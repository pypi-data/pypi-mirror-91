<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>devshell.shell API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>devshell.shell</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#if you go inside a directory, the python part of things shoud stay up at the top package level


import os, pkgutil, os.path, readline, inspect, doctest, sys, re, importlib, pdb, traceback, code, subprocess, shutil,textwrap, argparse, shlex
from contextlib import contextmanager
#from cmd import Cmd
from pypager.pager import Pager
from pypager.source import StringSource
from io import StringIO
from .injector import doctestify, get_target, get_ast_obj
from .ptcmd import PTCmd
from . import __version__



from prompt_toolkit.shortcuts import PromptSession
from prompt_toolkit.styles import Style
from pygments.lexers.shell import BashLexer, BatchLexer, FishShellLexer, PowerShellLexer, TcshLexer
from pygments.lexers.python import PythonConsoleLexer, PythonLexer
from prompt_toolkit.lexers import PygmentsLexer


@contextmanager
def capture_stdout():
    s = StringIO()
    sys.stdout = s
    yield s
    sys.stdout = sys.__stdout__
   
def run_cmd(cmd,do_paginate=False,print_also=False):
    print(&#39;Running command:\n  &#39;+&#39; &#39;.join(cmd))
    if not do_paginate:
        subprocess.run(cmd)
    else:
        proc = subprocess.run(cmd,stdout=subprocess.PIPE)
        text = proc.stdout.decode(&#39;utf-8&#39;,&#39;replace&#39;)
        paginate(text,print_also=print_also)

def run_coverage(sourcedir,arglist,sourcefilename=None):
    if sourcefilename is None:
        cmd1 = [sys.executable,&#39;-m&#39;,&#39;coverage&#39;,&#39;run&#39;,&#39;--source=&#39;+os.path.abspath(sourcedir),&#39;--parallel-mode&#39;,&#39;-m&#39;,&#39;pytest&#39;,&#39;--doctest-modules&#39;,os.path.abspath(sourcedir)]+arglist
    else:
        cmd1 = [sys.executable,&#39;-m&#39;,&#39;coverage&#39;,&#39;run&#39;,&#39;--source=&#39;+os.path.abspath(sourcedir),&#39;--include=&#34;&#39;+sourcefilename+&#39;&#34;&#39;,&#39;--parallel-mode&#39;,&#39;-m&#39;,&#39;pytest&#39;,&#39;--doctest-modules&#39;,os.path.abspath(os.path.join(sourcedir,sourcefilename))]+arglist
    cmd2 = [sys.executable,&#39;-m&#39;,&#39;coverage&#39;,&#39;combine&#39;]
    cmd3 = [sys.executable,&#39;-m&#39;,&#39;coverage&#39;,&#39;report&#39;,&#39;-m&#39;]
    cmd4 = [sys.executable,&#39;-m&#39;,&#39;coverage&#39;,&#39;erase&#39;]
    run_cmd(cmd1)
    run_cmd(cmd2)
    run_cmd(cmd3,do_paginate=True,print_also=True)
    run_cmd(cmd4)

def paginate(text,print_also=False):
    p=Pager()
    p.add_source(StringSource(text,lexer=None))
    p.run()
    if print_also:
        print(text)

def _get_args_kwargs(*args,**kwargs):
    return args,kwargs
def _auto_debug_handler(exc_type,exc_value,exc_traceback):
    traceback.print_exception(exc_type,exc_value,exc_traceback)
    pdb.post_mortem(exc_traceback)
_default_excepthook = sys.excepthook


class DevshellCmd(PTCmd):
    &#34;&#34;&#34;
    This implements the command line interface for devshell
    &#34;&#34;&#34;
    prompt = [(&#39;class:prompt&#39;,&#39;(devshell)$ &#39;)]
    intro = &#39;devshell version %s\nWelcome to devshell. Type help or ? to list commands. Start a line with ! to execute a shell command in a sub-shell (does not retain environmental variables).\n&#39; % __version__
    _cdable = set([&#39;package&#39;,&#39;module&#39;,&#39;class&#39;,&#39;root&#39;])
    _callable = set([&#39;function&#39;,&#39;method&#39;,&#39;coroutine&#39;,&#39;class&#39;])
    def __init__(self,completekey=&#39;tab&#39;,stdin=None,stdout=None):
        self.cwd = os.getcwd()
        self.orig_sys_path = sys.path
        if os.path.exists(os.path.join(self.cwd,&#39;__init__.py&#39;)):
            self.ppwd = [(os.path.basename(self.cwd),&#39;package&#39;)]
        else:
            self.ppwd = []
        self._pls_cache = None
        self.style = Style.from_dict({
            &#39;prompt&#39;:&#39;#ff0066&#39;,
            })
        super(DevshellCmd,self).__init__(completekey,stdin,stdout,lexer=PygmentsLexer(BashLexer),style=self.style)


    

    def _pls(self,args=&#39;&#39;):
        args = args.strip()
        if args != &#39;&#39;:
            orig_cwd = self.cwd
            orig_ppwd = list(self.ppwd)
            self._pls_cache = None
            self.do_pcd(args)
            result = self._pls(&#39;&#39;)
            self.cwd = orig_cwd
            os.chdir(orig_cwd)
            self.ppwd = orig_ppwd
            self._pls_cache = None
            return result
        else:
            if self._pls_cache is not None:
                return self._pls_cache
            if len(self.ppwd) == 0:
                self._pls_cache = [((mi[1],&#39;package&#39;) if mi[2] else (mi[1],&#39;module&#39;)) for mi in sorted(pkgutil.iter_modules([self.cwd,os.path.join(self.cwd,&#39;src&#39;)]),key=lambda mi: mi[1]) if (mi[1],mi[2]) != (&#39;setup&#39;,False)]
                return self._pls_cache
            else:
                current_name,current_type = self.ppwd[-1]
                if current_type == &#39;package&#39;:
                    _,bottom_folder = os.path.split(self.cwd)
                    mod_ppwd = list(self.ppwd)
                    for i,(package_name,_) in enumerate(self.ppwd):
                        if bottom_folder == package_name:
                            mod_ppwd = self.ppwd[i+1:]
                            break

                            


                    self._pls_cache = [((mi[1],&#39;package&#39;) if mi[2] else (mi[1],&#39;module&#39;)) for mi in sorted(pkgutil.iter_modules([os.path.join(self.cwd,*[item[0] for item in mod_ppwd])]),key=lambda mi: mi[1])]
                    package_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
                    cwd = self.cwd
                    current_sys_path = sys.path
                    while os.path.exists(os.path.join(cwd,&#39;__init__.py&#39;)):
                        cwd = os.path.dirname(cwd)
                    sys.path = self.orig_sys_path + [cwd]
                    try:
                        pkg = __import__(package_fqn)
                    except:
                        print(&#39;Could not fully import package: %s&#39; % package_fqn)
                        print(textwrap.indent(traceback.format_exc(),&#39;    &#39;))
                        return
                    finally:
                        sys.path = current_sys_path

                    for item in self.ppwd[1:]:
                        pkg = getattr(pkg,item[0])
                    for item_name,item in pkg.__dict__.items():
                        if inspect.getmodule(item) != pkg:
                            continue
                        if inspect.isfunction(item):
                            self._pls_cache.append((item_name,&#39;function&#39;))
                        elif hasattr(inspect,&#39;iscoroutinefunction&#39;) and inspect.iscoroutinefunction(item):
                            self._pls_cache.append((item_name,&#39;coroutine&#39;))
                        elif inspect.isclass(item):
                            self._pls_cache.append((item_name,&#39;class&#39;))
                    self._pls_cache.sort()
                    return self._pls_cache

                elif current_type == &#39;module&#39;:
                    module_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
                    try:
                        mod = __import__(module_fqn)
                    except:
                        print(&#39;Could not import module: %s&#39; % module_fqn)
                        print(textwrap.indent(traceback.format_exc(),&#39;    &#39;))
                        return
                    for item in self.ppwd[1:]:
                        mod = getattr(mod,item[0])
                    self._pls_cache = []
                    for item_name,item in mod.__dict__.items():
                        if inspect.getmodule(item) != mod:
                            continue
                        if inspect.isfunction(item):
                            self._pls_cache.append((item_name,&#39;function&#39;))
                        elif hasattr(inspect,&#39;iscoroutinefunction&#39;) and inspect.iscoroutinefunction(item):
                            self._pls_cache.append((item_name,&#39;coroutine&#39;))
                        elif inspect.isclass(item):
                            self._pls_cache.append((item_name,&#39;class&#39;))
                    self._pls_cache.sort()
                    return self._pls_cache
                elif current_type == &#39;class&#39;:
                    klass_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
                    try:
                        klass,_,_ = get_target(klass_fqn)
                    except:
                        print(&#39;Failed to get target: %s&#39; % klass_fqn)
                        return

                    self._pls_cache = []
                    for item_name,item in klass.__dict__.items():
                        if inspect.ismethod(item):
                            self._pls_cache.append((item_name,&#39;method&#39;))
                        elif inspect.isfunction(item):
                            self._pls_cache.append((item_name,&#39;function&#39;))
                        elif hasattr(inspect,&#39;iscoroutinefunction&#39;) and inspect.iscoroutinefunction(item):
                            self._pls_cache.append((item_name,&#39;coroutine&#39;))
                        elif inspect.isclass(item):
                            self._pls_cache.append((item_name,&#39;class&#39;))
                    self._pls_cache.sort()
                    return self._pls_cache
                else:
                    print(&#39;Error - cannot perform pls when targeting a %s - try to run &#34;pcd ..&#34; first&#39; % current_type)
                    return []

    def do_h(self,args):
        &#34;&#34;&#34; Alias for help &#34;&#34;&#34;
        self.do_help(args)
    def default(self,line):
        if line.startswith(&#39;!&#39;):
            line = line[1:]
        os.system(line)
    def do_pip(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ pip command [args...]

        Runs pip
        &#34;&#34;&#34;
        arglist = [arg.strip() for arg in args.split() if arg.strip() != &#39;&#39;]
        run_cmd([sys.executable,&#39;-m&#39;,&#39;pip&#39;]+arglist)
    def do_restart(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ restart

        Restarts devshell at the current working directory with the current path
        Sometimes needed to cleanly re-import scripts that were already imported and then changed.
        &#34;&#34;&#34;
        sys.exit(subprocess.run([sys.executable,&#39;-m&#39;,&#39;devshell&#39;,&#39;-d&#39;,os.path.abspath(os.getcwd()),&#39;-t&#39;,&#39;.&#39;.join([item[0] for item in self.ppwd])]).returncode)
    #def do_venv(self,args):
    #    &#34;&#34;&#34;
    #Help: (devshell)$ venv [env]
    #    Creates a virtual environment at the current location with the given name
    #    If no name is given, the name will be &#34;env&#34;
    #    &#34;&#34;&#34;
    #    if args.strip() == &#39;&#39;:
    #        args = &#39;env&#39;
    #    subprocess.run([sys.executable,&#39;-m&#39;,&#39;venv&#39;,args])
    #    self.do_activate(&#39;&#39;,bootstrap_devshell=True)
    #def do_activate(self,args,bootstrap_devshell=False):
    #    &#34;&#34;&#34;
    #Help: (devshell)$ activate [env]
    #    Activates the virtual environment at the current location with the given name
    #    If no name is given, the name will be &#34;env&#34;
    #    &#34;&#34;&#34;
    #    if args.strip() == &#39;&#39;:
    #        args = &#39;env&#39;
    #    cwd = os.path.abspath(os.getcwd())
    #    ppwd = &#39;.&#39;.join([item[0] for item in self.ppwd])
    #    if not bootstrap_devshell:
    #        if len(ppwd) &gt; 0:
    #            exec_str = &#39;{executable} -m devshell -d {cwd} -t {ppwd}&#39;.format(executable=os.path.basename(sys.executable),cwd=cwd,ppwd=ppwd)
    #
    #        else:
    #            exec_str = &#39;{executable} -m devshell -d {cwd}&#39;.format(executable=os.path.basename(sys.executable),cwd=cwd)
    #    else:
    #        exec_str = &#39;{executable} -m pip install devshell&#39;.format(executable=os.path.basename(sys.executable),cwd=cwd,ppwd=ppwd)
    #
    #
    #    if sys.platform in [&#39;win32&#39;,&#39;cygwin&#39;]:
    #        subprocess.run([&#39;cmd.exe&#39;,&#39;/C&#39;,r&#39;&#34;cd {cwd}; {env}\Scripts\activate.bat &amp; {exec_str}&#34;&#39;.format(env=args,cwd=cwd,exec_str=exec_str)])
    #    else:
    #        default_shell = os.environ[&#39;SHELL&#39;]
    #        shell_name = os.path.basename(default_shell)
    #        subprocess.run([default_shell,&#39;-c&#39;,&#39;&#34;cd {cwd}; source {env}/bin/activate; {exec_str}&#34;&#39;.format(env=args,cwd=cwd,exec_str=exec_str)])
    #
    #
    #def do_deactivate(self,args):
    #    &#34;&#34;&#34;
    #Help: (devshell)$ deactivate
    #    Deactivates the current virtual environment 
    #    Note: This will result in changing the current working directory and python target to what they were at the time the virtual environment was activated
    #    &#34;&#34;&#34;
    #    if &#39;VIRTUAL_ENV&#39; in os.environ:
    #        print(&#39;Exiting %s&#39; % os.environ[&#39;VIRTUAL_ENV&#39;])
    #        sys.exit(0)
    #    else:
    #        print(&#39;Not currently in a virtual environment&#39;)

    #def do_create(self,args):
    #    &#34;&#34;&#34;
    #Help: (devshell)$ create project_name
    #    Creates a new directory with the provided project name
    #    Creates a src subfolder with an empty python package with the project name
    #    Creates an empty tests python package
    #    Creates a setup.py
    #    Creates a LICENSE file (MIT)
    #    Creates a Makefile
    #    Creates a docs subfolder
    #    Creates a venv env and activates it
    #    &#34;&#34;&#34;

    def do_read(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ read filename
        Opens the selected file in a paginated view (similar to Unix &#34;less&#34; or &#34;more&#34; commands)
        The preferred locale encoding defined by locale.getpreferredencoding() is used
        &#34;&#34;&#34;
        with open(args,&#39;r&#39;) as f:
            text = f.read()
        paginate(text)



    def do_mkdir(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ mkdir dirname
        Creates the specified directory 
        &#34;&#34;&#34;
        os.mkdir(args)
    def do_rm(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ rm filename
        Deletes the file specified by filename. Will not delete a directory.
        See rmtree to delete a directory
        &#34;&#34;&#34;
        try:
            os.remove(args)
        except:
            traceback.print_exc()
            if &#39;-r&#39; in args:
                print(&#39;To remove a folder use the rmtree command&#39;)

    def do_rmtree(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ rmtree dirname
        Deletes the directory specified by dirname and all of its contents.
        See rm to delete a single file
        &#34;&#34;&#34;
        shutil.rmtree(args)

    def do_mv(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ mv source target
        Moves the file or folder at source to target
        &#34;&#34;&#34;
        try:
            src,dst = args.split()
        except:
            print(&#39;Invalid syntax&#39;)
            return
        shutil.move(src,dst)
    def do_cp(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ cp source target
        Copies the file or folder at source to target
        &#34;&#34;&#34;
        try:
            src,dst = args.split()
        except:
            print(&#39;Invalid syntax&#39;)
            return
        if os.path.isdir(src):
            shutil.copytree(src,dst)
        else:
            shutil.copy(src,dst)


    def do_run(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ run shellcmd [args...]
        Runs the given command in a subshell
        &#34;&#34;&#34;
        os.system(args)



    def do_edit(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ edit editor
        Runs the command editor, passing the file of the currently targeted object in as first argument.
        If no editor is specified, an error message will apppear.
        For most editors (e.g. vim, nano, etc), this will open the file for editing.
        If the current item is package, opens __init__.py.

        For editors that have some other command line invocation, see the devshell run command.
        &#34;&#34;&#34;
        editor = args.strip()
        if len(editor) == 0:
            print(&#39;Specify an editor (e.g. edit vim, edit nano, edit notepad++.exe, etc)&#39;)
            return
        else:
            editor=[editor]
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            current_name,current_type = self.ppwd[-1]
            if current_type == &#39;package&#39;:
                filepath = self._get_path() + &#39;__init__.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    run_cmd(editor+[filepath])
            elif current_type == &#39;module&#39;:
                filepath = self._get_path() + &#39;.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    run_cmd(editor+[filepath])
            else:
                try:
                    obj,mod,mod_fqn = get_target(target_fqn)
                except:
                    print(&#39;Failed to get target: %s&#39; % target_fqn)
                    return
                filepath = inspect.getsourcefile(obj)
                print(&#39;File:&#39;,filepath)
                run_cmd(editor+[filepath])
        else:
            print(&#39;No target identified&#39;)


    def _get_path(self):
        ppwd = list(self.ppwd)
        while len(ppwd) &gt; 0 and ppwd[-1][1] not in [&#39;package&#39;,&#39;module&#39;]:
            ppwd.pop(-1)
        current_name,current_type = ppwd[-1]
        _,bottom_folder = os.path.split(self.cwd)
        mod_names = list([name for name,_ in self.ppwd])
        for i,(package_name,_) in enumerate(self.ppwd):
            if bottom_folder == package_name:
                mod_names = [name for name,_ in self.ppwd[i+1:]]
                break
        return os.path.abspath(os.path.join(self.cwd,*mod_names))

    def do_editvim(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ editvim
        Opens vim to the first source line of the given target
        If on windows, opens gvim instead.
        &#34;&#34;&#34;
        if sys.platform == &#39;win32&#39; or sys.platform == &#39;cygwin&#39;:
            editor=[&#39;gvim&#39;]
        else:
            editor=[&#39;vim&#39;]
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            current_name,current_type = self.ppwd[-1]
            if current_type == &#39;package&#39;:
                filepath = self._get_path() + &#39;__init__.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:

                    run_cmd(editor+[filepath])
            elif current_type == &#39;module&#39;:

                _,bottom_folder = os.path.split(self.cwd)
                mod_ppwd = list(self.ppwd)
                for i,(package_name,_) in enumerate(self.ppwd):
                    if bottom_folder == package_name:
                        mod_ppwd = self.ppwd[i+1:]
                        break

                filepath = self._get_path() + &#39;.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    run_cmd(editor+[filepath])
            else:
                #try:
                if 1:
                    obj,mod,mod_fqn = get_target(target_fqn)
                    ast_obj,filepath,source,src_lines = get_ast_obj(target_fqn,obj,mod,mod_fqn)
                    lineno = ast_obj.lineno
                #except:
                if 0:
                    print(&#39;Failed to get target: %s&#39; % target_fqn)
                    return
                print(&#39;File:&#39;,filepath,&#39;Line:&#39;,str(lineno))
                run_cmd(editor+[filepath,&#39;+&#39;+str(lineno)])
        else:
            print(&#39;No target identified&#39;)



    def do_debug(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ debug(arg1,arg2,...,kwarg1=kwvalue1,kwarg2=kwvalue2,...)
        If currently targeting a class or function, this will attempt to load and call that code with the provided positional args and keyword args - entering pdb debug mode on the first line. 
        If currently targeting a package or module, this will enter debug mode at the first line of the module as if the module&#39;s file were directly run with python -m pdb &lt;filename&gt;.
       &#34;&#34;&#34;
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            args = args.strip()
            obj_type = self.ppwd[-1][1]
            if len(self.ppwd) == 0:
                print(&#39;No target is selected&#39;)
                return

            if obj_type in self._callable:
                if len(args) &gt; 0:
                    pargs,kwargs = eval(&#39;_get_args_kwargs{args}&#39;.format(args=args),sys.modules[obj.__module__].__dict__,{&#39;_get_args_kwargs&#39;:_get_args_kwargs})
                else:
                    pargs = tuple()
                    kwargs = {}
                try:
                    result = pdb.runcall(obj,*pargs,**kwargs)
                    print(&#39;Return value: %s&#39; % repr(result))
                except:
                    traceback.print_exc()
            else:
                if len(args) &gt; 0:
                    print(&#39;No arguments are excepted for object type %s&#39; % obj_type)
                else:
                    os.system(&#39;%s -m pdb %s&#39; % (sys.executable,os.path.abspath(inspect.getsourcefile(obj))))

        else:
            print(&#39;No target identified&#39;)


    def do_ls(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ ls path
        This lists the files/subfolders within the provided operating system folder path
        If path is not provided, then files/subfolders within the operating system folder path (current working directory) will be listed
        &#34;&#34;&#34;
        if args == &#39;&#39;:
            args = &#39;.&#39;
        if not os.path.exists(args):
            print(&#39;Error - path does not exist: %s&#39; % args)
            return
        if not os.path.isdir(args):
            print(&#39;Error - path is not a folder: %s&#39; % args)
            return
        lines = []
        for item in os.listdir(args):
            if os.path.isdir(item):
                itemtype = &#39;folder&#39;
            else:
                itemtype = &#39;file&#39;
            lines.append(&#39;    &#39;+item.ljust(30)+itemtype)
        lines.sort()
        print(&#39;\n&#39;.join(lines))



    def do_cd(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ cd path
        This changes the operating system folder path (current working directory) where devshell will look for packages and modules
        &#34;&#34;&#34;
        if os.path.exists(args) and os.path.isdir(args):
            if os.path.exists(os.path.join(args,&#39;__init__.py&#39;)):
                self.do_pcd(args)
            else:
                self.ppwd = []
                self._pls_cache = None
            os.chdir(args)
            self.cwd = os.getcwd()
            sys.path = self.orig_sys_path + [self.cwd]
        else:
            print(&#39;Error - path does not exist: %s&#39; % args)

    def do_doctestify(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ doctestify
          (devshell)$ doctestify resume
        Performs doctestify on the currently targeted item.
        This will cause an interactive python recording session to begin with all items from the targeted item&#39;s module imported in automatically.
        All inputs and outputs will be recorded and entered into the targeted item&#39;s docstring as a doctest.

        If &#34;doctestify resume&#34; is called, then the current doctest commands will be automatically executed into the interpreter
        &#34;&#34;&#34;
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            resume = args.strip() == &#39;resume&#39;
            doctestify(target_fqn,resume)
        else:
            print(&#39;No target identified&#39;)

    def do_quit(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ quit
        Exit the devshell shell.
        &#34;&#34;&#34;
        print(&#39;Exiting devshell shell...&#39;)
        return True
    def do_exit(self,args):
        &#34;&#34;&#34;
    Help:(devshell)$ exit
        Exit the devshell shell.
        &#34;&#34;&#34;
        return self.do_quit(args)
    def do_q(self,args):
        &#34;&#34;&#34;
    Help:(devshell)$ q 
        Exit the devshell shell.
        &#34;&#34;&#34;
        return self.do_quit(args)
    def do_EOF(self,args):
        &#34;&#34;&#34;
    Help: EOF
        Pressing Ctrl+D while in the devshell shell will result in exiting the devshell shell.
        Note that Ctrl+D is also used to terminate an interactive recording session and return to the devshell shell.
        &#34;&#34;&#34;
        return self.do_quit(args)
    def do_doctest(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ doctest [verbose]
        This runs the current doctests for the currently targeted item. verbose can be True or False. If unspecified, verbose=False.
        &#34;&#34;&#34;
        if len(self.ppwd) == 0:
            print(&#39;No target identified&#39;)
            return
        current_type = self.ppwd[-1][1]
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            if len(args.strip()) &gt; 0:
                verbose = eval(args)
            else:
                verbose = False

            try:
                stdout_capture = StringIO()
                sys.stdout = stdout_capture
                
                if current_type in self._callable:
                    importlib.reload(mod)
                    importlib.reload(sys.modules[obj.__module__])
                    doctest.run_docstring_examples(obj,sys.modules[obj.__module__].__dict__,verbose)
                elif current_type in [&#39;package&#39;,&#39;module&#39;]:
                    importlib.reload(mod)
                    importlib.reload(obj)
                    doctest.testmod(obj,verbose=verbose)
                else:
                    sys.stdout = sys.__stdout__
                    print(&#39;Invalid type to run doctest: %s&#39; % current_type)
                    return
                sys.stdout = sys.__stdout__
                results = stdout_capture.getvalue()
                if len(results) != 0:
                    paginate(results)
                else:
                    print(&#39;All doctests passed&#39;)
            except:
                sys.stdout = sys.__stdout__
                traceback.print_exc()
        else:
            print(&#39;No target identified&#39;)
    def do_pytest(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ pytest [pytest_args]
        This runs the pytest against the currently targeted item. 
        If pytest is not installed, an error message will be printed.

        The --doctest-modules option is automatically inserted.

        pytest_args are defined in the pytest documentation:
            https://docs.pytest.org/en/latest/usage.html
            See --pdb, --trace, --capture

        If there is no currently targeted item, pytest will be run against the folder indicated by pwd:
            (devshell)$ pytest -ra --doctest-modules
                is equivalent to:
                    python -m pytest . -ra --doctest-modules

        If there is a target item, pytest will be run specifically against that item.
            For example, if the currently target object is mypackage.my_module.MyClass.my_test_method, then running 
            (devshell)$ pytest -ra
                is equivalent to:
                    python -m pytest  /fullpathto/mypackage/my_module.py::MyClass::my_test_method --doctest-modules -ra
        &#34;&#34;&#34;
        try:
            import pytest
        except:
            print(&#39;pytest is not installed&#39;)
            return


        arglist = [arg.strip() for arg in args.split() if arg.strip() != &#39;&#39;]
        if len(self.ppwd) == 0:
            run_cmd([sys.executable,&#39;-m&#39;,&#39;pytest&#39;,os.path.abspath(self.cwd),&#39;--doctest-modules&#39;]+arglist)
            return
        current_type = self.ppwd[-1][1]

        item_names = []
        reached_module = False
        item_names_inside_module = []
        for item_name,item_type in self.ppwd:
            item_names.append(item_name)
            if reached_module:
                item_names_inside_module.append(item_name)
            if item_type == &#39;module&#39;:
                reached_module = True
        target_fqn = &#39;.&#39;.join(item_names)
        if target_fqn != &#39;&#39;:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                sys.stdout = sys.__stdout__
                #results = stdout_capture.getvalue()
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            sourcefile = inspect.getsourcefile(obj)
            if current_type == &#39;package&#39;:
                sourcefile = os.path.dirname(sourcefile)
            pytest_node_id = &#39;::&#39;.join([os.path.abspath(sourcefile)]+item_names_inside_module)
            run_cmd([sys.executable,&#39;-m&#39;,&#39;pytest&#39;,pytest_node_id,&#39;--doctest-modules&#39;]+arglist)
        else:
            run_cmd([sys.executable,&#39;-m&#39;,&#39;pytest&#39;,os.path.abspath(self.cwd),&#39;--doctest-modules&#39;]+arglist)

    def do_coverage(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ coverage [pytest_args]
        This runs coverage and pytest against the source file containing the currently targeted item. 
        This does not use the pytest-cov plugin, just the coverage and pytest packages themselves.
        If pytest and/or coverage are not installed, an error message will be printed.

        The --doctest-modules pytest argument is automatically inserted.

        pytest_args are defined in the pytest documentation:
            https://docs.pytest.org/en/latest/usage.html
            See --pdb, --trace, --capture

        If there is no currently targeted item, coverage and pytest will be run against the folder indicated by pwd:
            (devshell)$ coverage -ra
                is functionally equivalent to:
                    python -m coverage run --parallel-mode --source=. pytest . -ra --doctest-modules
                    python -m coverage report -m

        If there is a target item, coverage and pytest will be run specifically against the entire source file containing that item.
            For example, if the currently target object is mypackage.my_module.MyClass.my_test_method, then running 
            (devshell)$ coverage -ra
                is functionally equivalent to:
                    python -m coverage run --parallel-mode --source=/fullpathto/mypackage --include=my_module.py pytest  /fullpathto/mypackage/my_module.py -ra --doctest-modules
                    python -m coverage report -m
        &#34;&#34;&#34;
        try:
            import coverage
        except ImportError:
            print(&#39;coverage is not installed&#39;)
            return
        try:
            import pytest
        except ImportError:
            print(&#39;pytest is not installed&#39;)
            return
        arglist = [arg.strip() for arg in args.split() if arg.strip() != &#39;&#39;]
        if len(self.ppwd) == 0:
            run_coverage(self.cwd,arglist)
            return
        current_type = self.ppwd[-1][1]
        item_names = []
        reached_module = False
        item_names_inside_module = []
        for item_name,item_type in self.ppwd:
            item_names.append(item_name)
            if reached_module:
                item_names_inside_module.append(item_name)
            if item_type == &#39;module&#39;:
                reached_module = True
        target_fqn = &#39;.&#39;.join(item_names)
        if target_fqn != &#39;&#39;:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                sys.stdout = sys.__stdout__
                #results = stdout_capture.getvalue()
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            sourcefile = inspect.getsourcefile(obj)
            sourcefilename = os.path.basename(sourcefile)
            sourcedir = os.path.dirname(sourcefile)
            run_coverage(sourcedir,arglist,sourcefilename)
        else:
            run_coverage(self.cwd,arglist)
    def do_source(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ source
        This displays the file name and source code for the currently targeted item.
        &#34;&#34;&#34;
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            current_name,current_type = self.ppwd[-1]
            if current_type == &#39;package&#39;:
                filepath = self._get_path() + &#39;/__init__.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    with open(filepath,&#39;r&#39;) as f:
                        paginate(f.read())
            elif current_type == &#39;module&#39;:
                filepath = self._get_path() + &#39;.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    with open(filepath,&#39;r&#39;) as f:
                        paginate(f.read())
            else:
                try:
                    obj,mod,mod_fqn = get_target(target_fqn)
                except:
                    print(&#39;Failed to get target: %s&#39; % target_fqn)
                    return
                filepath = inspect.getsourcefile(obj)
                print(&#39;File:&#39;,filepath)
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    paginate(inspect.getsource(obj))
        else:
            print(&#39;No target identified&#39;)
    def do_grep(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ grep pattern [OPTIONS]
        Searches the source code of the currently targeted item based on the provided regular expression.
        The source is split into lines and the regular expression is applied to each line.
        Files are opened for reading in string mode with errors being handled via open()&#39;s errors=&#39;backslashreplace&#39; option
        Regular expressions are according to python interpretation (not standard grep).
        Only includes python source files (.py$|.py[w3wxi]$|.pxd$)
        If a package is selected, all files will be looked at.
        If a module is selected, the module will be looked at.
        If a sub-module item is selected, only that items source code will be looked at.

        Supported options:
            -i = Ignore case (re.IGNORECASE)
                Normally, matching is case sensitive
                With -i specified, matching is case-insensitive

            -v = Invert match
                Normally, lines that match the pattern are included
                With -v, lines that do not match the pattern are included
            -p = Print to console after displaying
                Normally, the results will be paginated in a page viewer (similar to unix less)
                With -p, the results will be paginated and then printed to the console after
                
        &#34;&#34;&#34;
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            current_name,current_type = self.ppwd[-1]
            if current_type == &#39;package&#39;:
                #recurse through package directory
                path = self._get_path() 
                grep(args,path=path)
                
            elif current_type == &#39;module&#39;:
                filepath = self._get_path() + &#39;.py&#39;
                grep(args,path=filepath)
            else:
                try:
                    obj,mod,mod_fqn = get_target(target_fqn)
                except:
                    print(&#39;Failed to get target: %s&#39; % target_fqn)
                    return
                filepath = inspect.getsourcefile(obj)
                print(&#39;File:&#39;,filepath)
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    grep(args,source=inspect.getsource(obj),path=filepath)
        else:
            path = os.path.abspath(os.getcwd())
            grep(args,path=path)

    def do_doc(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ doc
        This displays the docstring for the currently targeted item.
        &#34;&#34;&#34;
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            doc = inspect.getdoc(obj)
            lines = []
            if self.ppwd[-1][1] in self._callable:
                lines.append(self.ppwd[-1][1]+&#39;: &#39;+self.ppwd[-1][0] + str(inspect.signature(obj)))
            else:
                lines.append(self.ppwd[-1][1]+&#39;: &#39;+self.ppwd[-1][0])
            if doc is not None:
                lines.append(&#39;&#34;&#34;&#34;&#39;)
                lines.append(re.sub(&#39;\n&#39;,&#39;\n    &#39;,doc))
                lines.append(&#39;&#34;&#34;&#34;&#39;)
            else:
                lines.append(&#39;&#39;)
                lines.append(&#39;No docstring exists for target&#39;)
            result = (&#39;    &#39;+&#39;\n    &#39;.join(lines))
            if len(result.strip()) != 0:
                paginate(result,print_also=True)
            else:
                print(&#39;No documentation exists for the given target&#39;)
        else:
            print(&#39;No target identified&#39;)
        

    def do_pwd(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ pwd
        This displays the operating system folder path (current working directory) where devshell will look for packages and modules
        &#34;&#34;&#34;
        print(self.cwd)
    def do_pls(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ pls [python_object]
        This will show all items contained within the currently targeted item.
            e.g. for a package, this would list the modules
            e.g. for a module, this would list the functions and classes
            etc
        If there is no currently targeted item, then all packages in the current working directory or within a subfolder of the current working directory named &#34;src&#34; will be shown.
        Note that using this command may result in importing the module containing the currently targeted item.
        Note that setup.py files will be purposefully excluded because importing/inspecting them without providing commands results in terminating python.

        For tab completion, use the dot &#34;.&#34; character to separate python items, not the slash &#34;/&#34; character.

        &#34;&#34;&#34;
        lines = []
        result = self._pls(args)
        if result is None:
            return
        for item_name,item_type in result: 
            if item_type in self._cdable:
                if len(self.ppwd) == 0 and item_type == &#39;package&#39; and not os.path.exists(os.path.join(self.cwd,item_name,&#39;__init__.py&#39;)) and os.path.exists(os.path.join(self.cwd,&#39;src&#39;,item_name,&#39;__init__.py&#39;)):
                    lines.append(&#39;    %s%sdirectory (./src)&#39; % (item_name.ljust(30), item_type.ljust(30)))
                else:
                    lines.append(&#39;    %s%sdirectory&#39; % (item_name.ljust(30), item_type.ljust(30)))

            else:
                lines.append(&#39;    %s%snon-directory&#39; % (item_name.ljust(30), item_type.ljust(30)))
        print(&#39;\n&#39;.join(lines))
    def _ppwd(self):
        if len(self.ppwd) &gt; 0:
            return (&#39;/&#39;+&#39;.&#39;.join(item[0] for item in self.ppwd),self.ppwd[-1][1])
        else:
            return &#39;/&#39;,&#39;root&#39;
    def do_ppwd(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ ppwd
        This shows the fully qualified name of the currently targeted item.

        &#34;&#34;&#34;
        ppwd,current_type = self._ppwd()
        print(&#39;%s (%s)&#39; % (ppwd.ljust(30),current_type))

    def _pcd(self,args):
        resolved = False
        clear_pls_cache = False
        if args == &#39;.&#39;:
            resolved = True
            clear_pls_cache = False
        elif args == &#39;..&#39;:
            if len(self.ppwd) &gt; 0:
                last_item,last_item_type = self.ppwd.pop()
                if len(self.ppwd) == 0 and last_item_type == &#39;package&#39; and os.path.basename(self.cwd) == &#39;src&#39; and os.path.exists(os.path.join(self.cwd,last_item,&#39;__init__.py&#39;)) and not os.path.exists(os.path.join(self.cwd,&#39;..&#39;,last_item,&#39;__init__.py&#39;)):
                    self.do_cd(&#39;..&#39;)

            resolved = True
            clear_pls_cache = True
            #go up if in src
        elif args == &#39;/&#39;:
            del self.ppwd[:]
            resolved = True
            clear_pls_cache = True
        elif &#39;.&#39; not in args:
            for item,item_type in self._pls():
                if item == args:
                    if len(self.ppwd) == 0 and item_type == &#39;package&#39; and not os.path.exists(os.path.join(self.cwd,item,&#39;__init__.py&#39;)) and os.path.exists(os.path.join(self.cwd,&#39;src&#39;,item,&#39;__init__.py&#39;)):
                        self.do_cd(&#39;src&#39;)
                    self.ppwd.append((item,item_type))
                    resolved = True
                    clear_pls_cache = True
                    break
        else:
            pieces = args.split(&#39;.&#39;)
            orig_ppwd = list(self.ppwd)
            resolved = True
            clear_pls_cache = False
            orig_pls_cache = self._pls_cache
            for piece in pieces:
                self._pls_cache = None
                piece_resolved,piece_clear_pls_cache = self._pcd(piece)
                if not piece_resolved:
                    resolved = False
                    self.ppwd = orig_ppwd
                    clear_pls_cache = False
                    break
                else:
                    clear_pls_cache = clear_pls_cache or piece_clear_pls_cache
            self._pls_cache = orig_pls_cache
        return (resolved,clear_pls_cache)
    def do_interactive(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ interactive
        Opens a python interactive session
        &#34;&#34;&#34;
        console = code.InteractiveConsole()
        console.interact()
    def do_python(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ python
        Opens a python interactive session
        &#34;&#34;&#34;
        self.do_interactive(args)

    def do_pcd(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ pcd &lt;argument&gt;
        This changes the currently targeted item.
        
        &lt;argument&gt; can be part of a fully qualified name to append to the end of the current target.

        If there is no current target, then one may pcd into a package within the current working directory or within a package in a subfolder of the current working directory named &#34;src&#34;.
        Cding into the &#34;src&#34; subfolder only occurs when the src subfolder has the package with the given name and the current working directory does not.
        Cding into the &#34;src&#34; subfolder will change the current working directory to be the &#34;src&#34; subfolder.
        Command completion is supported via the tab key.
        Note that performing command line completion at a level may result in importing/loading the module containing the item being examined.

        The following are special invocations:

            (devshell)$ pcd /
                This will remove all parts of the current fully qualified name

            (devshell)$ pcd .
                This has no effect

            (devshell)$ pcd ..
                This removes the last piece of the currently fully qualified name (navigates up to the parent item)
                If leaving a package to a subfolder named &#34;src&#34;, will also change the current working directory to be the parent directory of &#34;src&#34; if a package with the current target as its name exists only in the &#34;src&#34; directory and not in the parent directory.

        &#34;&#34;&#34;
        resolved,clear_pls_cache = self._pcd(args)
        if not resolved is True:
            print(&#39;Error - &#34;%s&#34; does not exist&#39; % args)
        #else:
        #    self.prompt = &#39;(devshell)%s$ &#39; % self._ppwd()
        if clear_pls_cache:
            self._pls_cache = None
    def complete_pcd(self,text,line,begin_idx,end_idx):
        return self._complete_python(text,line,begin_idx,end_idx)
    def complete_pls(self,text,line,begin_idx,end_idx):
        return self._complete_python(text,line,begin_idx,end_idx)
    def _complete_python(self,text,line,begin_idx,end_idx):
        orig_cwd = self.cwd
        last_piece = shlex.split(text)[-1]
        if &#39;.&#39; not in text:
            results = [item[0] for item in self._pls() if item[0].startswith(last_piece)]
            if self.cwd != orig_cwd:
                self.cwd = orig_cwd
                os.chdir(orig_cwd)
            return results

        elif set(last_piece) == set([&#39;.&#39;]):
            return []
        else:
            orig_ppwd = list(self.ppwd)
            orig_pls_cache = self._pls_cache
            ts = text.split(&#39;.&#39;)
            #front = &#39;.&#39;.join(ts[:-1])
            front = shlex.join(shlex.split(&#39;.&#39;.join(ts[:-1]))[1:])
            
            last_piece = ts[-1]
            resolved,clear_pls_cache = self._pcd(front)
            #resolved,clear_pls_cache = self._pcd(shlex.join(shlex.split(front)[1:]))
            if resolved:
                self._pls_cache = None
                results = [front+&#39;.&#39;+item[0] for item in self._pls() if item[0].startswith(last_piece)]
            else:
                results = []
            self.ppwd = orig_ppwd
            self._pls_cache = orig_pls_cache
            if self.cwd != orig_cwd:
                self.cwd = orig_cwd
                os.chdir(orig_cwd)
            return results
    def complete_cd(self,text,line,begin_idx,end_idx):
        return self._complete_dirs(&#39;cd&#39;,text,line,begin_idx,end_idx)

    def complete_ls(self,text,line,begin_idx,end_idx):
        return self._complete_dirs(&#39;ls&#39;,text,line,begin_idx,end_idx)

    def complete_rmtree(self,text,line,begin_idx,end_idx):
        return self._complete_dirs(&#39;rmtree&#39;,text,line,begin_idx,end_idx)
    
    def complete_rm(self,text,line,begin_idx,end_idx):
        return self._complete_files(&#39;rm&#39;,text,line,begin_idx,end_idx)

    def complete_cp(self,text,line,begin_idx,end_idx):
        return self._complete_lastdirfile(&#39;cp&#39;,text,line,begin_idx,end_idx)
    def complete_mv(self,text,line,begin_idx,end_idx):
        return self._complete_lastdirfile(&#39;mv&#39;,text,line,begin_idx,end_idx)
    def complete_read(self,text,line,begin_idx,end_idx):
        return self._complete_files(&#39;read&#39;,text,line,begin_idx,end_idx)
    def complete_run(self,text,line,begin_idx,end_idx):
        return self._complete_lastdirfile(&#39;run&#39;,text,line,begin_idx,end_idx)
    def completedefault(self,text,line,begin_idx,end_idx):
        return self._complete_lastdirfile(None,text,line,begin_idx,end_idx)

    def _complete_dirs(self,cmd,text,line,begin_idx,end_idx):
        path = re.sub(&#39;^\\s*%s\\s*&#39;%cmd,&#39;&#39;,line)
        pieces = re.split(&#39;([/\\\\])&#39;,path)
        if len(pieces) &gt; 1:
            front = &#39;&#39;.join(pieces[:-2])
            if front == &#39;&#39;:
                front = &#39;.&#39;
            last_dlm = pieces[-2]
            last_piece = pieces[-1]
        else:
            front = &#39;.&#39;
            last_piece = path
        return [(os.path.join(front,item) if front != &#39;.&#39; else item) for item in os.listdir(front) if item.startswith(last_piece) and os.path.isdir(os.path.join(front,item))]

    def _complete_files(self,cmd,text,line,begin_idx,end_idx):
        path = re.sub(&#39;^\\s*%s\\s*&#39;%cmd,&#39;&#39;,line)
        pieces = re.split(&#39;([/\\\\])&#39;,path)
        if len(pieces) &gt; 1:
            front = &#39;&#39;.join(pieces[:-2])
            if front == &#39;&#39;:
                front = &#39;.&#39;
            last_dlm = pieces[-2]
            last_piece = pieces[-1]
        else:
            front = &#39;.&#39;
            last_piece = path
        return [(os.path.join(front,item) if front != &#39;.&#39; else item) for item in os.listdir(front) if item.startswith(last_piece) and not os.path.isdir(os.path.join(front,item))]
    def _complete_lastdirfile(self,cmd,text,line,begin_idx,end_idx):
        if cmd is not None:
            paths = re.sub(&#39;^\\s*%s\\s*&#39;%cmd,&#39;&#39;,line)
        else:
            paths = line
        qc = len(re.findall(&#39;(?&lt;!\\\\)&#34;&#39;,paths))
        if qc &gt; 0:
            #non-escaped quotes found

            #get the position of the right-most non-escaped quote
            rq_pos = len(paths) - 1 - re.search(&#39;&#34;(?!\\\\)&#39;,paths[::-1]).start(0)
            if qc % 2 == 0:
                #there are an even number of quotes i.e. we are outside of any quoted argument
                path = paths[rq_pos+1:].strip()

            else:
                #there are an odd number of quotes i.e. we are in the middle of a quoted argument
                path = paths[rq_pos+1:]
        else:
            rs_match = re.search(&#39; (?!\\\\)&#39;,paths[::-1])
            if rs_match is not None:
                #there are non-escaped spaces
                rs_pos = len(paths) - 1 - rs_match.start(0)
                path = paths[rs_pos+1:].strip()
            else:
                #there are no spaces
                path = paths
        pieces = re.split(&#39;([/\\\\])&#39;,path)
        if len(pieces) &gt; 1:
            front = &#39;&#39;.join(pieces[:-2])
            if front == &#39;&#39;:
                front = &#39;.&#39;
            last_dlm = pieces[-2]
            last_piece = pieces[-1]
        else:
            front = &#39;.&#39;
            last_piece = path
        return [item for item in os.listdir(front) if item.startswith(last_piece)]

def grep(args,source=None,path=None):
    parser = argparse.ArgumentParser()
    parser.add_argument(&#39;pattern&#39;)
    parser.add_argument(&#39;-i&#39;,action=&#39;store_true&#39;)
    parser.add_argument(&#39;-v&#39;,action=&#39;store_true&#39;)
    parser.add_argument(&#39;-p&#39;,action=&#39;store_true&#39;)
    parsed_args = parser.parse_args(shlex.split(args))


    flags = (re.I if parsed_args.i else 0)
    invert_match = parsed_args.v

    regex = re.compile(parsed_args.pattern,flags)
    if source is None:
        def sourcegen_func():
            if os.path.isdir(path):
                #recurse
                pathgen = ((os.path.join(dirpath,filename) for filename in filenames) for dirpath,dirnames,filenames in os.walk(path))
            else:
                pathgen = ((path for _ in [None]) for _ in [None])
            for filegen in pathgen:
                for filepath in filegen:
                    if re.search(&#39;^\\.(py|py[w3wxi]|pxd)$&#39;,os.path.splitext(filepath)[1]) is not None:
                        with open(filepath,&#39;r&#39;,errors=&#39;backslashreplace&#39;) as f:
                            source = f.read()
                        yield (source,filepath)
        sourcegen = sourcegen_func()
    else:
        sourcegen = ((source,path) for _ in [None])
    output_lines = []
    for source,path in sourcegen:
        filename = os.path.basename(path)
        for line_i,line in enumerate(source.splitlines()):
            matched = regex.search(line) is not None
            include = matched ^ invert_match
            if include:
                output_lines.append(&#39;:&#39;.join([filename,str(line_i),line]))
    results = &#39;\n&#39;.join(output_lines)
    paginate(results)
    if parsed_args.p:
        print(results)
    return results</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="devshell.shell.capture_stdout"><code class="name flex">
<span>def <span class="ident">capture_stdout</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def capture_stdout():
    s = StringIO()
    sys.stdout = s
    yield s
    sys.stdout = sys.__stdout__</code></pre>
</details>
</dd>
<dt id="devshell.shell.grep"><code class="name flex">
<span>def <span class="ident">grep</span></span>(<span>args, source=None, path=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grep(args,source=None,path=None):
    parser = argparse.ArgumentParser()
    parser.add_argument(&#39;pattern&#39;)
    parser.add_argument(&#39;-i&#39;,action=&#39;store_true&#39;)
    parser.add_argument(&#39;-v&#39;,action=&#39;store_true&#39;)
    parser.add_argument(&#39;-p&#39;,action=&#39;store_true&#39;)
    parsed_args = parser.parse_args(shlex.split(args))


    flags = (re.I if parsed_args.i else 0)
    invert_match = parsed_args.v

    regex = re.compile(parsed_args.pattern,flags)
    if source is None:
        def sourcegen_func():
            if os.path.isdir(path):
                #recurse
                pathgen = ((os.path.join(dirpath,filename) for filename in filenames) for dirpath,dirnames,filenames in os.walk(path))
            else:
                pathgen = ((path for _ in [None]) for _ in [None])
            for filegen in pathgen:
                for filepath in filegen:
                    if re.search(&#39;^\\.(py|py[w3wxi]|pxd)$&#39;,os.path.splitext(filepath)[1]) is not None:
                        with open(filepath,&#39;r&#39;,errors=&#39;backslashreplace&#39;) as f:
                            source = f.read()
                        yield (source,filepath)
        sourcegen = sourcegen_func()
    else:
        sourcegen = ((source,path) for _ in [None])
    output_lines = []
    for source,path in sourcegen:
        filename = os.path.basename(path)
        for line_i,line in enumerate(source.splitlines()):
            matched = regex.search(line) is not None
            include = matched ^ invert_match
            if include:
                output_lines.append(&#39;:&#39;.join([filename,str(line_i),line]))
    results = &#39;\n&#39;.join(output_lines)
    paginate(results)
    if parsed_args.p:
        print(results)
    return results</code></pre>
</details>
</dd>
<dt id="devshell.shell.paginate"><code class="name flex">
<span>def <span class="ident">paginate</span></span>(<span>text, print_also=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paginate(text,print_also=False):
    p=Pager()
    p.add_source(StringSource(text,lexer=None))
    p.run()
    if print_also:
        print(text)</code></pre>
</details>
</dd>
<dt id="devshell.shell.run_cmd"><code class="name flex">
<span>def <span class="ident">run_cmd</span></span>(<span>cmd, do_paginate=False, print_also=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_cmd(cmd,do_paginate=False,print_also=False):
    print(&#39;Running command:\n  &#39;+&#39; &#39;.join(cmd))
    if not do_paginate:
        subprocess.run(cmd)
    else:
        proc = subprocess.run(cmd,stdout=subprocess.PIPE)
        text = proc.stdout.decode(&#39;utf-8&#39;,&#39;replace&#39;)
        paginate(text,print_also=print_also)</code></pre>
</details>
</dd>
<dt id="devshell.shell.run_coverage"><code class="name flex">
<span>def <span class="ident">run_coverage</span></span>(<span>sourcedir, arglist, sourcefilename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_coverage(sourcedir,arglist,sourcefilename=None):
    if sourcefilename is None:
        cmd1 = [sys.executable,&#39;-m&#39;,&#39;coverage&#39;,&#39;run&#39;,&#39;--source=&#39;+os.path.abspath(sourcedir),&#39;--parallel-mode&#39;,&#39;-m&#39;,&#39;pytest&#39;,&#39;--doctest-modules&#39;,os.path.abspath(sourcedir)]+arglist
    else:
        cmd1 = [sys.executable,&#39;-m&#39;,&#39;coverage&#39;,&#39;run&#39;,&#39;--source=&#39;+os.path.abspath(sourcedir),&#39;--include=&#34;&#39;+sourcefilename+&#39;&#34;&#39;,&#39;--parallel-mode&#39;,&#39;-m&#39;,&#39;pytest&#39;,&#39;--doctest-modules&#39;,os.path.abspath(os.path.join(sourcedir,sourcefilename))]+arglist
    cmd2 = [sys.executable,&#39;-m&#39;,&#39;coverage&#39;,&#39;combine&#39;]
    cmd3 = [sys.executable,&#39;-m&#39;,&#39;coverage&#39;,&#39;report&#39;,&#39;-m&#39;]
    cmd4 = [sys.executable,&#39;-m&#39;,&#39;coverage&#39;,&#39;erase&#39;]
    run_cmd(cmd1)
    run_cmd(cmd2)
    run_cmd(cmd3,do_paginate=True,print_also=True)
    run_cmd(cmd4)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="devshell.shell.DevshellCmd"><code class="flex name class">
<span>class <span class="ident">DevshellCmd</span></span>
<span>(</span><span>completekey='tab', stdin=None, stdout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the command line interface for devshell</p>
<p>Instantiate a line-oriented interpreter framework.</p>
<p>The optional argument 'completekey' is the readline name of a
completion key; it defaults to the Tab key. If completekey is
not None and the readline module is available, command completion
is done automatically. The optional arguments stdin and stdout
specify alternate input and output file objects; if not specified,
sys.stdin and sys.stdout are used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DevshellCmd(PTCmd):
    &#34;&#34;&#34;
    This implements the command line interface for devshell
    &#34;&#34;&#34;
    prompt = [(&#39;class:prompt&#39;,&#39;(devshell)$ &#39;)]
    intro = &#39;devshell version %s\nWelcome to devshell. Type help or ? to list commands. Start a line with ! to execute a shell command in a sub-shell (does not retain environmental variables).\n&#39; % __version__
    _cdable = set([&#39;package&#39;,&#39;module&#39;,&#39;class&#39;,&#39;root&#39;])
    _callable = set([&#39;function&#39;,&#39;method&#39;,&#39;coroutine&#39;,&#39;class&#39;])
    def __init__(self,completekey=&#39;tab&#39;,stdin=None,stdout=None):
        self.cwd = os.getcwd()
        self.orig_sys_path = sys.path
        if os.path.exists(os.path.join(self.cwd,&#39;__init__.py&#39;)):
            self.ppwd = [(os.path.basename(self.cwd),&#39;package&#39;)]
        else:
            self.ppwd = []
        self._pls_cache = None
        self.style = Style.from_dict({
            &#39;prompt&#39;:&#39;#ff0066&#39;,
            })
        super(DevshellCmd,self).__init__(completekey,stdin,stdout,lexer=PygmentsLexer(BashLexer),style=self.style)


    

    def _pls(self,args=&#39;&#39;):
        args = args.strip()
        if args != &#39;&#39;:
            orig_cwd = self.cwd
            orig_ppwd = list(self.ppwd)
            self._pls_cache = None
            self.do_pcd(args)
            result = self._pls(&#39;&#39;)
            self.cwd = orig_cwd
            os.chdir(orig_cwd)
            self.ppwd = orig_ppwd
            self._pls_cache = None
            return result
        else:
            if self._pls_cache is not None:
                return self._pls_cache
            if len(self.ppwd) == 0:
                self._pls_cache = [((mi[1],&#39;package&#39;) if mi[2] else (mi[1],&#39;module&#39;)) for mi in sorted(pkgutil.iter_modules([self.cwd,os.path.join(self.cwd,&#39;src&#39;)]),key=lambda mi: mi[1]) if (mi[1],mi[2]) != (&#39;setup&#39;,False)]
                return self._pls_cache
            else:
                current_name,current_type = self.ppwd[-1]
                if current_type == &#39;package&#39;:
                    _,bottom_folder = os.path.split(self.cwd)
                    mod_ppwd = list(self.ppwd)
                    for i,(package_name,_) in enumerate(self.ppwd):
                        if bottom_folder == package_name:
                            mod_ppwd = self.ppwd[i+1:]
                            break

                            


                    self._pls_cache = [((mi[1],&#39;package&#39;) if mi[2] else (mi[1],&#39;module&#39;)) for mi in sorted(pkgutil.iter_modules([os.path.join(self.cwd,*[item[0] for item in mod_ppwd])]),key=lambda mi: mi[1])]
                    package_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
                    cwd = self.cwd
                    current_sys_path = sys.path
                    while os.path.exists(os.path.join(cwd,&#39;__init__.py&#39;)):
                        cwd = os.path.dirname(cwd)
                    sys.path = self.orig_sys_path + [cwd]
                    try:
                        pkg = __import__(package_fqn)
                    except:
                        print(&#39;Could not fully import package: %s&#39; % package_fqn)
                        print(textwrap.indent(traceback.format_exc(),&#39;    &#39;))
                        return
                    finally:
                        sys.path = current_sys_path

                    for item in self.ppwd[1:]:
                        pkg = getattr(pkg,item[0])
                    for item_name,item in pkg.__dict__.items():
                        if inspect.getmodule(item) != pkg:
                            continue
                        if inspect.isfunction(item):
                            self._pls_cache.append((item_name,&#39;function&#39;))
                        elif hasattr(inspect,&#39;iscoroutinefunction&#39;) and inspect.iscoroutinefunction(item):
                            self._pls_cache.append((item_name,&#39;coroutine&#39;))
                        elif inspect.isclass(item):
                            self._pls_cache.append((item_name,&#39;class&#39;))
                    self._pls_cache.sort()
                    return self._pls_cache

                elif current_type == &#39;module&#39;:
                    module_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
                    try:
                        mod = __import__(module_fqn)
                    except:
                        print(&#39;Could not import module: %s&#39; % module_fqn)
                        print(textwrap.indent(traceback.format_exc(),&#39;    &#39;))
                        return
                    for item in self.ppwd[1:]:
                        mod = getattr(mod,item[0])
                    self._pls_cache = []
                    for item_name,item in mod.__dict__.items():
                        if inspect.getmodule(item) != mod:
                            continue
                        if inspect.isfunction(item):
                            self._pls_cache.append((item_name,&#39;function&#39;))
                        elif hasattr(inspect,&#39;iscoroutinefunction&#39;) and inspect.iscoroutinefunction(item):
                            self._pls_cache.append((item_name,&#39;coroutine&#39;))
                        elif inspect.isclass(item):
                            self._pls_cache.append((item_name,&#39;class&#39;))
                    self._pls_cache.sort()
                    return self._pls_cache
                elif current_type == &#39;class&#39;:
                    klass_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
                    try:
                        klass,_,_ = get_target(klass_fqn)
                    except:
                        print(&#39;Failed to get target: %s&#39; % klass_fqn)
                        return

                    self._pls_cache = []
                    for item_name,item in klass.__dict__.items():
                        if inspect.ismethod(item):
                            self._pls_cache.append((item_name,&#39;method&#39;))
                        elif inspect.isfunction(item):
                            self._pls_cache.append((item_name,&#39;function&#39;))
                        elif hasattr(inspect,&#39;iscoroutinefunction&#39;) and inspect.iscoroutinefunction(item):
                            self._pls_cache.append((item_name,&#39;coroutine&#39;))
                        elif inspect.isclass(item):
                            self._pls_cache.append((item_name,&#39;class&#39;))
                    self._pls_cache.sort()
                    return self._pls_cache
                else:
                    print(&#39;Error - cannot perform pls when targeting a %s - try to run &#34;pcd ..&#34; first&#39; % current_type)
                    return []

    def do_h(self,args):
        &#34;&#34;&#34; Alias for help &#34;&#34;&#34;
        self.do_help(args)
    def default(self,line):
        if line.startswith(&#39;!&#39;):
            line = line[1:]
        os.system(line)
    def do_pip(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ pip command [args...]

        Runs pip
        &#34;&#34;&#34;
        arglist = [arg.strip() for arg in args.split() if arg.strip() != &#39;&#39;]
        run_cmd([sys.executable,&#39;-m&#39;,&#39;pip&#39;]+arglist)
    def do_restart(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ restart

        Restarts devshell at the current working directory with the current path
        Sometimes needed to cleanly re-import scripts that were already imported and then changed.
        &#34;&#34;&#34;
        sys.exit(subprocess.run([sys.executable,&#39;-m&#39;,&#39;devshell&#39;,&#39;-d&#39;,os.path.abspath(os.getcwd()),&#39;-t&#39;,&#39;.&#39;.join([item[0] for item in self.ppwd])]).returncode)
    #def do_venv(self,args):
    #    &#34;&#34;&#34;
    #Help: (devshell)$ venv [env]
    #    Creates a virtual environment at the current location with the given name
    #    If no name is given, the name will be &#34;env&#34;
    #    &#34;&#34;&#34;
    #    if args.strip() == &#39;&#39;:
    #        args = &#39;env&#39;
    #    subprocess.run([sys.executable,&#39;-m&#39;,&#39;venv&#39;,args])
    #    self.do_activate(&#39;&#39;,bootstrap_devshell=True)
    #def do_activate(self,args,bootstrap_devshell=False):
    #    &#34;&#34;&#34;
    #Help: (devshell)$ activate [env]
    #    Activates the virtual environment at the current location with the given name
    #    If no name is given, the name will be &#34;env&#34;
    #    &#34;&#34;&#34;
    #    if args.strip() == &#39;&#39;:
    #        args = &#39;env&#39;
    #    cwd = os.path.abspath(os.getcwd())
    #    ppwd = &#39;.&#39;.join([item[0] for item in self.ppwd])
    #    if not bootstrap_devshell:
    #        if len(ppwd) &gt; 0:
    #            exec_str = &#39;{executable} -m devshell -d {cwd} -t {ppwd}&#39;.format(executable=os.path.basename(sys.executable),cwd=cwd,ppwd=ppwd)
    #
    #        else:
    #            exec_str = &#39;{executable} -m devshell -d {cwd}&#39;.format(executable=os.path.basename(sys.executable),cwd=cwd)
    #    else:
    #        exec_str = &#39;{executable} -m pip install devshell&#39;.format(executable=os.path.basename(sys.executable),cwd=cwd,ppwd=ppwd)
    #
    #
    #    if sys.platform in [&#39;win32&#39;,&#39;cygwin&#39;]:
    #        subprocess.run([&#39;cmd.exe&#39;,&#39;/C&#39;,r&#39;&#34;cd {cwd}; {env}\Scripts\activate.bat &amp; {exec_str}&#34;&#39;.format(env=args,cwd=cwd,exec_str=exec_str)])
    #    else:
    #        default_shell = os.environ[&#39;SHELL&#39;]
    #        shell_name = os.path.basename(default_shell)
    #        subprocess.run([default_shell,&#39;-c&#39;,&#39;&#34;cd {cwd}; source {env}/bin/activate; {exec_str}&#34;&#39;.format(env=args,cwd=cwd,exec_str=exec_str)])
    #
    #
    #def do_deactivate(self,args):
    #    &#34;&#34;&#34;
    #Help: (devshell)$ deactivate
    #    Deactivates the current virtual environment 
    #    Note: This will result in changing the current working directory and python target to what they were at the time the virtual environment was activated
    #    &#34;&#34;&#34;
    #    if &#39;VIRTUAL_ENV&#39; in os.environ:
    #        print(&#39;Exiting %s&#39; % os.environ[&#39;VIRTUAL_ENV&#39;])
    #        sys.exit(0)
    #    else:
    #        print(&#39;Not currently in a virtual environment&#39;)

    #def do_create(self,args):
    #    &#34;&#34;&#34;
    #Help: (devshell)$ create project_name
    #    Creates a new directory with the provided project name
    #    Creates a src subfolder with an empty python package with the project name
    #    Creates an empty tests python package
    #    Creates a setup.py
    #    Creates a LICENSE file (MIT)
    #    Creates a Makefile
    #    Creates a docs subfolder
    #    Creates a venv env and activates it
    #    &#34;&#34;&#34;

    def do_read(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ read filename
        Opens the selected file in a paginated view (similar to Unix &#34;less&#34; or &#34;more&#34; commands)
        The preferred locale encoding defined by locale.getpreferredencoding() is used
        &#34;&#34;&#34;
        with open(args,&#39;r&#39;) as f:
            text = f.read()
        paginate(text)



    def do_mkdir(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ mkdir dirname
        Creates the specified directory 
        &#34;&#34;&#34;
        os.mkdir(args)
    def do_rm(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ rm filename
        Deletes the file specified by filename. Will not delete a directory.
        See rmtree to delete a directory
        &#34;&#34;&#34;
        try:
            os.remove(args)
        except:
            traceback.print_exc()
            if &#39;-r&#39; in args:
                print(&#39;To remove a folder use the rmtree command&#39;)

    def do_rmtree(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ rmtree dirname
        Deletes the directory specified by dirname and all of its contents.
        See rm to delete a single file
        &#34;&#34;&#34;
        shutil.rmtree(args)

    def do_mv(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ mv source target
        Moves the file or folder at source to target
        &#34;&#34;&#34;
        try:
            src,dst = args.split()
        except:
            print(&#39;Invalid syntax&#39;)
            return
        shutil.move(src,dst)
    def do_cp(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ cp source target
        Copies the file or folder at source to target
        &#34;&#34;&#34;
        try:
            src,dst = args.split()
        except:
            print(&#39;Invalid syntax&#39;)
            return
        if os.path.isdir(src):
            shutil.copytree(src,dst)
        else:
            shutil.copy(src,dst)


    def do_run(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ run shellcmd [args...]
        Runs the given command in a subshell
        &#34;&#34;&#34;
        os.system(args)



    def do_edit(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ edit editor
        Runs the command editor, passing the file of the currently targeted object in as first argument.
        If no editor is specified, an error message will apppear.
        For most editors (e.g. vim, nano, etc), this will open the file for editing.
        If the current item is package, opens __init__.py.

        For editors that have some other command line invocation, see the devshell run command.
        &#34;&#34;&#34;
        editor = args.strip()
        if len(editor) == 0:
            print(&#39;Specify an editor (e.g. edit vim, edit nano, edit notepad++.exe, etc)&#39;)
            return
        else:
            editor=[editor]
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            current_name,current_type = self.ppwd[-1]
            if current_type == &#39;package&#39;:
                filepath = self._get_path() + &#39;__init__.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    run_cmd(editor+[filepath])
            elif current_type == &#39;module&#39;:
                filepath = self._get_path() + &#39;.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    run_cmd(editor+[filepath])
            else:
                try:
                    obj,mod,mod_fqn = get_target(target_fqn)
                except:
                    print(&#39;Failed to get target: %s&#39; % target_fqn)
                    return
                filepath = inspect.getsourcefile(obj)
                print(&#39;File:&#39;,filepath)
                run_cmd(editor+[filepath])
        else:
            print(&#39;No target identified&#39;)


    def _get_path(self):
        ppwd = list(self.ppwd)
        while len(ppwd) &gt; 0 and ppwd[-1][1] not in [&#39;package&#39;,&#39;module&#39;]:
            ppwd.pop(-1)
        current_name,current_type = ppwd[-1]
        _,bottom_folder = os.path.split(self.cwd)
        mod_names = list([name for name,_ in self.ppwd])
        for i,(package_name,_) in enumerate(self.ppwd):
            if bottom_folder == package_name:
                mod_names = [name for name,_ in self.ppwd[i+1:]]
                break
        return os.path.abspath(os.path.join(self.cwd,*mod_names))

    def do_editvim(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ editvim
        Opens vim to the first source line of the given target
        If on windows, opens gvim instead.
        &#34;&#34;&#34;
        if sys.platform == &#39;win32&#39; or sys.platform == &#39;cygwin&#39;:
            editor=[&#39;gvim&#39;]
        else:
            editor=[&#39;vim&#39;]
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            current_name,current_type = self.ppwd[-1]
            if current_type == &#39;package&#39;:
                filepath = self._get_path() + &#39;__init__.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:

                    run_cmd(editor+[filepath])
            elif current_type == &#39;module&#39;:

                _,bottom_folder = os.path.split(self.cwd)
                mod_ppwd = list(self.ppwd)
                for i,(package_name,_) in enumerate(self.ppwd):
                    if bottom_folder == package_name:
                        mod_ppwd = self.ppwd[i+1:]
                        break

                filepath = self._get_path() + &#39;.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    run_cmd(editor+[filepath])
            else:
                #try:
                if 1:
                    obj,mod,mod_fqn = get_target(target_fqn)
                    ast_obj,filepath,source,src_lines = get_ast_obj(target_fqn,obj,mod,mod_fqn)
                    lineno = ast_obj.lineno
                #except:
                if 0:
                    print(&#39;Failed to get target: %s&#39; % target_fqn)
                    return
                print(&#39;File:&#39;,filepath,&#39;Line:&#39;,str(lineno))
                run_cmd(editor+[filepath,&#39;+&#39;+str(lineno)])
        else:
            print(&#39;No target identified&#39;)



    def do_debug(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ debug(arg1,arg2,...,kwarg1=kwvalue1,kwarg2=kwvalue2,...)
        If currently targeting a class or function, this will attempt to load and call that code with the provided positional args and keyword args - entering pdb debug mode on the first line. 
        If currently targeting a package or module, this will enter debug mode at the first line of the module as if the module&#39;s file were directly run with python -m pdb &lt;filename&gt;.
       &#34;&#34;&#34;
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            args = args.strip()
            obj_type = self.ppwd[-1][1]
            if len(self.ppwd) == 0:
                print(&#39;No target is selected&#39;)
                return

            if obj_type in self._callable:
                if len(args) &gt; 0:
                    pargs,kwargs = eval(&#39;_get_args_kwargs{args}&#39;.format(args=args),sys.modules[obj.__module__].__dict__,{&#39;_get_args_kwargs&#39;:_get_args_kwargs})
                else:
                    pargs = tuple()
                    kwargs = {}
                try:
                    result = pdb.runcall(obj,*pargs,**kwargs)
                    print(&#39;Return value: %s&#39; % repr(result))
                except:
                    traceback.print_exc()
            else:
                if len(args) &gt; 0:
                    print(&#39;No arguments are excepted for object type %s&#39; % obj_type)
                else:
                    os.system(&#39;%s -m pdb %s&#39; % (sys.executable,os.path.abspath(inspect.getsourcefile(obj))))

        else:
            print(&#39;No target identified&#39;)


    def do_ls(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ ls path
        This lists the files/subfolders within the provided operating system folder path
        If path is not provided, then files/subfolders within the operating system folder path (current working directory) will be listed
        &#34;&#34;&#34;
        if args == &#39;&#39;:
            args = &#39;.&#39;
        if not os.path.exists(args):
            print(&#39;Error - path does not exist: %s&#39; % args)
            return
        if not os.path.isdir(args):
            print(&#39;Error - path is not a folder: %s&#39; % args)
            return
        lines = []
        for item in os.listdir(args):
            if os.path.isdir(item):
                itemtype = &#39;folder&#39;
            else:
                itemtype = &#39;file&#39;
            lines.append(&#39;    &#39;+item.ljust(30)+itemtype)
        lines.sort()
        print(&#39;\n&#39;.join(lines))



    def do_cd(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ cd path
        This changes the operating system folder path (current working directory) where devshell will look for packages and modules
        &#34;&#34;&#34;
        if os.path.exists(args) and os.path.isdir(args):
            if os.path.exists(os.path.join(args,&#39;__init__.py&#39;)):
                self.do_pcd(args)
            else:
                self.ppwd = []
                self._pls_cache = None
            os.chdir(args)
            self.cwd = os.getcwd()
            sys.path = self.orig_sys_path + [self.cwd]
        else:
            print(&#39;Error - path does not exist: %s&#39; % args)

    def do_doctestify(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ doctestify
          (devshell)$ doctestify resume
        Performs doctestify on the currently targeted item.
        This will cause an interactive python recording session to begin with all items from the targeted item&#39;s module imported in automatically.
        All inputs and outputs will be recorded and entered into the targeted item&#39;s docstring as a doctest.

        If &#34;doctestify resume&#34; is called, then the current doctest commands will be automatically executed into the interpreter
        &#34;&#34;&#34;
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            resume = args.strip() == &#39;resume&#39;
            doctestify(target_fqn,resume)
        else:
            print(&#39;No target identified&#39;)

    def do_quit(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ quit
        Exit the devshell shell.
        &#34;&#34;&#34;
        print(&#39;Exiting devshell shell...&#39;)
        return True
    def do_exit(self,args):
        &#34;&#34;&#34;
    Help:(devshell)$ exit
        Exit the devshell shell.
        &#34;&#34;&#34;
        return self.do_quit(args)
    def do_q(self,args):
        &#34;&#34;&#34;
    Help:(devshell)$ q 
        Exit the devshell shell.
        &#34;&#34;&#34;
        return self.do_quit(args)
    def do_EOF(self,args):
        &#34;&#34;&#34;
    Help: EOF
        Pressing Ctrl+D while in the devshell shell will result in exiting the devshell shell.
        Note that Ctrl+D is also used to terminate an interactive recording session and return to the devshell shell.
        &#34;&#34;&#34;
        return self.do_quit(args)
    def do_doctest(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ doctest [verbose]
        This runs the current doctests for the currently targeted item. verbose can be True or False. If unspecified, verbose=False.
        &#34;&#34;&#34;
        if len(self.ppwd) == 0:
            print(&#39;No target identified&#39;)
            return
        current_type = self.ppwd[-1][1]
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            if len(args.strip()) &gt; 0:
                verbose = eval(args)
            else:
                verbose = False

            try:
                stdout_capture = StringIO()
                sys.stdout = stdout_capture
                
                if current_type in self._callable:
                    importlib.reload(mod)
                    importlib.reload(sys.modules[obj.__module__])
                    doctest.run_docstring_examples(obj,sys.modules[obj.__module__].__dict__,verbose)
                elif current_type in [&#39;package&#39;,&#39;module&#39;]:
                    importlib.reload(mod)
                    importlib.reload(obj)
                    doctest.testmod(obj,verbose=verbose)
                else:
                    sys.stdout = sys.__stdout__
                    print(&#39;Invalid type to run doctest: %s&#39; % current_type)
                    return
                sys.stdout = sys.__stdout__
                results = stdout_capture.getvalue()
                if len(results) != 0:
                    paginate(results)
                else:
                    print(&#39;All doctests passed&#39;)
            except:
                sys.stdout = sys.__stdout__
                traceback.print_exc()
        else:
            print(&#39;No target identified&#39;)
    def do_pytest(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ pytest [pytest_args]
        This runs the pytest against the currently targeted item. 
        If pytest is not installed, an error message will be printed.

        The --doctest-modules option is automatically inserted.

        pytest_args are defined in the pytest documentation:
            https://docs.pytest.org/en/latest/usage.html
            See --pdb, --trace, --capture

        If there is no currently targeted item, pytest will be run against the folder indicated by pwd:
            (devshell)$ pytest -ra --doctest-modules
                is equivalent to:
                    python -m pytest . -ra --doctest-modules

        If there is a target item, pytest will be run specifically against that item.
            For example, if the currently target object is mypackage.my_module.MyClass.my_test_method, then running 
            (devshell)$ pytest -ra
                is equivalent to:
                    python -m pytest  /fullpathto/mypackage/my_module.py::MyClass::my_test_method --doctest-modules -ra
        &#34;&#34;&#34;
        try:
            import pytest
        except:
            print(&#39;pytest is not installed&#39;)
            return


        arglist = [arg.strip() for arg in args.split() if arg.strip() != &#39;&#39;]
        if len(self.ppwd) == 0:
            run_cmd([sys.executable,&#39;-m&#39;,&#39;pytest&#39;,os.path.abspath(self.cwd),&#39;--doctest-modules&#39;]+arglist)
            return
        current_type = self.ppwd[-1][1]

        item_names = []
        reached_module = False
        item_names_inside_module = []
        for item_name,item_type in self.ppwd:
            item_names.append(item_name)
            if reached_module:
                item_names_inside_module.append(item_name)
            if item_type == &#39;module&#39;:
                reached_module = True
        target_fqn = &#39;.&#39;.join(item_names)
        if target_fqn != &#39;&#39;:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                sys.stdout = sys.__stdout__
                #results = stdout_capture.getvalue()
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            sourcefile = inspect.getsourcefile(obj)
            if current_type == &#39;package&#39;:
                sourcefile = os.path.dirname(sourcefile)
            pytest_node_id = &#39;::&#39;.join([os.path.abspath(sourcefile)]+item_names_inside_module)
            run_cmd([sys.executable,&#39;-m&#39;,&#39;pytest&#39;,pytest_node_id,&#39;--doctest-modules&#39;]+arglist)
        else:
            run_cmd([sys.executable,&#39;-m&#39;,&#39;pytest&#39;,os.path.abspath(self.cwd),&#39;--doctest-modules&#39;]+arglist)

    def do_coverage(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ coverage [pytest_args]
        This runs coverage and pytest against the source file containing the currently targeted item. 
        This does not use the pytest-cov plugin, just the coverage and pytest packages themselves.
        If pytest and/or coverage are not installed, an error message will be printed.

        The --doctest-modules pytest argument is automatically inserted.

        pytest_args are defined in the pytest documentation:
            https://docs.pytest.org/en/latest/usage.html
            See --pdb, --trace, --capture

        If there is no currently targeted item, coverage and pytest will be run against the folder indicated by pwd:
            (devshell)$ coverage -ra
                is functionally equivalent to:
                    python -m coverage run --parallel-mode --source=. pytest . -ra --doctest-modules
                    python -m coverage report -m

        If there is a target item, coverage and pytest will be run specifically against the entire source file containing that item.
            For example, if the currently target object is mypackage.my_module.MyClass.my_test_method, then running 
            (devshell)$ coverage -ra
                is functionally equivalent to:
                    python -m coverage run --parallel-mode --source=/fullpathto/mypackage --include=my_module.py pytest  /fullpathto/mypackage/my_module.py -ra --doctest-modules
                    python -m coverage report -m
        &#34;&#34;&#34;
        try:
            import coverage
        except ImportError:
            print(&#39;coverage is not installed&#39;)
            return
        try:
            import pytest
        except ImportError:
            print(&#39;pytest is not installed&#39;)
            return
        arglist = [arg.strip() for arg in args.split() if arg.strip() != &#39;&#39;]
        if len(self.ppwd) == 0:
            run_coverage(self.cwd,arglist)
            return
        current_type = self.ppwd[-1][1]
        item_names = []
        reached_module = False
        item_names_inside_module = []
        for item_name,item_type in self.ppwd:
            item_names.append(item_name)
            if reached_module:
                item_names_inside_module.append(item_name)
            if item_type == &#39;module&#39;:
                reached_module = True
        target_fqn = &#39;.&#39;.join(item_names)
        if target_fqn != &#39;&#39;:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                sys.stdout = sys.__stdout__
                #results = stdout_capture.getvalue()
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            sourcefile = inspect.getsourcefile(obj)
            sourcefilename = os.path.basename(sourcefile)
            sourcedir = os.path.dirname(sourcefile)
            run_coverage(sourcedir,arglist,sourcefilename)
        else:
            run_coverage(self.cwd,arglist)
    def do_source(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ source
        This displays the file name and source code for the currently targeted item.
        &#34;&#34;&#34;
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            current_name,current_type = self.ppwd[-1]
            if current_type == &#39;package&#39;:
                filepath = self._get_path() + &#39;/__init__.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    with open(filepath,&#39;r&#39;) as f:
                        paginate(f.read())
            elif current_type == &#39;module&#39;:
                filepath = self._get_path() + &#39;.py&#39;
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    with open(filepath,&#39;r&#39;) as f:
                        paginate(f.read())
            else:
                try:
                    obj,mod,mod_fqn = get_target(target_fqn)
                except:
                    print(&#39;Failed to get target: %s&#39; % target_fqn)
                    return
                filepath = inspect.getsourcefile(obj)
                print(&#39;File:&#39;,filepath)
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    paginate(inspect.getsource(obj))
        else:
            print(&#39;No target identified&#39;)
    def do_grep(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ grep pattern [OPTIONS]
        Searches the source code of the currently targeted item based on the provided regular expression.
        The source is split into lines and the regular expression is applied to each line.
        Files are opened for reading in string mode with errors being handled via open()&#39;s errors=&#39;backslashreplace&#39; option
        Regular expressions are according to python interpretation (not standard grep).
        Only includes python source files (.py$|.py[w3wxi]$|.pxd$)
        If a package is selected, all files will be looked at.
        If a module is selected, the module will be looked at.
        If a sub-module item is selected, only that items source code will be looked at.

        Supported options:
            -i = Ignore case (re.IGNORECASE)
                Normally, matching is case sensitive
                With -i specified, matching is case-insensitive

            -v = Invert match
                Normally, lines that match the pattern are included
                With -v, lines that do not match the pattern are included
            -p = Print to console after displaying
                Normally, the results will be paginated in a page viewer (similar to unix less)
                With -p, the results will be paginated and then printed to the console after
                
        &#34;&#34;&#34;
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            current_name,current_type = self.ppwd[-1]
            if current_type == &#39;package&#39;:
                #recurse through package directory
                path = self._get_path() 
                grep(args,path=path)
                
            elif current_type == &#39;module&#39;:
                filepath = self._get_path() + &#39;.py&#39;
                grep(args,path=filepath)
            else:
                try:
                    obj,mod,mod_fqn = get_target(target_fqn)
                except:
                    print(&#39;Failed to get target: %s&#39; % target_fqn)
                    return
                filepath = inspect.getsourcefile(obj)
                print(&#39;File:&#39;,filepath)
                if os.path.getsize(filepath) == 0:
                    print(&#39;File is empty&#39;)
                else:
                    grep(args,source=inspect.getsource(obj),path=filepath)
        else:
            path = os.path.abspath(os.getcwd())
            grep(args,path=path)

    def do_doc(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ doc
        This displays the docstring for the currently targeted item.
        &#34;&#34;&#34;
        target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
        if target_fqn != &#39;&#39;:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            doc = inspect.getdoc(obj)
            lines = []
            if self.ppwd[-1][1] in self._callable:
                lines.append(self.ppwd[-1][1]+&#39;: &#39;+self.ppwd[-1][0] + str(inspect.signature(obj)))
            else:
                lines.append(self.ppwd[-1][1]+&#39;: &#39;+self.ppwd[-1][0])
            if doc is not None:
                lines.append(&#39;&#34;&#34;&#34;&#39;)
                lines.append(re.sub(&#39;\n&#39;,&#39;\n    &#39;,doc))
                lines.append(&#39;&#34;&#34;&#34;&#39;)
            else:
                lines.append(&#39;&#39;)
                lines.append(&#39;No docstring exists for target&#39;)
            result = (&#39;    &#39;+&#39;\n    &#39;.join(lines))
            if len(result.strip()) != 0:
                paginate(result,print_also=True)
            else:
                print(&#39;No documentation exists for the given target&#39;)
        else:
            print(&#39;No target identified&#39;)
        

    def do_pwd(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ pwd
        This displays the operating system folder path (current working directory) where devshell will look for packages and modules
        &#34;&#34;&#34;
        print(self.cwd)
    def do_pls(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ pls [python_object]
        This will show all items contained within the currently targeted item.
            e.g. for a package, this would list the modules
            e.g. for a module, this would list the functions and classes
            etc
        If there is no currently targeted item, then all packages in the current working directory or within a subfolder of the current working directory named &#34;src&#34; will be shown.
        Note that using this command may result in importing the module containing the currently targeted item.
        Note that setup.py files will be purposefully excluded because importing/inspecting them without providing commands results in terminating python.

        For tab completion, use the dot &#34;.&#34; character to separate python items, not the slash &#34;/&#34; character.

        &#34;&#34;&#34;
        lines = []
        result = self._pls(args)
        if result is None:
            return
        for item_name,item_type in result: 
            if item_type in self._cdable:
                if len(self.ppwd) == 0 and item_type == &#39;package&#39; and not os.path.exists(os.path.join(self.cwd,item_name,&#39;__init__.py&#39;)) and os.path.exists(os.path.join(self.cwd,&#39;src&#39;,item_name,&#39;__init__.py&#39;)):
                    lines.append(&#39;    %s%sdirectory (./src)&#39; % (item_name.ljust(30), item_type.ljust(30)))
                else:
                    lines.append(&#39;    %s%sdirectory&#39; % (item_name.ljust(30), item_type.ljust(30)))

            else:
                lines.append(&#39;    %s%snon-directory&#39; % (item_name.ljust(30), item_type.ljust(30)))
        print(&#39;\n&#39;.join(lines))
    def _ppwd(self):
        if len(self.ppwd) &gt; 0:
            return (&#39;/&#39;+&#39;.&#39;.join(item[0] for item in self.ppwd),self.ppwd[-1][1])
        else:
            return &#39;/&#39;,&#39;root&#39;
    def do_ppwd(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ ppwd
        This shows the fully qualified name of the currently targeted item.

        &#34;&#34;&#34;
        ppwd,current_type = self._ppwd()
        print(&#39;%s (%s)&#39; % (ppwd.ljust(30),current_type))

    def _pcd(self,args):
        resolved = False
        clear_pls_cache = False
        if args == &#39;.&#39;:
            resolved = True
            clear_pls_cache = False
        elif args == &#39;..&#39;:
            if len(self.ppwd) &gt; 0:
                last_item,last_item_type = self.ppwd.pop()
                if len(self.ppwd) == 0 and last_item_type == &#39;package&#39; and os.path.basename(self.cwd) == &#39;src&#39; and os.path.exists(os.path.join(self.cwd,last_item,&#39;__init__.py&#39;)) and not os.path.exists(os.path.join(self.cwd,&#39;..&#39;,last_item,&#39;__init__.py&#39;)):
                    self.do_cd(&#39;..&#39;)

            resolved = True
            clear_pls_cache = True
            #go up if in src
        elif args == &#39;/&#39;:
            del self.ppwd[:]
            resolved = True
            clear_pls_cache = True
        elif &#39;.&#39; not in args:
            for item,item_type in self._pls():
                if item == args:
                    if len(self.ppwd) == 0 and item_type == &#39;package&#39; and not os.path.exists(os.path.join(self.cwd,item,&#39;__init__.py&#39;)) and os.path.exists(os.path.join(self.cwd,&#39;src&#39;,item,&#39;__init__.py&#39;)):
                        self.do_cd(&#39;src&#39;)
                    self.ppwd.append((item,item_type))
                    resolved = True
                    clear_pls_cache = True
                    break
        else:
            pieces = args.split(&#39;.&#39;)
            orig_ppwd = list(self.ppwd)
            resolved = True
            clear_pls_cache = False
            orig_pls_cache = self._pls_cache
            for piece in pieces:
                self._pls_cache = None
                piece_resolved,piece_clear_pls_cache = self._pcd(piece)
                if not piece_resolved:
                    resolved = False
                    self.ppwd = orig_ppwd
                    clear_pls_cache = False
                    break
                else:
                    clear_pls_cache = clear_pls_cache or piece_clear_pls_cache
            self._pls_cache = orig_pls_cache
        return (resolved,clear_pls_cache)
    def do_interactive(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ interactive
        Opens a python interactive session
        &#34;&#34;&#34;
        console = code.InteractiveConsole()
        console.interact()
    def do_python(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ python
        Opens a python interactive session
        &#34;&#34;&#34;
        self.do_interactive(args)

    def do_pcd(self,args):
        &#34;&#34;&#34;
    Help: (devshell)$ pcd &lt;argument&gt;
        This changes the currently targeted item.
        
        &lt;argument&gt; can be part of a fully qualified name to append to the end of the current target.

        If there is no current target, then one may pcd into a package within the current working directory or within a package in a subfolder of the current working directory named &#34;src&#34;.
        Cding into the &#34;src&#34; subfolder only occurs when the src subfolder has the package with the given name and the current working directory does not.
        Cding into the &#34;src&#34; subfolder will change the current working directory to be the &#34;src&#34; subfolder.
        Command completion is supported via the tab key.
        Note that performing command line completion at a level may result in importing/loading the module containing the item being examined.

        The following are special invocations:

            (devshell)$ pcd /
                This will remove all parts of the current fully qualified name

            (devshell)$ pcd .
                This has no effect

            (devshell)$ pcd ..
                This removes the last piece of the currently fully qualified name (navigates up to the parent item)
                If leaving a package to a subfolder named &#34;src&#34;, will also change the current working directory to be the parent directory of &#34;src&#34; if a package with the current target as its name exists only in the &#34;src&#34; directory and not in the parent directory.

        &#34;&#34;&#34;
        resolved,clear_pls_cache = self._pcd(args)
        if not resolved is True:
            print(&#39;Error - &#34;%s&#34; does not exist&#39; % args)
        #else:
        #    self.prompt = &#39;(devshell)%s$ &#39; % self._ppwd()
        if clear_pls_cache:
            self._pls_cache = None
    def complete_pcd(self,text,line,begin_idx,end_idx):
        return self._complete_python(text,line,begin_idx,end_idx)
    def complete_pls(self,text,line,begin_idx,end_idx):
        return self._complete_python(text,line,begin_idx,end_idx)
    def _complete_python(self,text,line,begin_idx,end_idx):
        orig_cwd = self.cwd
        last_piece = shlex.split(text)[-1]
        if &#39;.&#39; not in text:
            results = [item[0] for item in self._pls() if item[0].startswith(last_piece)]
            if self.cwd != orig_cwd:
                self.cwd = orig_cwd
                os.chdir(orig_cwd)
            return results

        elif set(last_piece) == set([&#39;.&#39;]):
            return []
        else:
            orig_ppwd = list(self.ppwd)
            orig_pls_cache = self._pls_cache
            ts = text.split(&#39;.&#39;)
            #front = &#39;.&#39;.join(ts[:-1])
            front = shlex.join(shlex.split(&#39;.&#39;.join(ts[:-1]))[1:])
            
            last_piece = ts[-1]
            resolved,clear_pls_cache = self._pcd(front)
            #resolved,clear_pls_cache = self._pcd(shlex.join(shlex.split(front)[1:]))
            if resolved:
                self._pls_cache = None
                results = [front+&#39;.&#39;+item[0] for item in self._pls() if item[0].startswith(last_piece)]
            else:
                results = []
            self.ppwd = orig_ppwd
            self._pls_cache = orig_pls_cache
            if self.cwd != orig_cwd:
                self.cwd = orig_cwd
                os.chdir(orig_cwd)
            return results
    def complete_cd(self,text,line,begin_idx,end_idx):
        return self._complete_dirs(&#39;cd&#39;,text,line,begin_idx,end_idx)

    def complete_ls(self,text,line,begin_idx,end_idx):
        return self._complete_dirs(&#39;ls&#39;,text,line,begin_idx,end_idx)

    def complete_rmtree(self,text,line,begin_idx,end_idx):
        return self._complete_dirs(&#39;rmtree&#39;,text,line,begin_idx,end_idx)
    
    def complete_rm(self,text,line,begin_idx,end_idx):
        return self._complete_files(&#39;rm&#39;,text,line,begin_idx,end_idx)

    def complete_cp(self,text,line,begin_idx,end_idx):
        return self._complete_lastdirfile(&#39;cp&#39;,text,line,begin_idx,end_idx)
    def complete_mv(self,text,line,begin_idx,end_idx):
        return self._complete_lastdirfile(&#39;mv&#39;,text,line,begin_idx,end_idx)
    def complete_read(self,text,line,begin_idx,end_idx):
        return self._complete_files(&#39;read&#39;,text,line,begin_idx,end_idx)
    def complete_run(self,text,line,begin_idx,end_idx):
        return self._complete_lastdirfile(&#39;run&#39;,text,line,begin_idx,end_idx)
    def completedefault(self,text,line,begin_idx,end_idx):
        return self._complete_lastdirfile(None,text,line,begin_idx,end_idx)

    def _complete_dirs(self,cmd,text,line,begin_idx,end_idx):
        path = re.sub(&#39;^\\s*%s\\s*&#39;%cmd,&#39;&#39;,line)
        pieces = re.split(&#39;([/\\\\])&#39;,path)
        if len(pieces) &gt; 1:
            front = &#39;&#39;.join(pieces[:-2])
            if front == &#39;&#39;:
                front = &#39;.&#39;
            last_dlm = pieces[-2]
            last_piece = pieces[-1]
        else:
            front = &#39;.&#39;
            last_piece = path
        return [(os.path.join(front,item) if front != &#39;.&#39; else item) for item in os.listdir(front) if item.startswith(last_piece) and os.path.isdir(os.path.join(front,item))]

    def _complete_files(self,cmd,text,line,begin_idx,end_idx):
        path = re.sub(&#39;^\\s*%s\\s*&#39;%cmd,&#39;&#39;,line)
        pieces = re.split(&#39;([/\\\\])&#39;,path)
        if len(pieces) &gt; 1:
            front = &#39;&#39;.join(pieces[:-2])
            if front == &#39;&#39;:
                front = &#39;.&#39;
            last_dlm = pieces[-2]
            last_piece = pieces[-1]
        else:
            front = &#39;.&#39;
            last_piece = path
        return [(os.path.join(front,item) if front != &#39;.&#39; else item) for item in os.listdir(front) if item.startswith(last_piece) and not os.path.isdir(os.path.join(front,item))]
    def _complete_lastdirfile(self,cmd,text,line,begin_idx,end_idx):
        if cmd is not None:
            paths = re.sub(&#39;^\\s*%s\\s*&#39;%cmd,&#39;&#39;,line)
        else:
            paths = line
        qc = len(re.findall(&#39;(?&lt;!\\\\)&#34;&#39;,paths))
        if qc &gt; 0:
            #non-escaped quotes found

            #get the position of the right-most non-escaped quote
            rq_pos = len(paths) - 1 - re.search(&#39;&#34;(?!\\\\)&#39;,paths[::-1]).start(0)
            if qc % 2 == 0:
                #there are an even number of quotes i.e. we are outside of any quoted argument
                path = paths[rq_pos+1:].strip()

            else:
                #there are an odd number of quotes i.e. we are in the middle of a quoted argument
                path = paths[rq_pos+1:]
        else:
            rs_match = re.search(&#39; (?!\\\\)&#39;,paths[::-1])
            if rs_match is not None:
                #there are non-escaped spaces
                rs_pos = len(paths) - 1 - rs_match.start(0)
                path = paths[rs_pos+1:].strip()
            else:
                #there are no spaces
                path = paths
        pieces = re.split(&#39;([/\\\\])&#39;,path)
        if len(pieces) &gt; 1:
            front = &#39;&#39;.join(pieces[:-2])
            if front == &#39;&#39;:
                front = &#39;.&#39;
            last_dlm = pieces[-2]
            last_piece = pieces[-1]
        else:
            front = &#39;.&#39;
            last_piece = path
        return [item for item in os.listdir(front) if item.startswith(last_piece)]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="devshell.ptcmd.PTCmd" href="ptcmd.html#devshell.ptcmd.PTCmd">PTCmd</a></li>
<li>cmd.Cmd</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="devshell.shell.DevshellCmd.intro"><code class="name">var <span class="ident">intro</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="devshell.shell.DevshellCmd.prompt"><code class="name">var <span class="ident">prompt</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="devshell.shell.DevshellCmd.complete_cd"><code class="name flex">
<span>def <span class="ident">complete_cd</span></span>(<span>self, text, line, begin_idx, end_idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_cd(self,text,line,begin_idx,end_idx):
    return self._complete_dirs(&#39;cd&#39;,text,line,begin_idx,end_idx)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.complete_cp"><code class="name flex">
<span>def <span class="ident">complete_cp</span></span>(<span>self, text, line, begin_idx, end_idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_cp(self,text,line,begin_idx,end_idx):
    return self._complete_lastdirfile(&#39;cp&#39;,text,line,begin_idx,end_idx)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.complete_ls"><code class="name flex">
<span>def <span class="ident">complete_ls</span></span>(<span>self, text, line, begin_idx, end_idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_ls(self,text,line,begin_idx,end_idx):
    return self._complete_dirs(&#39;ls&#39;,text,line,begin_idx,end_idx)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.complete_mv"><code class="name flex">
<span>def <span class="ident">complete_mv</span></span>(<span>self, text, line, begin_idx, end_idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_mv(self,text,line,begin_idx,end_idx):
    return self._complete_lastdirfile(&#39;mv&#39;,text,line,begin_idx,end_idx)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.complete_pcd"><code class="name flex">
<span>def <span class="ident">complete_pcd</span></span>(<span>self, text, line, begin_idx, end_idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_pcd(self,text,line,begin_idx,end_idx):
    return self._complete_python(text,line,begin_idx,end_idx)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.complete_pls"><code class="name flex">
<span>def <span class="ident">complete_pls</span></span>(<span>self, text, line, begin_idx, end_idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_pls(self,text,line,begin_idx,end_idx):
    return self._complete_python(text,line,begin_idx,end_idx)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.complete_read"><code class="name flex">
<span>def <span class="ident">complete_read</span></span>(<span>self, text, line, begin_idx, end_idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_read(self,text,line,begin_idx,end_idx):
    return self._complete_files(&#39;read&#39;,text,line,begin_idx,end_idx)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.complete_rm"><code class="name flex">
<span>def <span class="ident">complete_rm</span></span>(<span>self, text, line, begin_idx, end_idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_rm(self,text,line,begin_idx,end_idx):
    return self._complete_files(&#39;rm&#39;,text,line,begin_idx,end_idx)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.complete_rmtree"><code class="name flex">
<span>def <span class="ident">complete_rmtree</span></span>(<span>self, text, line, begin_idx, end_idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_rmtree(self,text,line,begin_idx,end_idx):
    return self._complete_dirs(&#39;rmtree&#39;,text,line,begin_idx,end_idx)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.complete_run"><code class="name flex">
<span>def <span class="ident">complete_run</span></span>(<span>self, text, line, begin_idx, end_idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_run(self,text,line,begin_idx,end_idx):
    return self._complete_lastdirfile(&#39;run&#39;,text,line,begin_idx,end_idx)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.completedefault"><code class="name flex">
<span>def <span class="ident">completedefault</span></span>(<span>self, text, line, begin_idx, end_idx)</span>
</code></dt>
<dd>
<div class="desc"><p>Method called to complete an input line when no command-specific
complete_*() method is available.</p>
<p>By default, it returns an empty list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def completedefault(self,text,line,begin_idx,end_idx):
    return self._complete_lastdirfile(None,text,line,begin_idx,end_idx)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>self, line)</span>
</code></dt>
<dd>
<div class="desc"><p>Called on an input line when the command prefix is not recognized.</p>
<p>If this method is not overridden, it prints an error message and
returns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default(self,line):
    if line.startswith(&#39;!&#39;):
        line = line[1:]
    os.system(line)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_EOF"><code class="name flex">
<span>def <span class="ident">do_EOF</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: EOF
Pressing Ctrl+D while in the devshell shell will result in exiting the devshell shell.
Note that Ctrl+D is also used to terminate an interactive recording session and return to the devshell shell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_EOF(self,args):
    &#34;&#34;&#34;
Help: EOF
    Pressing Ctrl+D while in the devshell shell will result in exiting the devshell shell.
    Note that Ctrl+D is also used to terminate an interactive recording session and return to the devshell shell.
    &#34;&#34;&#34;
    return self.do_quit(args)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_cd"><code class="name flex">
<span>def <span class="ident">do_cd</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ cd path
This changes the operating system folder path (current working directory) where devshell will look for packages and modules</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_cd(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ cd path
    This changes the operating system folder path (current working directory) where devshell will look for packages and modules
    &#34;&#34;&#34;
    if os.path.exists(args) and os.path.isdir(args):
        if os.path.exists(os.path.join(args,&#39;__init__.py&#39;)):
            self.do_pcd(args)
        else:
            self.ppwd = []
            self._pls_cache = None
        os.chdir(args)
        self.cwd = os.getcwd()
        sys.path = self.orig_sys_path + [self.cwd]
    else:
        print(&#39;Error - path does not exist: %s&#39; % args)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_coverage"><code class="name flex">
<span>def <span class="ident">do_coverage</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ coverage [pytest_args]
This runs coverage and pytest against the source file containing the currently targeted item.
This does not use the pytest-cov plugin, just the coverage and pytest packages themselves.
If pytest and/or coverage are not installed, an error message will be printed.</p>
<pre><code>The --doctest-modules pytest argument is automatically inserted.

pytest_args are defined in the pytest documentation:
    &lt;https://docs.pytest.org/en/latest/usage.html&gt;
    See --pdb, --trace, --capture

If there is no currently targeted item, coverage and pytest will be run against the folder indicated by pwd:
    (devshell)$ coverage -ra
        is functionally equivalent to:
            python -m coverage run --parallel-mode --source=. pytest . -ra --doctest-modules
            python -m coverage report -m

If there is a target item, coverage and pytest will be run specifically against the entire source file containing that item.
    For example, if the currently target object is mypackage.my_module.MyClass.my_test_method, then running 
    (devshell)$ coverage -ra
        is functionally equivalent to:
            python -m coverage run --parallel-mode --source=/fullpathto/mypackage --include=my_module.py pytest  /fullpathto/mypackage/my_module.py -ra --doctest-modules
            python -m coverage report -m
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_coverage(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ coverage [pytest_args]
    This runs coverage and pytest against the source file containing the currently targeted item. 
    This does not use the pytest-cov plugin, just the coverage and pytest packages themselves.
    If pytest and/or coverage are not installed, an error message will be printed.

    The --doctest-modules pytest argument is automatically inserted.

    pytest_args are defined in the pytest documentation:
        https://docs.pytest.org/en/latest/usage.html
        See --pdb, --trace, --capture

    If there is no currently targeted item, coverage and pytest will be run against the folder indicated by pwd:
        (devshell)$ coverage -ra
            is functionally equivalent to:
                python -m coverage run --parallel-mode --source=. pytest . -ra --doctest-modules
                python -m coverage report -m

    If there is a target item, coverage and pytest will be run specifically against the entire source file containing that item.
        For example, if the currently target object is mypackage.my_module.MyClass.my_test_method, then running 
        (devshell)$ coverage -ra
            is functionally equivalent to:
                python -m coverage run --parallel-mode --source=/fullpathto/mypackage --include=my_module.py pytest  /fullpathto/mypackage/my_module.py -ra --doctest-modules
                python -m coverage report -m
    &#34;&#34;&#34;
    try:
        import coverage
    except ImportError:
        print(&#39;coverage is not installed&#39;)
        return
    try:
        import pytest
    except ImportError:
        print(&#39;pytest is not installed&#39;)
        return
    arglist = [arg.strip() for arg in args.split() if arg.strip() != &#39;&#39;]
    if len(self.ppwd) == 0:
        run_coverage(self.cwd,arglist)
        return
    current_type = self.ppwd[-1][1]
    item_names = []
    reached_module = False
    item_names_inside_module = []
    for item_name,item_type in self.ppwd:
        item_names.append(item_name)
        if reached_module:
            item_names_inside_module.append(item_name)
        if item_type == &#39;module&#39;:
            reached_module = True
    target_fqn = &#39;.&#39;.join(item_names)
    if target_fqn != &#39;&#39;:
        try:
            obj,mod,mod_fqn = get_target(target_fqn)
        except:
            sys.stdout = sys.__stdout__
            #results = stdout_capture.getvalue()
            print(&#39;Failed to get target: %s&#39; % target_fqn)
            return
        sourcefile = inspect.getsourcefile(obj)
        sourcefilename = os.path.basename(sourcefile)
        sourcedir = os.path.dirname(sourcefile)
        run_coverage(sourcedir,arglist,sourcefilename)
    else:
        run_coverage(self.cwd,arglist)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_cp"><code class="name flex">
<span>def <span class="ident">do_cp</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ cp source target
Copies the file or folder at source to target</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_cp(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ cp source target
    Copies the file or folder at source to target
    &#34;&#34;&#34;
    try:
        src,dst = args.split()
    except:
        print(&#39;Invalid syntax&#39;)
        return
    if os.path.isdir(src):
        shutil.copytree(src,dst)
    else:
        shutil.copy(src,dst)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_debug"><code class="name flex">
<span>def <span class="ident">do_debug</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ debug(arg1,arg2,&hellip;,kwarg1=kwvalue1,kwarg2=kwvalue2,&hellip;)
If currently targeting a class or function, this will attempt to load and call that code with the provided positional args and keyword args - entering pdb debug mode on the first line.
If currently targeting a package or module, this will enter debug mode at the first line of the module as if the module's file were directly run with python -m pdb <filename>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_debug(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ debug(arg1,arg2,...,kwarg1=kwvalue1,kwarg2=kwvalue2,...)
    If currently targeting a class or function, this will attempt to load and call that code with the provided positional args and keyword args - entering pdb debug mode on the first line. 
    If currently targeting a package or module, this will enter debug mode at the first line of the module as if the module&#39;s file were directly run with python -m pdb &lt;filename&gt;.
   &#34;&#34;&#34;
    target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
    if target_fqn != &#39;&#39;:
        try:
            obj,mod,mod_fqn = get_target(target_fqn)
        except:
            print(&#39;Failed to get target: %s&#39; % target_fqn)
            return
        args = args.strip()
        obj_type = self.ppwd[-1][1]
        if len(self.ppwd) == 0:
            print(&#39;No target is selected&#39;)
            return

        if obj_type in self._callable:
            if len(args) &gt; 0:
                pargs,kwargs = eval(&#39;_get_args_kwargs{args}&#39;.format(args=args),sys.modules[obj.__module__].__dict__,{&#39;_get_args_kwargs&#39;:_get_args_kwargs})
            else:
                pargs = tuple()
                kwargs = {}
            try:
                result = pdb.runcall(obj,*pargs,**kwargs)
                print(&#39;Return value: %s&#39; % repr(result))
            except:
                traceback.print_exc()
        else:
            if len(args) &gt; 0:
                print(&#39;No arguments are excepted for object type %s&#39; % obj_type)
            else:
                os.system(&#39;%s -m pdb %s&#39; % (sys.executable,os.path.abspath(inspect.getsourcefile(obj))))

    else:
        print(&#39;No target identified&#39;)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_doc"><code class="name flex">
<span>def <span class="ident">do_doc</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ doc
This displays the docstring for the currently targeted item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_doc(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ doc
    This displays the docstring for the currently targeted item.
    &#34;&#34;&#34;
    target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
    if target_fqn != &#39;&#39;:
        try:
            obj,mod,mod_fqn = get_target(target_fqn)
        except:
            print(&#39;Failed to get target: %s&#39; % target_fqn)
            return
        doc = inspect.getdoc(obj)
        lines = []
        if self.ppwd[-1][1] in self._callable:
            lines.append(self.ppwd[-1][1]+&#39;: &#39;+self.ppwd[-1][0] + str(inspect.signature(obj)))
        else:
            lines.append(self.ppwd[-1][1]+&#39;: &#39;+self.ppwd[-1][0])
        if doc is not None:
            lines.append(&#39;&#34;&#34;&#34;&#39;)
            lines.append(re.sub(&#39;\n&#39;,&#39;\n    &#39;,doc))
            lines.append(&#39;&#34;&#34;&#34;&#39;)
        else:
            lines.append(&#39;&#39;)
            lines.append(&#39;No docstring exists for target&#39;)
        result = (&#39;    &#39;+&#39;\n    &#39;.join(lines))
        if len(result.strip()) != 0:
            paginate(result,print_also=True)
        else:
            print(&#39;No documentation exists for the given target&#39;)
    else:
        print(&#39;No target identified&#39;)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_doctest"><code class="name flex">
<span>def <span class="ident">do_doctest</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ doctest [verbose]
This runs the current doctests for the currently targeted item. verbose can be True or False. If unspecified, verbose=False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_doctest(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ doctest [verbose]
    This runs the current doctests for the currently targeted item. verbose can be True or False. If unspecified, verbose=False.
    &#34;&#34;&#34;
    if len(self.ppwd) == 0:
        print(&#39;No target identified&#39;)
        return
    current_type = self.ppwd[-1][1]
    target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
    if target_fqn != &#39;&#39;:
        try:
            obj,mod,mod_fqn = get_target(target_fqn)
        except:
            print(&#39;Failed to get target: %s&#39; % target_fqn)
            return
        if len(args.strip()) &gt; 0:
            verbose = eval(args)
        else:
            verbose = False

        try:
            stdout_capture = StringIO()
            sys.stdout = stdout_capture
            
            if current_type in self._callable:
                importlib.reload(mod)
                importlib.reload(sys.modules[obj.__module__])
                doctest.run_docstring_examples(obj,sys.modules[obj.__module__].__dict__,verbose)
            elif current_type in [&#39;package&#39;,&#39;module&#39;]:
                importlib.reload(mod)
                importlib.reload(obj)
                doctest.testmod(obj,verbose=verbose)
            else:
                sys.stdout = sys.__stdout__
                print(&#39;Invalid type to run doctest: %s&#39; % current_type)
                return
            sys.stdout = sys.__stdout__
            results = stdout_capture.getvalue()
            if len(results) != 0:
                paginate(results)
            else:
                print(&#39;All doctests passed&#39;)
        except:
            sys.stdout = sys.__stdout__
            traceback.print_exc()
    else:
        print(&#39;No target identified&#39;)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_doctestify"><code class="name flex">
<span>def <span class="ident">do_doctestify</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ doctestify
(devshell)$ doctestify resume
Performs doctestify on the currently targeted item.
This will cause an interactive python recording session to begin with all items from the targeted item's module imported in automatically.
All inputs and outputs will be recorded and entered into the targeted item's docstring as a doctest.</p>
<pre><code>If "doctestify resume" is called, then the current doctest commands will be automatically executed into the interpreter
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_doctestify(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ doctestify
      (devshell)$ doctestify resume
    Performs doctestify on the currently targeted item.
    This will cause an interactive python recording session to begin with all items from the targeted item&#39;s module imported in automatically.
    All inputs and outputs will be recorded and entered into the targeted item&#39;s docstring as a doctest.

    If &#34;doctestify resume&#34; is called, then the current doctest commands will be automatically executed into the interpreter
    &#34;&#34;&#34;
    target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
    if target_fqn != &#39;&#39;:
        resume = args.strip() == &#39;resume&#39;
        doctestify(target_fqn,resume)
    else:
        print(&#39;No target identified&#39;)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_edit"><code class="name flex">
<span>def <span class="ident">do_edit</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ edit editor
Runs the command editor, passing the file of the currently targeted object in as first argument.
If no editor is specified, an error message will apppear.
For most editors (e.g. vim, nano, etc), this will open the file for editing.
If the current item is package, opens <strong>init</strong>.py.</p>
<pre><code>For editors that have some other command line invocation, see the devshell run command.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_edit(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ edit editor
    Runs the command editor, passing the file of the currently targeted object in as first argument.
    If no editor is specified, an error message will apppear.
    For most editors (e.g. vim, nano, etc), this will open the file for editing.
    If the current item is package, opens __init__.py.

    For editors that have some other command line invocation, see the devshell run command.
    &#34;&#34;&#34;
    editor = args.strip()
    if len(editor) == 0:
        print(&#39;Specify an editor (e.g. edit vim, edit nano, edit notepad++.exe, etc)&#39;)
        return
    else:
        editor=[editor]
    target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
    if target_fqn != &#39;&#39;:
        current_name,current_type = self.ppwd[-1]
        if current_type == &#39;package&#39;:
            filepath = self._get_path() + &#39;__init__.py&#39;
            if os.path.getsize(filepath) == 0:
                print(&#39;File is empty&#39;)
            else:
                run_cmd(editor+[filepath])
        elif current_type == &#39;module&#39;:
            filepath = self._get_path() + &#39;.py&#39;
            if os.path.getsize(filepath) == 0:
                print(&#39;File is empty&#39;)
            else:
                run_cmd(editor+[filepath])
        else:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            filepath = inspect.getsourcefile(obj)
            print(&#39;File:&#39;,filepath)
            run_cmd(editor+[filepath])
    else:
        print(&#39;No target identified&#39;)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_editvim"><code class="name flex">
<span>def <span class="ident">do_editvim</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ editvim
Opens vim to the first source line of the given target
If on windows, opens gvim instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_editvim(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ editvim
    Opens vim to the first source line of the given target
    If on windows, opens gvim instead.
    &#34;&#34;&#34;
    if sys.platform == &#39;win32&#39; or sys.platform == &#39;cygwin&#39;:
        editor=[&#39;gvim&#39;]
    else:
        editor=[&#39;vim&#39;]
    target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
    if target_fqn != &#39;&#39;:
        current_name,current_type = self.ppwd[-1]
        if current_type == &#39;package&#39;:
            filepath = self._get_path() + &#39;__init__.py&#39;
            if os.path.getsize(filepath) == 0:
                print(&#39;File is empty&#39;)
            else:

                run_cmd(editor+[filepath])
        elif current_type == &#39;module&#39;:

            _,bottom_folder = os.path.split(self.cwd)
            mod_ppwd = list(self.ppwd)
            for i,(package_name,_) in enumerate(self.ppwd):
                if bottom_folder == package_name:
                    mod_ppwd = self.ppwd[i+1:]
                    break

            filepath = self._get_path() + &#39;.py&#39;
            if os.path.getsize(filepath) == 0:
                print(&#39;File is empty&#39;)
            else:
                run_cmd(editor+[filepath])
        else:
            #try:
            if 1:
                obj,mod,mod_fqn = get_target(target_fqn)
                ast_obj,filepath,source,src_lines = get_ast_obj(target_fqn,obj,mod,mod_fqn)
                lineno = ast_obj.lineno
            #except:
            if 0:
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            print(&#39;File:&#39;,filepath,&#39;Line:&#39;,str(lineno))
            run_cmd(editor+[filepath,&#39;+&#39;+str(lineno)])
    else:
        print(&#39;No target identified&#39;)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_exit"><code class="name flex">
<span>def <span class="ident">do_exit</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help:(devshell)$ exit
Exit the devshell shell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_exit(self,args):
    &#34;&#34;&#34;
Help:(devshell)$ exit
    Exit the devshell shell.
    &#34;&#34;&#34;
    return self.do_quit(args)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_grep"><code class="name flex">
<span>def <span class="ident">do_grep</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ grep pattern [OPTIONS]
Searches the source code of the currently targeted item based on the provided regular expression.
The source is split into lines and the regular expression is applied to each line.
Files are opened for reading in string mode with errors being handled via open()'s errors='backslashreplace' option
Regular expressions are according to python interpretation (not standard grep).
Only includes python source files (.py$|.py[w3wxi]$|.pxd$)
If a package is selected, all files will be looked at.
If a module is selected, the module will be looked at.
If a sub-module item is selected, only that items source code will be looked at.</p>
<pre><code>Supported options:
    -i = Ignore case (re.IGNORECASE)
        Normally, matching is case sensitive
        With -i specified, matching is case-insensitive

    -v = Invert match
        Normally, lines that match the pattern are included
        With -v, lines that do not match the pattern are included
    -p = Print to console after displaying
        Normally, the results will be paginated in a page viewer (similar to unix less)
        With -p, the results will be paginated and then printed to the console after
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_grep(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ grep pattern [OPTIONS]
    Searches the source code of the currently targeted item based on the provided regular expression.
    The source is split into lines and the regular expression is applied to each line.
    Files are opened for reading in string mode with errors being handled via open()&#39;s errors=&#39;backslashreplace&#39; option
    Regular expressions are according to python interpretation (not standard grep).
    Only includes python source files (.py$|.py[w3wxi]$|.pxd$)
    If a package is selected, all files will be looked at.
    If a module is selected, the module will be looked at.
    If a sub-module item is selected, only that items source code will be looked at.

    Supported options:
        -i = Ignore case (re.IGNORECASE)
            Normally, matching is case sensitive
            With -i specified, matching is case-insensitive

        -v = Invert match
            Normally, lines that match the pattern are included
            With -v, lines that do not match the pattern are included
        -p = Print to console after displaying
            Normally, the results will be paginated in a page viewer (similar to unix less)
            With -p, the results will be paginated and then printed to the console after
            
    &#34;&#34;&#34;
    target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
    if target_fqn != &#39;&#39;:
        current_name,current_type = self.ppwd[-1]
        if current_type == &#39;package&#39;:
            #recurse through package directory
            path = self._get_path() 
            grep(args,path=path)
            
        elif current_type == &#39;module&#39;:
            filepath = self._get_path() + &#39;.py&#39;
            grep(args,path=filepath)
        else:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            filepath = inspect.getsourcefile(obj)
            print(&#39;File:&#39;,filepath)
            if os.path.getsize(filepath) == 0:
                print(&#39;File is empty&#39;)
            else:
                grep(args,source=inspect.getsource(obj),path=filepath)
    else:
        path = os.path.abspath(os.getcwd())
        grep(args,path=path)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_h"><code class="name flex">
<span>def <span class="ident">do_h</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for help</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_h(self,args):
    &#34;&#34;&#34; Alias for help &#34;&#34;&#34;
    self.do_help(args)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_interactive"><code class="name flex">
<span>def <span class="ident">do_interactive</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ interactive
Opens a python interactive session</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_interactive(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ interactive
    Opens a python interactive session
    &#34;&#34;&#34;
    console = code.InteractiveConsole()
    console.interact()</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_ls"><code class="name flex">
<span>def <span class="ident">do_ls</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ ls path
This lists the files/subfolders within the provided operating system folder path
If path is not provided, then files/subfolders within the operating system folder path (current working directory) will be listed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_ls(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ ls path
    This lists the files/subfolders within the provided operating system folder path
    If path is not provided, then files/subfolders within the operating system folder path (current working directory) will be listed
    &#34;&#34;&#34;
    if args == &#39;&#39;:
        args = &#39;.&#39;
    if not os.path.exists(args):
        print(&#39;Error - path does not exist: %s&#39; % args)
        return
    if not os.path.isdir(args):
        print(&#39;Error - path is not a folder: %s&#39; % args)
        return
    lines = []
    for item in os.listdir(args):
        if os.path.isdir(item):
            itemtype = &#39;folder&#39;
        else:
            itemtype = &#39;file&#39;
        lines.append(&#39;    &#39;+item.ljust(30)+itemtype)
    lines.sort()
    print(&#39;\n&#39;.join(lines))</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_mkdir"><code class="name flex">
<span>def <span class="ident">do_mkdir</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ mkdir dirname
Creates the specified directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_mkdir(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ mkdir dirname
    Creates the specified directory 
    &#34;&#34;&#34;
    os.mkdir(args)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_mv"><code class="name flex">
<span>def <span class="ident">do_mv</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ mv source target
Moves the file or folder at source to target</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_mv(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ mv source target
    Moves the file or folder at source to target
    &#34;&#34;&#34;
    try:
        src,dst = args.split()
    except:
        print(&#39;Invalid syntax&#39;)
        return
    shutil.move(src,dst)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_pcd"><code class="name flex">
<span>def <span class="ident">do_pcd</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ pcd <argument>
This changes the currently targeted item.</p>
<pre><code>&lt;argument&gt; can be part of a fully qualified name to append to the end of the current target.

If there is no current target, then one may pcd into a package within the current working directory or within a package in a subfolder of the current working directory named "src".
Cding into the "src" subfolder only occurs when the src subfolder has the package with the given name and the current working directory does not.
Cding into the "src" subfolder will change the current working directory to be the "src" subfolder.
Command completion is supported via the tab key.
Note that performing command line completion at a level may result in importing/loading the module containing the item being examined.

The following are special invocations:

    (devshell)$ pcd /
        This will remove all parts of the current fully qualified name

    (devshell)$ pcd .
        This has no effect

    (devshell)$ pcd ..
        This removes the last piece of the currently fully qualified name (navigates up to the parent item)
        If leaving a package to a subfolder named "src", will also change the current working directory to be the parent directory of "src" if a package with the current target as its name exists only in the "src" directory and not in the parent directory.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_pcd(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ pcd &lt;argument&gt;
    This changes the currently targeted item.
    
    &lt;argument&gt; can be part of a fully qualified name to append to the end of the current target.

    If there is no current target, then one may pcd into a package within the current working directory or within a package in a subfolder of the current working directory named &#34;src&#34;.
    Cding into the &#34;src&#34; subfolder only occurs when the src subfolder has the package with the given name and the current working directory does not.
    Cding into the &#34;src&#34; subfolder will change the current working directory to be the &#34;src&#34; subfolder.
    Command completion is supported via the tab key.
    Note that performing command line completion at a level may result in importing/loading the module containing the item being examined.

    The following are special invocations:

        (devshell)$ pcd /
            This will remove all parts of the current fully qualified name

        (devshell)$ pcd .
            This has no effect

        (devshell)$ pcd ..
            This removes the last piece of the currently fully qualified name (navigates up to the parent item)
            If leaving a package to a subfolder named &#34;src&#34;, will also change the current working directory to be the parent directory of &#34;src&#34; if a package with the current target as its name exists only in the &#34;src&#34; directory and not in the parent directory.

    &#34;&#34;&#34;
    resolved,clear_pls_cache = self._pcd(args)
    if not resolved is True:
        print(&#39;Error - &#34;%s&#34; does not exist&#39; % args)
    #else:
    #    self.prompt = &#39;(devshell)%s$ &#39; % self._ppwd()
    if clear_pls_cache:
        self._pls_cache = None</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_pip"><code class="name flex">
<span>def <span class="ident">do_pip</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ pip command [args&hellip;]</p>
<pre><code>Runs pip
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_pip(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ pip command [args...]

    Runs pip
    &#34;&#34;&#34;
    arglist = [arg.strip() for arg in args.split() if arg.strip() != &#39;&#39;]
    run_cmd([sys.executable,&#39;-m&#39;,&#39;pip&#39;]+arglist)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_pls"><code class="name flex">
<span>def <span class="ident">do_pls</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ pls [python_object]
This will show all items contained within the currently targeted item.
e.g. for a package, this would list the modules
e.g. for a module, this would list the functions and classes
etc
If there is no currently targeted item, then all packages in the current working directory or within a subfolder of the current working directory named "src" will be shown.
Note that using this command may result in importing the module containing the currently targeted item.
Note that setup.py files will be purposefully excluded because importing/inspecting them without providing commands results in terminating python.</p>
<pre><code>For tab completion, use the dot "." character to separate python items, not the slash "/" character.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_pls(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ pls [python_object]
    This will show all items contained within the currently targeted item.
        e.g. for a package, this would list the modules
        e.g. for a module, this would list the functions and classes
        etc
    If there is no currently targeted item, then all packages in the current working directory or within a subfolder of the current working directory named &#34;src&#34; will be shown.
    Note that using this command may result in importing the module containing the currently targeted item.
    Note that setup.py files will be purposefully excluded because importing/inspecting them without providing commands results in terminating python.

    For tab completion, use the dot &#34;.&#34; character to separate python items, not the slash &#34;/&#34; character.

    &#34;&#34;&#34;
    lines = []
    result = self._pls(args)
    if result is None:
        return
    for item_name,item_type in result: 
        if item_type in self._cdable:
            if len(self.ppwd) == 0 and item_type == &#39;package&#39; and not os.path.exists(os.path.join(self.cwd,item_name,&#39;__init__.py&#39;)) and os.path.exists(os.path.join(self.cwd,&#39;src&#39;,item_name,&#39;__init__.py&#39;)):
                lines.append(&#39;    %s%sdirectory (./src)&#39; % (item_name.ljust(30), item_type.ljust(30)))
            else:
                lines.append(&#39;    %s%sdirectory&#39; % (item_name.ljust(30), item_type.ljust(30)))

        else:
            lines.append(&#39;    %s%snon-directory&#39; % (item_name.ljust(30), item_type.ljust(30)))
    print(&#39;\n&#39;.join(lines))</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_ppwd"><code class="name flex">
<span>def <span class="ident">do_ppwd</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ ppwd
This shows the fully qualified name of the currently targeted item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_ppwd(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ ppwd
    This shows the fully qualified name of the currently targeted item.

    &#34;&#34;&#34;
    ppwd,current_type = self._ppwd()
    print(&#39;%s (%s)&#39; % (ppwd.ljust(30),current_type))</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_pwd"><code class="name flex">
<span>def <span class="ident">do_pwd</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ pwd
This displays the operating system folder path (current working directory) where devshell will look for packages and modules</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_pwd(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ pwd
    This displays the operating system folder path (current working directory) where devshell will look for packages and modules
    &#34;&#34;&#34;
    print(self.cwd)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_pytest"><code class="name flex">
<span>def <span class="ident">do_pytest</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ pytest [pytest_args]
This runs the pytest against the currently targeted item.
If pytest is not installed, an error message will be printed.</p>
<pre><code>The --doctest-modules option is automatically inserted.

pytest_args are defined in the pytest documentation:
    &lt;https://docs.pytest.org/en/latest/usage.html&gt;
    See --pdb, --trace, --capture

If there is no currently targeted item, pytest will be run against the folder indicated by pwd:
    (devshell)$ pytest -ra --doctest-modules
        is equivalent to:
            python -m pytest . -ra --doctest-modules

If there is a target item, pytest will be run specifically against that item.
    For example, if the currently target object is mypackage.my_module.MyClass.my_test_method, then running 
    (devshell)$ pytest -ra
        is equivalent to:
            python -m pytest  /fullpathto/mypackage/my_module.py::MyClass::my_test_method --doctest-modules -ra
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_pytest(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ pytest [pytest_args]
    This runs the pytest against the currently targeted item. 
    If pytest is not installed, an error message will be printed.

    The --doctest-modules option is automatically inserted.

    pytest_args are defined in the pytest documentation:
        https://docs.pytest.org/en/latest/usage.html
        See --pdb, --trace, --capture

    If there is no currently targeted item, pytest will be run against the folder indicated by pwd:
        (devshell)$ pytest -ra --doctest-modules
            is equivalent to:
                python -m pytest . -ra --doctest-modules

    If there is a target item, pytest will be run specifically against that item.
        For example, if the currently target object is mypackage.my_module.MyClass.my_test_method, then running 
        (devshell)$ pytest -ra
            is equivalent to:
                python -m pytest  /fullpathto/mypackage/my_module.py::MyClass::my_test_method --doctest-modules -ra
    &#34;&#34;&#34;
    try:
        import pytest
    except:
        print(&#39;pytest is not installed&#39;)
        return


    arglist = [arg.strip() for arg in args.split() if arg.strip() != &#39;&#39;]
    if len(self.ppwd) == 0:
        run_cmd([sys.executable,&#39;-m&#39;,&#39;pytest&#39;,os.path.abspath(self.cwd),&#39;--doctest-modules&#39;]+arglist)
        return
    current_type = self.ppwd[-1][1]

    item_names = []
    reached_module = False
    item_names_inside_module = []
    for item_name,item_type in self.ppwd:
        item_names.append(item_name)
        if reached_module:
            item_names_inside_module.append(item_name)
        if item_type == &#39;module&#39;:
            reached_module = True
    target_fqn = &#39;.&#39;.join(item_names)
    if target_fqn != &#39;&#39;:
        try:
            obj,mod,mod_fqn = get_target(target_fqn)
        except:
            sys.stdout = sys.__stdout__
            #results = stdout_capture.getvalue()
            print(&#39;Failed to get target: %s&#39; % target_fqn)
            return
        sourcefile = inspect.getsourcefile(obj)
        if current_type == &#39;package&#39;:
            sourcefile = os.path.dirname(sourcefile)
        pytest_node_id = &#39;::&#39;.join([os.path.abspath(sourcefile)]+item_names_inside_module)
        run_cmd([sys.executable,&#39;-m&#39;,&#39;pytest&#39;,pytest_node_id,&#39;--doctest-modules&#39;]+arglist)
    else:
        run_cmd([sys.executable,&#39;-m&#39;,&#39;pytest&#39;,os.path.abspath(self.cwd),&#39;--doctest-modules&#39;]+arglist)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_python"><code class="name flex">
<span>def <span class="ident">do_python</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ python
Opens a python interactive session</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_python(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ python
    Opens a python interactive session
    &#34;&#34;&#34;
    self.do_interactive(args)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_q"><code class="name flex">
<span>def <span class="ident">do_q</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help:(devshell)$ q
Exit the devshell shell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_q(self,args):
    &#34;&#34;&#34;
Help:(devshell)$ q 
    Exit the devshell shell.
    &#34;&#34;&#34;
    return self.do_quit(args)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_quit"><code class="name flex">
<span>def <span class="ident">do_quit</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ quit
Exit the devshell shell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_quit(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ quit
    Exit the devshell shell.
    &#34;&#34;&#34;
    print(&#39;Exiting devshell shell...&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_read"><code class="name flex">
<span>def <span class="ident">do_read</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ read filename
Opens the selected file in a paginated view (similar to Unix "less" or "more" commands)
The preferred locale encoding defined by locale.getpreferredencoding() is used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_read(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ read filename
    Opens the selected file in a paginated view (similar to Unix &#34;less&#34; or &#34;more&#34; commands)
    The preferred locale encoding defined by locale.getpreferredencoding() is used
    &#34;&#34;&#34;
    with open(args,&#39;r&#39;) as f:
        text = f.read()
    paginate(text)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_restart"><code class="name flex">
<span>def <span class="ident">do_restart</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ restart</p>
<pre><code>Restarts devshell at the current working directory with the current path
Sometimes needed to cleanly re-import scripts that were already imported and then changed.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_restart(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ restart

    Restarts devshell at the current working directory with the current path
    Sometimes needed to cleanly re-import scripts that were already imported and then changed.
    &#34;&#34;&#34;
    sys.exit(subprocess.run([sys.executable,&#39;-m&#39;,&#39;devshell&#39;,&#39;-d&#39;,os.path.abspath(os.getcwd()),&#39;-t&#39;,&#39;.&#39;.join([item[0] for item in self.ppwd])]).returncode)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_rm"><code class="name flex">
<span>def <span class="ident">do_rm</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ rm filename
Deletes the file specified by filename. Will not delete a directory.
See rmtree to delete a directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_rm(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ rm filename
    Deletes the file specified by filename. Will not delete a directory.
    See rmtree to delete a directory
    &#34;&#34;&#34;
    try:
        os.remove(args)
    except:
        traceback.print_exc()
        if &#39;-r&#39; in args:
            print(&#39;To remove a folder use the rmtree command&#39;)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_rmtree"><code class="name flex">
<span>def <span class="ident">do_rmtree</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ rmtree dirname
Deletes the directory specified by dirname and all of its contents.
See rm to delete a single file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_rmtree(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ rmtree dirname
    Deletes the directory specified by dirname and all of its contents.
    See rm to delete a single file
    &#34;&#34;&#34;
    shutil.rmtree(args)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_run"><code class="name flex">
<span>def <span class="ident">do_run</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ run shellcmd [args&hellip;]
Runs the given command in a subshell</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_run(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ run shellcmd [args...]
    Runs the given command in a subshell
    &#34;&#34;&#34;
    os.system(args)</code></pre>
</details>
</dd>
<dt id="devshell.shell.DevshellCmd.do_source"><code class="name flex">
<span>def <span class="ident">do_source</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Help: (devshell)$ source
This displays the file name and source code for the currently targeted item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_source(self,args):
    &#34;&#34;&#34;
Help: (devshell)$ source
    This displays the file name and source code for the currently targeted item.
    &#34;&#34;&#34;
    target_fqn = &#39;.&#39;.join(item[0] for item in self.ppwd)
    if target_fqn != &#39;&#39;:
        current_name,current_type = self.ppwd[-1]
        if current_type == &#39;package&#39;:
            filepath = self._get_path() + &#39;/__init__.py&#39;
            if os.path.getsize(filepath) == 0:
                print(&#39;File is empty&#39;)
            else:
                with open(filepath,&#39;r&#39;) as f:
                    paginate(f.read())
        elif current_type == &#39;module&#39;:
            filepath = self._get_path() + &#39;.py&#39;
            if os.path.getsize(filepath) == 0:
                print(&#39;File is empty&#39;)
            else:
                with open(filepath,&#39;r&#39;) as f:
                    paginate(f.read())
        else:
            try:
                obj,mod,mod_fqn = get_target(target_fqn)
            except:
                print(&#39;Failed to get target: %s&#39; % target_fqn)
                return
            filepath = inspect.getsourcefile(obj)
            print(&#39;File:&#39;,filepath)
            if os.path.getsize(filepath) == 0:
                print(&#39;File is empty&#39;)
            else:
                paginate(inspect.getsource(obj))
    else:
        print(&#39;No target identified&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="devshell.ptcmd.PTCmd" href="ptcmd.html#devshell.ptcmd.PTCmd">PTCmd</a></b></code>:
<ul class="hlist">
<li><code><a title="devshell.ptcmd.PTCmd.cmdloop" href="ptcmd.html#devshell.ptcmd.PTCmd.cmdloop">cmdloop</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="devshell" href="index.html">devshell</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="devshell.shell.capture_stdout" href="#devshell.shell.capture_stdout">capture_stdout</a></code></li>
<li><code><a title="devshell.shell.grep" href="#devshell.shell.grep">grep</a></code></li>
<li><code><a title="devshell.shell.paginate" href="#devshell.shell.paginate">paginate</a></code></li>
<li><code><a title="devshell.shell.run_cmd" href="#devshell.shell.run_cmd">run_cmd</a></code></li>
<li><code><a title="devshell.shell.run_coverage" href="#devshell.shell.run_coverage">run_coverage</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="devshell.shell.DevshellCmd" href="#devshell.shell.DevshellCmd">DevshellCmd</a></code></h4>
<ul class="two-column">
<li><code><a title="devshell.shell.DevshellCmd.complete_cd" href="#devshell.shell.DevshellCmd.complete_cd">complete_cd</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.complete_cp" href="#devshell.shell.DevshellCmd.complete_cp">complete_cp</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.complete_ls" href="#devshell.shell.DevshellCmd.complete_ls">complete_ls</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.complete_mv" href="#devshell.shell.DevshellCmd.complete_mv">complete_mv</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.complete_pcd" href="#devshell.shell.DevshellCmd.complete_pcd">complete_pcd</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.complete_pls" href="#devshell.shell.DevshellCmd.complete_pls">complete_pls</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.complete_read" href="#devshell.shell.DevshellCmd.complete_read">complete_read</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.complete_rm" href="#devshell.shell.DevshellCmd.complete_rm">complete_rm</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.complete_rmtree" href="#devshell.shell.DevshellCmd.complete_rmtree">complete_rmtree</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.complete_run" href="#devshell.shell.DevshellCmd.complete_run">complete_run</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.completedefault" href="#devshell.shell.DevshellCmd.completedefault">completedefault</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.default" href="#devshell.shell.DevshellCmd.default">default</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_EOF" href="#devshell.shell.DevshellCmd.do_EOF">do_EOF</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_cd" href="#devshell.shell.DevshellCmd.do_cd">do_cd</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_coverage" href="#devshell.shell.DevshellCmd.do_coverage">do_coverage</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_cp" href="#devshell.shell.DevshellCmd.do_cp">do_cp</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_debug" href="#devshell.shell.DevshellCmd.do_debug">do_debug</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_doc" href="#devshell.shell.DevshellCmd.do_doc">do_doc</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_doctest" href="#devshell.shell.DevshellCmd.do_doctest">do_doctest</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_doctestify" href="#devshell.shell.DevshellCmd.do_doctestify">do_doctestify</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_edit" href="#devshell.shell.DevshellCmd.do_edit">do_edit</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_editvim" href="#devshell.shell.DevshellCmd.do_editvim">do_editvim</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_exit" href="#devshell.shell.DevshellCmd.do_exit">do_exit</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_grep" href="#devshell.shell.DevshellCmd.do_grep">do_grep</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_h" href="#devshell.shell.DevshellCmd.do_h">do_h</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_interactive" href="#devshell.shell.DevshellCmd.do_interactive">do_interactive</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_ls" href="#devshell.shell.DevshellCmd.do_ls">do_ls</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_mkdir" href="#devshell.shell.DevshellCmd.do_mkdir">do_mkdir</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_mv" href="#devshell.shell.DevshellCmd.do_mv">do_mv</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_pcd" href="#devshell.shell.DevshellCmd.do_pcd">do_pcd</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_pip" href="#devshell.shell.DevshellCmd.do_pip">do_pip</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_pls" href="#devshell.shell.DevshellCmd.do_pls">do_pls</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_ppwd" href="#devshell.shell.DevshellCmd.do_ppwd">do_ppwd</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_pwd" href="#devshell.shell.DevshellCmd.do_pwd">do_pwd</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_pytest" href="#devshell.shell.DevshellCmd.do_pytest">do_pytest</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_python" href="#devshell.shell.DevshellCmd.do_python">do_python</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_q" href="#devshell.shell.DevshellCmd.do_q">do_q</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_quit" href="#devshell.shell.DevshellCmd.do_quit">do_quit</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_read" href="#devshell.shell.DevshellCmd.do_read">do_read</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_restart" href="#devshell.shell.DevshellCmd.do_restart">do_restart</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_rm" href="#devshell.shell.DevshellCmd.do_rm">do_rm</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_rmtree" href="#devshell.shell.DevshellCmd.do_rmtree">do_rmtree</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_run" href="#devshell.shell.DevshellCmd.do_run">do_run</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.do_source" href="#devshell.shell.DevshellCmd.do_source">do_source</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.intro" href="#devshell.shell.DevshellCmd.intro">intro</a></code></li>
<li><code><a title="devshell.shell.DevshellCmd.prompt" href="#devshell.shell.DevshellCmd.prompt">prompt</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>