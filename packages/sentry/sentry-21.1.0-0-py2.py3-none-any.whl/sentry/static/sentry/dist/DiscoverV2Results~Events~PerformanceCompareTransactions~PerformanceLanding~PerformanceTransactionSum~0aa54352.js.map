{"version":3,"sources":["webpack:///./app/components/charts/eventsRequest.tsx","webpack:////workspace/node_modules/lodash/omitBy.js","webpack:///./app/components/charts/eventsChart.tsx","webpack:////workspace/node_modules/lodash/negate.js"],"names":["propNamesToIgnore","omitIgnoredProps","props","omitBy","_value","key","includes","EventsRequest","state","reloading","loading","errored","timeseriesData","fetchedWithPrevious","unmounting","fetchData","a","api","confirmedQuery","setState","clear","doEventsRequest","responseJSON","detail","addErrorMessage","t","includePrevious","getData","data","period","hasPreviousPeriod","canIncludePreviousPeriod","dataMiddleIndex","Math","floor","length","current","slice","previous","this","prevProps","isEqual","getName","timestamp","map","i","countArray","name","value","reduce","acc","count","seriesName","previousSeriesName","calculateTotalsPerTimestamp","_timestamp","_countArray","response","totals","includeTransformedData","includeTimeAggregation","timeAggregationSeriesName","transformTimeseriesData","currentSeriesName","allData","originalData","originalPreviousData","previousData","transformPreviousPeriodData","timeAggregatedData","transformAggregatedTimeseries","children","showLoading","data-test-id","isMultiSeriesStats","results","Object","keys","seriesData","transformed","order","sort","b","item","processData","allTimeseriesData","originalTimeseriesData","timeseriesTotals","originalPreviousTimeseriesData","previousTimeseriesData","React","PureComponent","defaultProps","undefined","start","end","interval","limit","query","baseIteratee","negate","pickBy","module","exports","object","predicate","Chart","seriesSelection","forceUpdate","handleLegendSelectChanged","legendChange","disableableSeries","selected","disableable","nextProps","nextState","releaseSeries","showDaily","yAxis","BarChart","aggregateMultiPlotType","LineChart","AreaChart","Error","zoomRenderProps","showLegend","legendOptions","chartOptionsProp","chartOptions","seriesNameTransformer","colors","Array","isArray","push","legend","right","top","icon","itemHeight","itemWidth","itemGap","align","textStyle","color","theme","textColor","verticalAlign","fontSize","fontFamily","charts","getColorPalette","grid","left","bottom","seriesOptions","showSymbol","tooltip","trigger","truncate","valueFormatter","tooltipFormatter","axisLabel","gray200","formatter","axisLabelFormatter","Component","getChartComponent","series","forEach","s","onLegendSelectChanged","previousPeriod","EventsChart","utc","router","projects","environments","disablePrevious","disableReleases","emphasizeReleases","currentName","previousName","field","topEvents","orderby","chartHeader","preserveReleaseQueryParams","releaseQueryExtra","intervalVal","getInterval","chartImplementation","size","visible","isValidElement","stacked","previousChart","chartProps","preserveQueryParams","queryExtra","project","environment","eventData","TypeError","args","arguments","call","apply"],"mappings":"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","file":"DiscoverV2Results~Events~PerformanceCompareTransactions~PerformanceLanding~PerformanceTransactionSum~0aa54352.js","sourcesContent":["import React from 'react';\nimport isEqual from 'lodash/isEqual';\nimport omitBy from 'lodash/omitBy';\nimport PropTypes from 'prop-types';\n\nimport {doEventsRequest} from 'app/actionCreators/events';\nimport {addErrorMessage} from 'app/actionCreators/indicator';\nimport {Client} from 'app/api';\nimport LoadingPanel from 'app/components/charts/loadingPanel';\nimport {canIncludePreviousPeriod, isMultiSeriesStats} from 'app/components/charts/utils';\nimport {t} from 'app/locale';\nimport SentryTypes from 'app/sentryTypes';\nimport {\n  DateString,\n  EventsStats,\n  EventsStatsData,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'app/types';\nimport {Series, SeriesDataUnit} from 'app/types/echarts';\n\nexport type TimeSeriesData = {\n  // timeseries data\n  timeseriesData?: Series[];\n  allTimeseriesData?: EventsStatsData;\n  originalTimeseriesData?: EventsStatsData;\n  timeseriesTotals?: {count: number};\n  originalPreviousTimeseriesData?: EventsStatsData | null;\n  previousTimeseriesData?: Series | null;\n  timeAggregatedData?: Series | {};\n};\n\ntype LoadingStatus = {\n  loading: boolean;\n  reloading: boolean;\n  /**\n   * Whether there was an error retrieving data\n   */\n  errored: boolean;\n};\n\n// Chart format for multiple series.\ntype MultiSeriesResults = Series[];\n\ntype RenderProps = LoadingStatus & TimeSeriesData & {results?: MultiSeriesResults};\n\ntype DefaultProps = {\n  /**\n   * Relative time period for query.\n   *\n   * Use `start` and `end` for absolute dates.\n   *\n   * e.g. 24h, 7d, 30d\n   */\n  period?: string;\n  /**\n   * Absolute start date for query\n   */\n  start?: DateString;\n  /**\n   * Absolute end date for query\n   */\n  end?: DateString;\n  /**\n   * Interval to group results in\n   *\n   * e.g. 1d, 1h, 1m, 1s\n   */\n  interval: string;\n  /**\n   * number of rows to return\n   */\n  limit: number;\n  /**\n   * The query string to search events by\n   */\n  query: string;\n  /**\n   * Include data for previous period\n   */\n  includePrevious: boolean;\n  /**\n   * Transform the response data to be something ingestible by charts\n   */\n  includeTransformedData: boolean;\n};\n\ntype EventsRequestPartialProps = {\n  /**\n   * API client instance\n   */\n  api: Client;\n  organization: OrganizationSummary;\n  /**\n   * List of project ids to query\n   */\n  project?: Readonly<number[]>;\n  /**\n   * List of environments to query\n   */\n  environment?: Readonly<string[]>;\n  /**\n   * List of fields to group with when doing a topEvents request.\n   */\n  field?: string[];\n  /**\n   * Initial loading state\n   */\n  loading?: boolean;\n  /**\n   * Should loading be shown.\n   */\n  showLoading?: boolean;\n  /**\n   * The yAxis being plotted. If multiple yAxis are requested,\n   * the child render function will be called with `results`\n   */\n  yAxis?: string | string[];\n  /**\n   * Name used for display current series data set tooltip\n   */\n  currentSeriesName?: string;\n  previousSeriesName?: string;\n  children: (renderProps: RenderProps) => React.ReactNode;\n  /**\n   * The number of top results to get. When set a multi-series result will be returned\n   * in the `results` child render function.\n   */\n  topEvents?: number;\n  /**\n   * How to order results when getting top events.\n   */\n  orderby?: string;\n  /**\n   * Discover needs confirmation to run >30 day >10 project queries,\n   * optional and when not passed confirmation is not required.\n   */\n  confirmedQuery?: boolean;\n};\n\ntype TimeAggregationProps =\n  | {includeTimeAggregation: true; timeAggregationSeriesName: string}\n  | {includeTimeAggregation?: false; timeAggregationSeriesName?: undefined};\n\ntype EventsRequestProps = DefaultProps & TimeAggregationProps & EventsRequestPartialProps;\n\ntype EventsRequestState = {\n  reloading: boolean;\n  errored: boolean;\n  timeseriesData: null | EventsStats | MultiSeriesEventsStats;\n  fetchedWithPrevious: boolean;\n};\n\nconst propNamesToIgnore = ['api', 'children', 'organization', 'loading'];\nconst omitIgnoredProps = (props: EventsRequestProps) =>\n  omitBy(props, (_value, key) => propNamesToIgnore.includes(key));\n\nclass EventsRequest extends React.PureComponent<EventsRequestProps, EventsRequestState> {\n  static propTypes = {\n    api: PropTypes.object.isRequired,\n    organization: SentryTypes.Organization.isRequired,\n    project: PropTypes.arrayOf(PropTypes.number),\n    environment: PropTypes.arrayOf(PropTypes.string),\n    period: PropTypes.string,\n    start: PropTypes.instanceOf(Date),\n    end: PropTypes.instanceOf(Date),\n    interval: PropTypes.string,\n    includePrevious: PropTypes.bool,\n    limit: PropTypes.number,\n    query: PropTypes.string,\n    includeTransformedData: PropTypes.bool,\n\n    /**\n     * Include a dataset transform that will aggregate count values for each\n     * timestamp. Be sure to supply a name to `timeAggregationSeriesName`\n     */\n    includeTimeAggregation: PropTypes.bool,\n\n    /**\n     * Name of series of aggregated timeseries\n     */\n    timeAggregationSeriesName: PropTypes.string,\n    loading: PropTypes.bool,\n    errored: PropTypes.bool,\n    showLoading: PropTypes.bool,\n    currentSeriesName: PropTypes.string,\n    yAxis: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n\n    field: PropTypes.arrayOf(PropTypes.string),\n    topEvents: PropTypes.number,\n    orderby: PropTypes.string,\n\n    confirmedQuery: PropTypes.bool,\n  };\n\n  static defaultProps: DefaultProps = {\n    period: undefined,\n    start: null,\n    end: null,\n    interval: '1d',\n    limit: 15,\n    query: '',\n    includePrevious: true,\n    includeTransformedData: true,\n  };\n\n  state: EventsRequestState = {\n    reloading: !!this.props.loading,\n    errored: false,\n    timeseriesData: null,\n    fetchedWithPrevious: false,\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentDidUpdate(prevProps: EventsRequestProps) {\n    if (isEqual(omitIgnoredProps(prevProps), omitIgnoredProps(this.props))) {\n      return;\n    }\n    this.fetchData();\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n  }\n\n  private unmounting: boolean = false;\n\n  fetchData = async () => {\n    const {api, confirmedQuery, ...props} = this.props;\n    let timeseriesData: EventsStats | MultiSeriesEventsStats | null = null;\n\n    if (confirmedQuery === false) {\n      return;\n    }\n\n    this.setState(state => ({\n      reloading: state.timeseriesData !== null,\n      errored: false,\n    }));\n\n    try {\n      api.clear();\n      timeseriesData = await doEventsRequest(api, props);\n    } catch (resp) {\n      if (resp && resp.responseJSON && resp.responseJSON.detail) {\n        addErrorMessage(resp.responseJSON.detail);\n      } else {\n        addErrorMessage(t('Error loading chart data'));\n      }\n      this.setState({\n        errored: true,\n      });\n    }\n\n    if (this.unmounting) {\n      return;\n    }\n\n    this.setState({\n      reloading: false,\n      timeseriesData,\n      fetchedWithPrevious: props.includePrevious,\n    });\n  };\n\n  /**\n   * Retrieves data set for the current period (since data can potentially\n   * contain previous period's data), as well as the previous period if\n   * possible.\n   *\n   * Returns `null` if data does not exist\n   */\n  getData = (\n    data: EventsStatsData\n  ): {previous: EventsStatsData | null; current: EventsStatsData} => {\n    const {fetchedWithPrevious} = this.state;\n    const {period, includePrevious} = this.props;\n\n    const hasPreviousPeriod =\n      fetchedWithPrevious || canIncludePreviousPeriod(includePrevious, period);\n    // Take the floor just in case, but data should always be divisible by 2\n    const dataMiddleIndex = Math.floor(data.length / 2);\n    return {\n      current: hasPreviousPeriod ? data.slice(dataMiddleIndex) : data,\n      previous: hasPreviousPeriod ? data.slice(0, dataMiddleIndex) : null,\n    };\n  };\n\n  // This aggregates all values per `timestamp`\n  calculateTotalsPerTimestamp(\n    data: EventsStatsData,\n    getName: (\n      timestamp: number,\n      countArray: {count: number}[],\n      i: number\n    ) => number = timestamp => timestamp * 1000\n  ): SeriesDataUnit[] {\n    return data.map(([timestamp, countArray], i) => ({\n      name: getName(timestamp, countArray, i),\n      value: countArray.reduce((acc, {count}) => acc + count, 0),\n    }));\n  }\n\n  /**\n   * Get previous period data, but transform timestamps so that data fits unto\n   * the current period's data axis\n   */\n  transformPreviousPeriodData(\n    current: EventsStatsData,\n    previous: EventsStatsData | null\n  ): Series | null {\n    // Need the current period data array so we can take the timestamp\n    // so we can be sure the data lines up\n    if (!previous) {\n      return null;\n    }\n\n    return {\n      seriesName: this.props.previousSeriesName ?? 'Previous',\n      data: this.calculateTotalsPerTimestamp(\n        previous,\n        (_timestamp, _countArray, i) => current[i][0] * 1000\n      ),\n    };\n  }\n\n  /**\n   * Aggregate all counts for each time stamp\n   */\n  transformAggregatedTimeseries(data: EventsStatsData, seriesName: string = ''): Series {\n    return {\n      seriesName,\n      data: this.calculateTotalsPerTimestamp(data),\n    };\n  }\n\n  /**\n   * Transforms query response into timeseries data to be used in a chart\n   */\n  transformTimeseriesData(data: EventsStatsData, seriesName?: string): Series[] {\n    return [\n      {\n        seriesName: seriesName || 'Current',\n        data: data.map(([timestamp, countsForTimestamp]) => ({\n          name: timestamp * 1000,\n          value: countsForTimestamp.reduce((acc, {count}) => acc + count, 0),\n        })),\n      },\n    ];\n  }\n\n  processData(response: EventsStats | null) {\n    if (!response) {\n      return {};\n    }\n\n    const {data, totals} = response;\n    const {\n      includeTransformedData,\n      includeTimeAggregation,\n      timeAggregationSeriesName,\n    } = this.props;\n    const {current, previous} = this.getData(data);\n    const transformedData = includeTransformedData\n      ? this.transformTimeseriesData(current, this.props.currentSeriesName)\n      : [];\n    const previousData = includeTransformedData\n      ? this.transformPreviousPeriodData(current, previous)\n      : null;\n    const timeAggregatedData = includeTimeAggregation\n      ? this.transformAggregatedTimeseries(current, timeAggregationSeriesName || '')\n      : {};\n    return {\n      data: transformedData,\n      allData: data,\n      originalData: current,\n      totals,\n      originalPreviousData: previous,\n      previousData,\n      timeAggregatedData,\n    };\n  }\n\n  render() {\n    const {children, showLoading, ...props} = this.props;\n    const {timeseriesData, reloading, errored} = this.state;\n    // Is \"loading\" if data is null\n    const loading = this.props.loading || timeseriesData === null;\n\n    if (showLoading && loading) {\n      return <LoadingPanel data-test-id=\"events-request-loading\" />;\n    }\n\n    if (isMultiSeriesStats(timeseriesData)) {\n      // Convert multi-series results into chartable series. Multi series results\n      // are created when multiple yAxis are used or a topEvents request is made.\n      // Convert the timeseries data into a multi-series result set.\n      // As the server will have replied with a map like:\n      // {[titleString: string]: EventsStats}\n      const results: MultiSeriesResults = Object.keys(timeseriesData)\n        .map((seriesName: string): [number, Series] => {\n          const seriesData: EventsStats = timeseriesData[seriesName];\n          const transformed = this.transformTimeseriesData(\n            seriesData.data,\n            seriesName\n          )[0];\n          return [seriesData.order || 0, transformed];\n        })\n        .sort((a, b) => a[0] - b[0])\n        .map(item => item[1]);\n\n      return children({\n        loading,\n        reloading,\n        errored,\n        results,\n        // sometimes we want to reference props that were given to EventsRequest\n        ...props,\n      });\n    }\n\n    const {\n      data: transformedTimeseriesData,\n      allData: allTimeseriesData,\n      originalData: originalTimeseriesData,\n      totals: timeseriesTotals,\n      originalPreviousData: originalPreviousTimeseriesData,\n      previousData: previousTimeseriesData,\n      timeAggregatedData,\n    } = this.processData(timeseriesData);\n\n    return children({\n      loading,\n      reloading,\n      errored,\n      // timeseries data\n      timeseriesData: transformedTimeseriesData,\n      allTimeseriesData,\n      originalTimeseriesData,\n      timeseriesTotals,\n      originalPreviousTimeseriesData,\n      previousTimeseriesData,\n      timeAggregatedData,\n      // sometimes we want to reference props that were given to EventsRequest\n      ...props,\n    });\n  }\n}\nexport default EventsRequest;\n","var baseIteratee = require('./_baseIteratee'),\n    negate = require('./negate'),\n    pickBy = require('./pickBy');\n\n/**\n * The opposite of `_.pickBy`; this method creates an object composed of\n * the own and inherited enumerable string keyed properties of `object` that\n * `predicate` doesn't return truthy for. The predicate is invoked with two\n * arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omitBy(object, _.isNumber);\n * // => { 'b': '2' }\n */\nfunction omitBy(object, predicate) {\n  return pickBy(object, negate(baseIteratee(predicate)));\n}\n\nmodule.exports = omitBy;\n","import React from 'react';\nimport {InjectedRouter} from 'react-router/lib/Router';\nimport {EChartOption} from 'echarts/lib/echarts';\nimport {Query} from 'history';\nimport isEqual from 'lodash/isEqual';\nimport PropTypes from 'prop-types';\n\nimport {Client} from 'app/api';\nimport AreaChart from 'app/components/charts/areaChart';\nimport BarChart from 'app/components/charts/barChart';\nimport ChartZoom, {ZoomRenderProps} from 'app/components/charts/chartZoom';\nimport ErrorPanel from 'app/components/charts/errorPanel';\nimport LineChart from 'app/components/charts/lineChart';\nimport ReleaseSeries from 'app/components/charts/releaseSeries';\nimport TransitionChart from 'app/components/charts/transitionChart';\nimport TransparentLoadingMask from 'app/components/charts/transparentLoadingMask';\nimport {getInterval} from 'app/components/charts/utils';\nimport {IconWarning} from 'app/icons';\nimport {t} from 'app/locale';\nimport {DateString, OrganizationSummary} from 'app/types';\nimport {Series} from 'app/types/echarts';\nimport {axisLabelFormatter, tooltipFormatter} from 'app/utils/discover/charts';\nimport {aggregateMultiPlotType} from 'app/utils/discover/fields';\nimport theme from 'app/utils/theme';\n\nimport EventsRequest from './eventsRequest';\n\ntype ChartProps = {\n  loading: boolean;\n  reloading: boolean;\n  zoomRenderProps: ZoomRenderProps;\n  timeseriesData: Series[];\n  showLegend?: boolean;\n  legendOptions?: EChartOption.Legend;\n  chartOptions?: EChartOption;\n  currentSeriesName?: string;\n  releaseSeries?: Series[];\n  previousTimeseriesData?: Series | null;\n  previousSeriesName?: string;\n  /**\n   * The default series names are based on the column names. This callback\n   * allows for custom naming of series.\n   */\n  seriesNameTransformer?: (string) => string;\n  showDaily?: boolean;\n  interval?: string;\n  yAxis: string;\n  stacked: boolean;\n  colors?: string[];\n  /**\n   * By default, only the release series is disableable. This adds\n   * a list of series names that are also disableable.\n   */\n  disableableSeries?: string[];\n};\n\ntype State = {\n  seriesSelection: Record<string, boolean>;\n  forceUpdate: boolean;\n};\n\nclass Chart extends React.Component<ChartProps, State> {\n  static propTypes = {\n    loading: PropTypes.bool,\n    reloading: PropTypes.bool,\n    releaseSeries: PropTypes.array,\n    zoomRenderProps: PropTypes.object,\n    timeseriesData: PropTypes.array,\n    showLegend: PropTypes.bool,\n    previousTimeseriesData: PropTypes.object,\n    currentSeriesName: PropTypes.string,\n    previousSeriesName: PropTypes.string,\n    seriesNameTransformer: PropTypes.func,\n    showDaily: PropTypes.bool,\n    yAxis: PropTypes.string,\n    stacked: PropTypes.bool,\n    colors: PropTypes.array,\n    disableableSeries: PropTypes.array,\n    legendOptions: PropTypes.object,\n    chartOptions: PropTypes.object,\n  };\n\n  state: State = {\n    seriesSelection: {},\n    forceUpdate: false,\n  };\n\n  shouldComponentUpdate(nextProps: ChartProps, nextState: State) {\n    if (nextState.forceUpdate) {\n      return true;\n    }\n\n    if (!isEqual(this.state.seriesSelection, nextState.seriesSelection)) {\n      return true;\n    }\n\n    if (nextProps.reloading || !nextProps.timeseriesData) {\n      return false;\n    }\n\n    if (\n      isEqual(this.props.timeseriesData, nextProps.timeseriesData) &&\n      isEqual(this.props.releaseSeries, nextProps.releaseSeries) &&\n      isEqual(this.props.previousTimeseriesData, nextProps.previousTimeseriesData)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  getChartComponent():\n    | React.ComponentType<BarChart['props']>\n    | React.ComponentType<AreaChart['props']>\n    | React.ComponentType<LineChart['props']> {\n    const {showDaily, timeseriesData, yAxis} = this.props;\n    if (showDaily) {\n      return BarChart;\n    }\n    if (timeseriesData.length > 1) {\n      switch (aggregateMultiPlotType(yAxis)) {\n        case 'line':\n          return LineChart;\n        case 'area':\n          return AreaChart;\n        default:\n          throw new Error(`Unknown multi plot type for ${yAxis}`);\n      }\n    }\n    return AreaChart;\n  }\n\n  handleLegendSelectChanged = legendChange => {\n    const {disableableSeries = []} = this.props;\n    const {selected} = legendChange;\n    const seriesSelection = Object.keys(selected).reduce((state, key) => {\n      // we only want them to be able to disable the Releases series,\n      // and not any of the other possible series here\n      const disableable = key === 'Releases' || disableableSeries.includes(key);\n      state[key] = disableable ? selected[key] : true;\n      return state;\n    }, {});\n\n    // we have to force an update here otherwise ECharts will\n    // update its internal state and disable the series\n    this.setState({seriesSelection, forceUpdate: true}, () =>\n      this.setState({forceUpdate: false})\n    );\n  };\n\n  render() {\n    const {\n      loading: _loading,\n      reloading: _reloading,\n      yAxis,\n      releaseSeries,\n      zoomRenderProps,\n      timeseriesData,\n      previousTimeseriesData,\n      showLegend,\n      legendOptions,\n      chartOptions: chartOptionsProp,\n      currentSeriesName,\n      previousSeriesName,\n      seriesNameTransformer,\n      colors,\n      ...props\n    } = this.props;\n    const {seriesSelection} = this.state;\n\n    const data = [currentSeriesName ?? t('Current'), previousSeriesName ?? t('Previous')];\n    if (Array.isArray(releaseSeries)) {\n      data.push(t('Releases'));\n    }\n\n    const legend = showLegend\n      ? {\n          right: 16,\n          top: 12,\n          icon: 'circle',\n          itemHeight: 8,\n          itemWidth: 8,\n          itemGap: 12,\n          align: 'left' as const,\n          textStyle: {\n            color: theme.textColor,\n            verticalAlign: 'top',\n            fontSize: 11,\n            fontFamily: 'Rubik',\n          },\n          data,\n          selected: seriesSelection,\n          ...(legendOptions ?? {}),\n        }\n      : undefined;\n\n    const chartOptions = {\n      colors: timeseriesData.length\n        ? colors?.slice(0, timeseriesData.length) ?? [\n            ...theme.charts.getColorPalette(timeseriesData.length - 2),\n          ]\n        : undefined,\n      grid: {\n        left: '24px',\n        right: '24px',\n        top: '32px',\n        bottom: '12px',\n      },\n      seriesOptions: {\n        showSymbol: false,\n      },\n      tooltip: {\n        trigger: 'axis' as const,\n        truncate: 80,\n        valueFormatter: (value: number) => tooltipFormatter(value, yAxis),\n      },\n      yAxis: {\n        axisLabel: {\n          color: theme.gray200,\n          formatter: (value: number) => axisLabelFormatter(value, yAxis),\n        },\n      },\n      ...(chartOptionsProp ?? {}),\n    };\n\n    const Component = this.getChartComponent();\n    const series = Array.isArray(releaseSeries)\n      ? [...timeseriesData, ...releaseSeries]\n      : timeseriesData;\n\n    if (seriesNameTransformer) {\n      series.forEach(s => {\n        s.seriesName = seriesNameTransformer(s.seriesName);\n      });\n    }\n\n    return (\n      <Component\n        {...props}\n        {...zoomRenderProps}\n        {...chartOptions}\n        legend={legend}\n        onLegendSelectChanged={this.handleLegendSelectChanged}\n        series={series}\n        previousPeriod={previousTimeseriesData ? [previousTimeseriesData] : undefined}\n      />\n    );\n  }\n}\n\ntype Props = {\n  api: Client;\n  router: InjectedRouter;\n  organization: OrganizationSummary;\n  /**\n   * Project ids\n   */\n  projects: number[];\n  /**\n   * Environment condition.\n   */\n  environments: string[];\n  /**\n   * The discover query string to find events with.\n   */\n  query: string;\n  /**\n   * The aggregate/metric to plot.\n   */\n  yAxis: string;\n  /**\n   * Relative datetime expression. eg. 14d\n   */\n  period?: string;\n  /**\n   * Absolute start date.\n   */\n  start: DateString;\n  /**\n   * Absolute end date.\n   */\n  end: DateString;\n  /**\n   * Should datetimes be formatted in UTC?\n   */\n  utc?: boolean | null;\n  /**\n   * Don't show the previous period's data. Will automatically disable\n   * when start/end are used.\n   */\n  disablePrevious?: boolean;\n  /**\n   * Don't show the release marklines.\n   */\n  disableReleases?: boolean;\n  /**\n   * A list of release names to visually emphasize. Can only be used when `disableReleases` is false.\n   */\n  emphasizeReleases?: string[];\n  /**\n   * Fetch n top events as dictated by the field and orderby props.\n   */\n  topEvents?: number;\n  /**\n   * The fields that act as grouping conditions when generating a topEvents chart.\n   */\n  field?: string[];\n  /**\n   * The interval resolution for a chart e.g. 1m, 5m, 1d\n   */\n  interval?: string;\n  /**\n   * Order condition when showing topEvents\n   */\n  orderby?: string;\n  /**\n   * Override the interval calculation and show daily results.\n   */\n  showDaily?: boolean;\n  confirmedQuery?: boolean;\n  /**\n   * Override the default color palette.\n   */\n  colors?: string[];\n  /**\n   * Markup for optional chart header\n   */\n  chartHeader?: React.ReactNode;\n  releaseQueryExtra?: Query;\n  preserveReleaseQueryParams?: boolean;\n} & Pick<\n  ChartProps,\n  | 'currentSeriesName'\n  | 'previousSeriesName'\n  | 'seriesNameTransformer'\n  | 'showLegend'\n  | 'disableableSeries'\n  | 'legendOptions'\n  | 'chartOptions'\n>;\n\ntype ChartDataProps = {\n  zoomRenderProps: ZoomRenderProps;\n  errored: boolean;\n  loading: boolean;\n  reloading: boolean;\n  results?: Series[];\n  timeseriesData?: Series[];\n  previousTimeseriesData?: Series | null;\n  releaseSeries?: Series[];\n};\n\nclass EventsChart extends React.Component<Props> {\n  static propTypes = {\n    api: PropTypes.object,\n    projects: PropTypes.arrayOf(PropTypes.number),\n    environments: PropTypes.arrayOf(PropTypes.string),\n    period: PropTypes.string,\n    query: PropTypes.string,\n    start: PropTypes.instanceOf(Date),\n    end: PropTypes.instanceOf(Date),\n    utc: PropTypes.bool,\n    router: PropTypes.object,\n    showLegend: PropTypes.bool,\n    yAxis: PropTypes.string,\n    disablePrevious: PropTypes.bool,\n    disableReleases: PropTypes.bool,\n    emphasizeReleases: PropTypes.array,\n    currentSeriesName: PropTypes.string,\n    previousSeriesName: PropTypes.string,\n    seriesNameTransformer: PropTypes.func,\n    topEvents: PropTypes.number,\n    field: PropTypes.arrayOf(PropTypes.string),\n    showDaily: PropTypes.bool,\n    orderby: PropTypes.string,\n    confirmedQuery: PropTypes.bool,\n    colors: PropTypes.array,\n    preserveReleaseQueryParams: PropTypes.bool,\n    releaseQueryExtras: PropTypes.object,\n    disableableSeries: PropTypes.array,\n    chartHeader: PropTypes.object,\n    legendOptions: PropTypes.object,\n    chartOptions: PropTypes.object,\n  };\n\n  render() {\n    const {\n      api,\n      period,\n      utc,\n      query,\n      router,\n      start,\n      end,\n      projects,\n      environments,\n      showLegend,\n      yAxis,\n      disablePrevious,\n      disableReleases,\n      emphasizeReleases,\n      currentSeriesName: currentName,\n      previousSeriesName: previousName,\n      seriesNameTransformer,\n      field,\n      interval,\n      showDaily,\n      topEvents,\n      orderby,\n      confirmedQuery,\n      colors,\n      chartHeader,\n      legendOptions,\n      chartOptions,\n      preserveReleaseQueryParams,\n      releaseQueryExtra,\n      ...props\n    } = this.props;\n    // Include previous only on relative dates (defaults to relative if no start and end)\n    const includePrevious = !disablePrevious && !start && !end;\n\n    const previousSeriesName =\n      previousName ?? (yAxis ? t('previous %s', yAxis) : undefined);\n    const currentSeriesName = currentName ?? yAxis;\n\n    const intervalVal = showDaily ? '1d' : interval || getInterval(this.props, true);\n\n    let chartImplementation = ({\n      zoomRenderProps,\n      releaseSeries,\n      errored,\n      loading,\n      reloading,\n      results,\n      timeseriesData,\n      previousTimeseriesData,\n    }: ChartDataProps) => {\n      if (errored) {\n        return (\n          <ErrorPanel>\n            <IconWarning color=\"gray300\" size=\"lg\" />\n          </ErrorPanel>\n        );\n      }\n      const seriesData = results ? results : timeseriesData;\n\n      return (\n        <TransitionChart loading={loading} reloading={reloading}>\n          <TransparentLoadingMask visible={reloading} />\n\n          {React.isValidElement(chartHeader) && chartHeader}\n\n          <Chart\n            zoomRenderProps={zoomRenderProps}\n            loading={loading}\n            reloading={reloading}\n            showLegend={showLegend}\n            releaseSeries={releaseSeries || []}\n            timeseriesData={seriesData ?? []}\n            previousTimeseriesData={previousTimeseriesData}\n            currentSeriesName={currentSeriesName}\n            previousSeriesName={previousSeriesName}\n            seriesNameTransformer={seriesNameTransformer}\n            stacked={typeof topEvents === 'number' && topEvents > 0}\n            yAxis={yAxis}\n            showDaily={showDaily}\n            colors={colors}\n            legendOptions={legendOptions}\n            chartOptions={chartOptions}\n          />\n        </TransitionChart>\n      );\n    };\n\n    if (!disableReleases) {\n      const previousChart = chartImplementation;\n      chartImplementation = chartProps => (\n        <ReleaseSeries\n          utc={utc}\n          period={period}\n          start={start}\n          end={end}\n          projects={projects}\n          environments={environments}\n          emphasizeReleases={emphasizeReleases}\n          preserveQueryParams={preserveReleaseQueryParams}\n          queryExtra={releaseQueryExtra}\n        >\n          {({releaseSeries}) => previousChart({...chartProps, releaseSeries})}\n        </ReleaseSeries>\n      );\n    }\n\n    return (\n      <ChartZoom router={router} period={period} utc={utc} {...props}>\n        {zoomRenderProps => (\n          <EventsRequest\n            {...props}\n            api={api}\n            period={period}\n            project={projects}\n            environment={environments}\n            start={start}\n            end={end}\n            interval={intervalVal}\n            query={query}\n            includePrevious={includePrevious}\n            currentSeriesName={currentSeriesName}\n            previousSeriesName={previousSeriesName}\n            yAxis={yAxis}\n            field={field}\n            orderby={orderby}\n            topEvents={topEvents}\n            confirmedQuery={confirmedQuery}\n          >\n            {eventData =>\n              chartImplementation({\n                ...eventData,\n                zoomRenderProps,\n              })\n            }\n          </EventsRequest>\n        )}\n      </ChartZoom>\n    );\n  }\n}\n\nexport default EventsChart;\n","/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that negates the result of the predicate `func`. The\n * `func` predicate is invoked with the `this` binding and arguments of the\n * created function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n * @example\n *\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n * // => [1, 3, 5]\n */\nfunction negate(predicate) {\n  if (typeof predicate != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0: return !predicate.call(this);\n      case 1: return !predicate.call(this, args[0]);\n      case 2: return !predicate.call(this, args[0], args[1]);\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\n\nmodule.exports = negate;\n"],"sourceRoot":""}