{"version":3,"sources":["webpack:///./app/components/sentryDocumentTitle.tsx","webpack:///./app/views/performance/transactionVitals/constants.tsx","webpack:///./app/views/performance/transactionSummary/utils.tsx","webpack:///./app/views/alerts/utils/index.tsx","webpack:///./app/views/settings/incidentRules/types.tsx","webpack:///./app/views/settings/incidentRules/constants.tsx","webpack:///./app/views/alerts/types.tsx","webpack:///./app/views/alerts/utils/getIncidentDiscoverUrl.tsx","webpack:///./app/views/settings/incidentRules/presets.tsx"],"names":["SentryDocumentTitle","props","_title","title","objSlug","children","NUM_BUCKETS","PERCENTILE","WEB_VITAL_DETAILS","WebVital","FP","slug","name","t","acronym","description","failureThreshold","type","measurementType","FCP","LCP","FID","CLS","TTFB","RequestTime","LONG_WEB_VITAL_NAMES","Object","fromEntries","values","map","value","WEB_VITAL_ACRONYMS","FILTER_OPTIONS","label","_VITAL_GROUPS","vitals","min","precision","_COLORS","theme","charts","getColorPalette","reduce","count","length","reverse","VITAL_GROUPS","group","colors","splice","ZOOM_KEYS","keys","forEach","vital","vitalSlug","push","TransactionFilterOptions","transactionSummaryRouteWithQuery","orgSlug","transaction","projectID","query","unselectedSeries","display","trendDisplay","showTransactions","pathname","generateTransactionSummaryRoute","project","environment","statsPeriod","start","end","fetchIncident","api","orgId","alertId","requestPromise","fetchIncidentStats","updateSubscription","isSubscribed","method","updateStatus","status","data","isOpen","incident","IncidentStatus","CLOSED","getIncidentMetricPreset","alertRule","aggregate","dataset","Dataset","ERRORS","PRESET_AGGREGATES","find","p","validDataset","includes","match","test","getStartEndFromStats","stats","getUtcDateString","eventStats","isIssueAlert","hasOwnProperty","DATA_SOURCE_LABELS","TRANSACTIONS","Datasource","ERROR_DEFAULT","ERROR","DEFAULT","TRANSACTION","DATA_SOURCE_TO_SET_AND_EVENT_TYPES","eventTypes","EventTypes","convertDatasetEventTypesToSource","getQueryDatasource","slice","sort","join","source","replace","trim","toUpperCase","AlertRuleThreshold","AlertRuleThresholdType","TimePeriod","TimeWindow","ActionType","TargetType","DEFAULT_AGGREGATE","DATASET_EVENT_TYPE_FILTERS","DATASOURCE_EVENT_TYPE_FILTERS","errorFieldConfig","aggregations","fields","transactionFieldConfig","measurementKeys","createDefaultTrigger","alertThreshold","actions","createDefaultRule","timeWindow","triggers","projects","resolveThreshold","thresholdType","ABOVE","createRuleFromEventView","eventView","parsedQuery","datasetAndEventtypes","error","getYAxis","IncidentType","IncidentActivityType","IncidentStatusMethod","AlertRuleStatus","getIncidentDiscoverUrl","opts","extraQueryParams","timeWindowString","discoverQuery","id","undefined","orderby","getAggregateAlias","yAxis","filter","Number","version","EventView","fromSavedQuery","getResultsViewUrlTarget","toObject","interval","default","makeCtaParams","makeDefaultCta","makeGenericTransactionCta","tooltip","to","buttonText","tokenizeSearch","getTagValues","DisplayModes","TOP5","period","Set"],"mappings":"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","file":"AlertsDetails~AlertsList~DiscoverV2Results~PerformanceTransactionSummary~PerformanceTransactionVital~83e15da4.js","sourcesContent":["import React, {FunctionComponent} from 'react';\nimport DocumentTitle from 'react-document-title';\n\ntype DocumentTitleProps = {\n  // Main page title\n  title: string;\n  // Organization or project slug to give title some context\n  objSlug: string;\n  children?: React.ReactNode;\n};\n\nconst SentryDocumentTitle: FunctionComponent<DocumentTitleProps> = (\n  props: DocumentTitleProps\n) => {\n  const _title = `${props.title} - ${props.objSlug} - Sentry`;\n  return <DocumentTitle title={_title}>{props.children}</DocumentTitle>;\n};\n\nexport default SentryDocumentTitle;\n","import {t} from 'app/locale';\nimport {SelectValue} from 'app/types';\nimport {measurementType, WebVital} from 'app/utils/discover/fields';\nimport theme from 'app/utils/theme';\n\nimport {Vital, VitalGroup} from './types';\n\nexport const NUM_BUCKETS = 100;\n\nexport const PERCENTILE = 0.75;\n\nexport const WEB_VITAL_DETAILS: Record<WebVital, Vital> = {\n  [WebVital.FP]: {\n    slug: 'fp',\n    name: t('First Paint'),\n    acronym: 'FP',\n    description: t(\n      'Render time of the first pixel loaded in the viewport (may overlap with FCP).'\n    ),\n    failureThreshold: 3000,\n    type: measurementType(WebVital.FP),\n  },\n  [WebVital.FCP]: {\n    slug: 'fcp',\n    name: t('First Contentful Paint'),\n    acronym: 'FCP',\n    description: t(\n      'Render time of the first image, text or other DOM node in the viewport.'\n    ),\n    failureThreshold: 3000,\n    type: measurementType(WebVital.FCP),\n  },\n  [WebVital.LCP]: {\n    slug: 'lcp',\n    name: t('Largest Contentful Paint'),\n    acronym: 'LCP',\n    description: t(\n      'Render time of the largest image, text or other DOM node in the viewport.'\n    ),\n    failureThreshold: 4000,\n    type: measurementType(WebVital.LCP),\n  },\n  [WebVital.FID]: {\n    slug: 'fid',\n    name: t('First Input Delay'),\n    acronym: 'FID',\n    description: t(\n      'Response time of the browser to a user interaction (clicking, tapping, etc).'\n    ),\n    failureThreshold: 300,\n    type: measurementType(WebVital.FID),\n  },\n  [WebVital.CLS]: {\n    slug: 'cls',\n    name: t('Cumulative Layout Shift'),\n    acronym: 'CLS',\n    description: t(\n      'Sum of layout shift scores that measure the visual stability of the page.'\n    ),\n    failureThreshold: 0.25,\n    type: measurementType(WebVital.CLS),\n  },\n  [WebVital.TTFB]: {\n    slug: 'ttfb',\n    name: t('Time to First Byte'),\n    acronym: 'TTFB',\n    description: t(\n      \"The time that it takes for a user's browser to receive the first byte of page content.\"\n    ),\n    failureThreshold: 600,\n    type: measurementType(WebVital.TTFB),\n  },\n  [WebVital.RequestTime]: {\n    slug: 'ttfb.requesttime',\n    name: t('Request Time'),\n    acronym: 'RT',\n    description: t(\n      'Captures the time spent making the request and receiving the first byte of the response.'\n    ),\n    failureThreshold: 600,\n    type: measurementType(WebVital.RequestTime),\n  },\n};\n\n// translate known short form names into their long forms\nexport const LONG_WEB_VITAL_NAMES = Object.fromEntries(\n  Object.values(WEB_VITAL_DETAILS).map(value => {\n    return [value.slug, value.name];\n  })\n);\n\nexport const WEB_VITAL_ACRONYMS = Object.fromEntries(\n  Object.values(WEB_VITAL_DETAILS).map(value => {\n    return [value.slug, value.acronym];\n  })\n);\n\nexport const FILTER_OPTIONS: SelectValue<string>[] = [\n  {label: t('Exclude Outliers'), value: 'exclude_outliers'},\n  {label: t('View All'), value: 'all'},\n];\n\n/**\n * This defines the grouping for histograms. Histograms that are in the same group\n * will be queried together on initial load for alignment. However, the zoom controls\n * are defined for each measurement independently.\n */\nconst _VITAL_GROUPS = [\n  {\n    vitals: [WebVital.FP, WebVital.FCP, WebVital.LCP],\n    min: 0,\n  },\n  {\n    vitals: [WebVital.FID],\n    min: 0,\n    precision: 2,\n  },\n  {\n    vitals: [WebVital.CLS],\n    min: 0,\n    precision: 2,\n  },\n];\n\nconst _COLORS = [\n  ...theme.charts.getColorPalette(\n    _VITAL_GROUPS.reduce((count, {vitals}) => count + vitals.length, 0) - 1\n  ),\n].reverse();\n\nexport const VITAL_GROUPS: VitalGroup[] = _VITAL_GROUPS.map(group => ({\n  ...group,\n  colors: _COLORS.splice(0, group.vitals.length),\n}));\n\nexport const ZOOM_KEYS = _VITAL_GROUPS.reduce((keys: string[], {vitals}) => {\n  vitals.forEach(vital => {\n    const vitalSlug = WEB_VITAL_DETAILS[vital].slug;\n    keys.push(`${vitalSlug}Start`);\n    keys.push(`${vitalSlug}End`);\n  });\n  return keys;\n}, []);\n","import {Query} from 'history';\n\nimport {TrendFunctionField} from '../trends/types';\n\nimport {DisplayModes} from './charts';\n\nexport enum TransactionFilterOptions {\n  FASTEST = 'fastest',\n  SLOW = 'slow',\n  OUTLIER = 'outlier',\n  RECENT = 'recent',\n}\n\nexport function generateTransactionSummaryRoute({orgSlug}: {orgSlug: String}): string {\n  return `/organizations/${orgSlug}/performance/summary/`;\n}\n\nexport function transactionSummaryRouteWithQuery({\n  orgSlug,\n  transaction,\n  projectID,\n  query,\n  unselectedSeries = 'p100()',\n  display,\n  trendDisplay,\n  showTransactions,\n}: {\n  orgSlug: string;\n  transaction: string;\n  query: Query;\n  display?: DisplayModes;\n  trendDisplay?: TrendFunctionField;\n  unselectedSeries?: string | string[];\n  projectID?: string | string[];\n  showTransactions?: TransactionFilterOptions;\n}) {\n  const pathname = generateTransactionSummaryRoute({\n    orgSlug,\n  });\n\n  return {\n    pathname,\n    query: {\n      transaction,\n      project: projectID,\n      environment: query.environment,\n      statsPeriod: query.statsPeriod,\n      start: query.start,\n      end: query.end,\n      query: query.query,\n      unselectedSeries,\n      showTransactions,\n      display,\n      trendDisplay,\n    },\n  };\n}\n","import {Client} from 'app/api';\nimport {t} from 'app/locale';\nimport {NewQuery, Project} from 'app/types';\nimport {IssueAlertRule} from 'app/types/alerts';\nimport {getUtcDateString} from 'app/utils/dates';\nimport EventView from 'app/utils/discover/eventView';\nimport {getAggregateAlias} from 'app/utils/discover/fields';\nimport {PRESET_AGGREGATES} from 'app/views/settings/incidentRules/presets';\nimport {\n  Dataset,\n  Datasource,\n  EventTypes,\n  SavedIncidentRule,\n} from 'app/views/settings/incidentRules/types';\n\nimport {Incident, IncidentStats, IncidentStatus} from '../types';\n\nexport function fetchIncident(\n  api: Client,\n  orgId: string,\n  alertId: string\n): Promise<Incident> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/`);\n}\n\nexport function fetchIncidentStats(\n  api: Client,\n  orgId: string,\n  alertId: string\n): Promise<IncidentStats> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/stats/`);\n}\n\nexport function updateSubscription(\n  api: Client,\n  orgId: string,\n  alertId: string,\n  isSubscribed?: boolean\n): Promise<Incident> {\n  const method = isSubscribed ? 'POST' : 'DELETE';\n  return api.requestPromise(\n    `/organizations/${orgId}/incidents/${alertId}/subscriptions/`,\n    {\n      method,\n    }\n  );\n}\n\nexport function updateStatus(\n  api: Client,\n  orgId: string,\n  alertId: string,\n  status: IncidentStatus\n): Promise<Incident> {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${alertId}/`, {\n    method: 'PUT',\n    data: {\n      status,\n    },\n  });\n}\n\n/**\n * Is incident open?\n *\n * @param {Object} incident Incident object\n * @returns {Boolean}\n */\nexport function isOpen(incident: Incident): boolean {\n  switch (incident.status) {\n    case IncidentStatus.CLOSED:\n      return false;\n    default:\n      return true;\n  }\n}\n\nexport function getIncidentMetricPreset(incident: Incident) {\n  const alertRule = incident?.alertRule;\n  const aggregate = alertRule?.aggregate ?? '';\n  const dataset = alertRule?.dataset ?? Dataset.ERRORS;\n\n  return PRESET_AGGREGATES.find(\n    p => p.validDataset.includes(dataset) && p.match.test(aggregate)\n  );\n}\n\n/**\n * Gets start and end date query parameters from stats\n */\nexport function getStartEndFromStats(stats: IncidentStats) {\n  const start = getUtcDateString(stats.eventStats.data[0][0] * 1000);\n  const end = getUtcDateString(\n    stats.eventStats.data[stats.eventStats.data.length - 1][0] * 1000\n  );\n\n  return {start, end};\n}\n\n/**\n * Gets the URL for a discover view of the incident with the following default\n * parameters:\n *\n * - Ordered by the incident aggregate, descending\n * - yAxis maps to the aggregate\n * - The following fields are displayed:\n *   - For Error dataset alerts: [issue, count(), count_unique(user)]\n *   - For Transaction dataset alerts: [transaction, count()]\n * - Start and end are scoped to the same period as the alert rule\n */\nexport function getIncidentDiscoverUrl(opts: {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n  extraQueryParams?: Partial<NewQuery>;\n}) {\n  const {orgSlug, projects, incident, stats, extraQueryParams} = opts;\n\n  if (!projects || !projects.length || !incident || !stats) {\n    return '';\n  }\n\n  const timeWindowString = `${incident.alertRule.timeWindow}m`;\n  const {start, end} = getStartEndFromStats(stats);\n\n  const discoverQuery: NewQuery = {\n    id: undefined,\n    name: (incident && incident.title) || '',\n    orderby: `-${getAggregateAlias(incident.alertRule.aggregate)}`,\n    yAxis: incident.alertRule.aggregate,\n    query: incident?.discoverQuery ?? '',\n    projects: projects\n      .filter(({slug}) => incident.projects.includes(slug))\n      .map(({id}) => Number(id)),\n    version: 2,\n    fields:\n      incident.alertRule.dataset === Dataset.ERRORS\n        ? ['issue', 'count()', 'count_unique(user)']\n        : ['transaction', incident.alertRule.aggregate],\n    start,\n    end,\n    ...extraQueryParams,\n  };\n\n  const discoverView = EventView.fromSavedQuery(discoverQuery);\n  const {query, ...toObject} = discoverView.getResultsViewUrlTarget(orgSlug);\n\n  return {\n    query: {...query, interval: timeWindowString},\n    ...toObject,\n  };\n}\n\nexport function isIssueAlert(\n  data: IssueAlertRule | SavedIncidentRule\n): data is IssueAlertRule {\n  return !data.hasOwnProperty('triggers');\n}\n\nexport const DATA_SOURCE_LABELS = {\n  [Dataset.ERRORS]: t('Errors'),\n  [Dataset.TRANSACTIONS]: t('Transactions'),\n  [Datasource.ERROR_DEFAULT]: t('event.type:error OR event.type:default'),\n  [Datasource.ERROR]: t('event.type:error'),\n  [Datasource.DEFAULT]: t('event.type:default'),\n  [Datasource.TRANSACTION]: t('event.type:transaction'),\n};\n\n// Maps a datasource to the relevant dataset and event_types for the backend to use\nexport const DATA_SOURCE_TO_SET_AND_EVENT_TYPES = {\n  [Datasource.ERROR_DEFAULT]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR, EventTypes.DEFAULT],\n  },\n  [Datasource.ERROR]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR],\n  },\n  [Datasource.DEFAULT]: {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.DEFAULT],\n  },\n  [Datasource.TRANSACTION]: {\n    dataset: Dataset.TRANSACTIONS,\n    eventTypes: [EventTypes.TRANSACTION],\n  },\n};\n\n// Converts the given dataset and event types array to a datasource for the datasource dropdown\nexport function convertDatasetEventTypesToSource(\n  dataset: Dataset,\n  eventTypes: EventTypes[]\n) {\n  // transactions only has one datasource option regardless of event type\n  if (dataset === Dataset.TRANSACTIONS) {\n    return Datasource.TRANSACTION;\n  }\n  // if no event type was provided use the default datasource\n  if (!eventTypes) {\n    return Datasource.ERROR;\n  }\n\n  if (eventTypes.includes(EventTypes.DEFAULT) && eventTypes.includes(EventTypes.ERROR)) {\n    return Datasource.ERROR_DEFAULT;\n  } else if (eventTypes.includes(EventTypes.DEFAULT)) {\n    return Datasource.DEFAULT;\n  } else {\n    return Datasource.ERROR;\n  }\n}\n\n/**\n * Attempt to guess the data source of a discover query\n *\n * @returns An object containing the datasource and new query without the datasource.\n * Returns null on no datasource.\n */\nexport function getQueryDatasource(\n  query: string\n): {source: Datasource; query: string} | null {\n  let match = query.match(\n    /\\(?\\bevent\\.type:(error|default|transaction)\\)?\\WOR\\W\\(?event\\.type:(error|default|transaction)\\)?/i\n  );\n  if (match) {\n    // should be [error, default] or [default, error]\n    const eventTypes = match.slice(1, 3).sort().join(',');\n    if (eventTypes !== 'default,error') {\n      return null;\n    }\n\n    return {source: Datasource.ERROR_DEFAULT, query: query.replace(match[0], '').trim()};\n  }\n\n  match = query.match(/(^|\\s)event\\.type:(error|default|transaction)/i);\n  if (match && Datasource[match[2].toUpperCase()]) {\n    return {\n      source: Datasource[match[2].toUpperCase()],\n      query: query.replace(match[0], '').trim(),\n    };\n  }\n\n  return null;\n}\n","export enum AlertRuleThreshold {\n  INCIDENT,\n  RESOLUTION,\n}\n\nexport enum AlertRuleThresholdType {\n  ABOVE,\n  BELOW,\n}\n\nexport enum Dataset {\n  ERRORS = 'events',\n  TRANSACTIONS = 'transactions',\n}\n\nexport enum EventTypes {\n  DEFAULT = 'default',\n  ERROR = 'error',\n  TRANSACTION = 'transaction',\n}\n\nexport enum Datasource {\n  ERROR_DEFAULT = 'error_default',\n  DEFAULT = 'default',\n  ERROR = 'error',\n  TRANSACTION = 'transaction',\n}\n\nexport type UnsavedTrigger = {\n  // UnsavedTrigger can be apart of an Unsaved Alert Rule that does not have an\n  // id yet\n  alertRuleId?: string;\n  label: string;\n  alertThreshold: number | '' | null;\n  actions: Action[];\n};\n\nexport type ThresholdControlValue = {\n  thresholdType: AlertRuleThresholdType;\n  /**\n   * Resolve threshold is optional, so it can be null\n   */\n  threshold: number | '' | null;\n};\n\nexport type SavedTrigger = Omit<UnsavedTrigger, 'actions'> & {\n  id: string;\n  dateCreated: string;\n  actions: Action[];\n};\n\nexport type Trigger = Partial<SavedTrigger> & UnsavedTrigger;\n\nexport type UnsavedIncidentRule = {\n  dataset: Dataset;\n  projects: string[];\n  environment: string | null;\n  query: string;\n  timeWindow: TimeWindow;\n  triggers: Trigger[];\n  aggregate: string;\n  thresholdType: AlertRuleThresholdType;\n  resolveThreshold: number | '' | null;\n  eventTypes?: EventTypes[];\n};\n\nexport type SavedIncidentRule = UnsavedIncidentRule & {\n  dateCreated: string;\n  dateModified: string;\n  id: string;\n  status: number;\n  name: string;\n};\n\nexport type IncidentRule = Partial<SavedIncidentRule> & UnsavedIncidentRule;\n\nexport enum TimePeriod {\n  SIX_HOURS = '6h',\n  ONE_DAY = '1d',\n  THREE_DAYS = '3d',\n  // Seven days is actually 10080m but we have a max of 10000 events\n  SEVEN_DAYS = '10000m',\n  FOURTEEN_DAYS = '14d',\n  THIRTY_DAYS = '30d',\n}\n\nexport enum TimeWindow {\n  ONE_MINUTE = 1,\n  FIVE_MINUTES = 5,\n  TEN_MINUTES = 10,\n  FIFTEEN_MINUTES = 15,\n  THIRTY_MINUTES = 30,\n  ONE_HOUR = 60,\n  TWO_HOURS = 120,\n  FOUR_HOURS = 240,\n  ONE_DAY = 1440,\n}\n\nexport type ProjectSelectOption = {\n  label: string;\n  value: number;\n};\n\nexport enum ActionType {\n  EMAIL = 'email',\n  SLACK = 'slack',\n  PAGERDUTY = 'pagerduty',\n  MSTEAMS = 'msteams',\n  SENTRY_APP = 'sentry_app',\n}\n\nexport enum TargetType {\n  // A direct reference, like an email address, Slack channel, or PagerDuty service\n  SPECIFIC = 'specific',\n\n  // A specific user. This could be used to grab the user's email address.\n  USER = 'user',\n\n  // A specific team. This could be used to send an email to everyone associated with a team.\n  TEAM = 'team',\n\n  // A Sentry App instead of any of the above.\n  SENTRY_APP = 'sentry_app',\n}\n\n/**\n * This is an available action template that is associated to a Trigger in a\n * Metric Alert Rule. They are defined by the available-actions API.\n */\nexport type MetricActionTemplate = {\n  /**\n   * The integration type e.g. 'email'\n   */\n  type: ActionType;\n\n  /**\n   * See `TargetType`\n   */\n  allowedTargetTypes: TargetType[];\n\n  /**\n   * Name of the integration. This is a text field that differentiates integrations from the same provider from each other\n   */\n  integrationName?: string;\n\n  /**\n   * Integration id for this `type`, should be passed to backend as `integrationId` when creating an action\n   */\n  integrationId?: number;\n\n  /**\n   * Name of the SentryApp. Like `integrationName`, this differentiates SentryApps from each other.\n   */\n  sentryAppName?: string;\n\n  /**\n   * SentryApp id for this `type`, should be passed to backend as `sentryAppId` when creating an action.\n   */\n  sentryAppId?: number;\n\n  /**\n   * For some available actions, we pass in the list of available targets.\n   */\n  options?: Array<{label: string; value: any}>;\n\n  /**\n   * If this is a `sentry_app` action, this is the Sentry App's status.\n   */\n  status?: 'unpublished' | 'published' | 'internal';\n};\n\n/**\n * This is the user's configured action\n */\nexport type Action = UnsavedAction & Partial<SavedActionFields>;\nexport type SavedAction = UnsavedAction & SavedActionFields;\n\ntype SavedActionFields = {\n  /**\n   * The id of the alert rule this action belongs to\n   */\n  alertRuleTriggerId: string;\n\n  /**\n   * A human readable description of the action generated by server\n   */\n  desc: string;\n\n  /**\n   * model id of the action\n   */\n  id: string;\n\n  /**\n   * date created\n   */\n  dateCreated: string;\n};\n\nexport type UnsavedAction = {\n  type: ActionType;\n\n  targetType: TargetType | null;\n\n  /**\n   * How to identify the target. Can be email, slack channel, pagerduty service,\n   * user_id, team_id, SentryApp id, etc\n   */\n  targetIdentifier: string | null;\n\n  /**\n   * The id of the integration, can be null (e.g. email) or undefined (server errors when posting w/ null value)\n   */\n  integrationId?: number | null;\n\n  /**\n   * The id of the SentryApp, can be null (e.g. email) or undefined (server errors when posting w/ null value)\n   */\n  sentryAppId?: number | null;\n\n  /**\n   * For some available actions, we pass in the list of available targets.\n   */\n  options: Array<{label: string; value: any}> | null;\n\n  /**\n   * If this is a `sentry_app` action, this is the Sentry App's status.\n   */\n  status?: 'unpublished' | 'published' | 'internal';\n};\n","import EventView from 'app/utils/discover/eventView';\nimport {AggregationKey, LooseFieldKey} from 'app/utils/discover/fields';\nimport {\n  DATA_SOURCE_TO_SET_AND_EVENT_TYPES,\n  getQueryDatasource,\n} from 'app/views/alerts/utils';\nimport {WEB_VITAL_DETAILS} from 'app/views/performance/transactionVitals/constants';\nimport {\n  AlertRuleThresholdType,\n  Dataset,\n  Datasource,\n  EventTypes,\n  Trigger,\n  UnsavedIncidentRule,\n} from 'app/views/settings/incidentRules/types';\n\nexport const DEFAULT_AGGREGATE = 'count()';\n\nexport const DATASET_EVENT_TYPE_FILTERS = {\n  [Dataset.ERRORS]: 'event.type:error',\n  [Dataset.TRANSACTIONS]: 'event.type:transaction',\n} as const;\n\nexport const DATASOURCE_EVENT_TYPE_FILTERS = {\n  [Datasource.ERROR_DEFAULT]: '(event.type:error OR event.type:default)',\n  [Datasource.ERROR]: 'event.type:error',\n  [Datasource.DEFAULT]: 'event.type:default',\n  [Datasource.TRANSACTION]: 'event.type:transaction',\n} as const;\n\ntype OptionConfig = {\n  aggregations: AggregationKey[];\n  fields: LooseFieldKey[];\n  measurementKeys?: string[];\n};\n\n/**\n * Allowed error aggregations for alerts\n */\nexport const errorFieldConfig: OptionConfig = {\n  aggregations: ['count', 'count_unique'],\n  fields: ['user'],\n};\n\n/**\n * Allowed transaction aggregations for alerts\n */\nexport const transactionFieldConfig: OptionConfig = {\n  aggregations: [\n    'avg',\n    'percentile',\n    'failure_rate',\n    'apdex',\n    'count',\n    'p50',\n    'p75',\n    'p95',\n    'p99',\n    'p100',\n  ],\n  fields: ['transaction.duration'],\n  measurementKeys: Object.keys(WEB_VITAL_DETAILS),\n};\n\nexport function createDefaultTrigger(label: 'critical' | 'warning'): Trigger {\n  return {\n    label,\n    alertThreshold: '',\n    actions: [],\n  };\n}\n\nexport function createDefaultRule(): UnsavedIncidentRule {\n  return {\n    dataset: Dataset.ERRORS,\n    eventTypes: [EventTypes.ERROR],\n    aggregate: DEFAULT_AGGREGATE,\n    query: '',\n    timeWindow: 1,\n    triggers: [createDefaultTrigger('critical'), createDefaultTrigger('warning')],\n    projects: [],\n    environment: null,\n    resolveThreshold: '',\n    thresholdType: AlertRuleThresholdType.ABOVE,\n  };\n}\n\n/**\n * Create an unsaved alert from a discover EventView object\n */\nexport function createRuleFromEventView(eventView: EventView): UnsavedIncidentRule {\n  const parsedQuery = getQueryDatasource(eventView.query);\n  const datasetAndEventtypes = parsedQuery\n    ? DATA_SOURCE_TO_SET_AND_EVENT_TYPES[parsedQuery.source]\n    : DATA_SOURCE_TO_SET_AND_EVENT_TYPES.error;\n  return {\n    ...createDefaultRule(),\n    ...datasetAndEventtypes,\n    query: parsedQuery?.query ?? eventView.query,\n    aggregate: eventView.getYAxis(),\n    environment: eventView.environment.length ? eventView.environment[0] : null,\n  };\n}\n","import {Repository, User} from 'app/types';\nimport {IncidentRule} from 'app/views/settings/incidentRules/types';\n\ntype Data = [number, {count: number}[]][];\n\nexport type Incident = {\n  dateClosed: string | null;\n  dateStarted: string;\n  dateDetected: string;\n  dateCreated: string;\n  id: string;\n  identifier: string;\n  isSubscribed: boolean;\n  groups: string[]; // Array of group ids\n  discoverQuery: string;\n  organizationId: string;\n  projects: string[]; // Array of slugs\n  seenBy: User[];\n  status: IncidentStatus;\n  statusMethod: IncidentStatusMethod;\n  title: string;\n  hasSeen: boolean;\n  alertRule: IncidentRule;\n};\n\nexport type IncidentStats = {\n  eventStats: {\n    data: Data;\n  };\n  totalEvents: number;\n  uniqueUsers: number;\n};\n\nexport type IncidentSuspect = {\n  author: User;\n  dateCreated: string;\n  id: string;\n  message: string;\n  repository: Repository;\n};\n\nexport type ActivityTypeDraft = {\n  comment: null | string;\n  dateCreated: string;\n  id: string;\n  incidentIdentifier: string;\n  type: IncidentActivityType;\n  user: User | null;\n};\n\nexport type ActivityType = ActivityTypeDraft & {\n  eventStats?: {data: Data};\n  previousValue: string | null;\n  value: string | null;\n};\n\nexport enum IncidentType {\n  DETECTED,\n  CREATED,\n  TRIGGERED,\n}\n\nexport enum IncidentActivityType {\n  CREATED = 0,\n  DETECTED = 1,\n  STATUS_CHANGE = 2,\n  COMMENT = 3,\n  STARTED = 4,\n}\n\nexport enum IncidentStatus {\n  OPENED = 1,\n  CLOSED = 2,\n  WARNING = 10,\n  CRITICAL = 20,\n}\n\nexport enum IncidentStatusMethod {\n  MANUAL = 1,\n  RULE_UPDATED = 2,\n  RULE_TRIGGERED = 3,\n}\n\nexport enum AlertRuleStatus {\n  PENDING = 0,\n  SNAPSHOT = 4,\n  DISABLED = 5,\n}\n","import {NewQuery, Project} from 'app/types';\nimport EventView from 'app/utils/discover/eventView';\nimport {getAggregateAlias} from 'app/utils/discover/fields';\nimport {Incident, IncidentStats} from 'app/views/alerts/types';\nimport {getStartEndFromStats} from 'app/views/alerts/utils';\nimport {Dataset} from 'app/views/settings/incidentRules/types';\n/**\n * Gets the URL for a discover view of the incident with the following default\n * parameters:\n *\n * - Ordered by the incident aggregate, descending\n * - yAxis maps to the aggregate\n * - The following fields are displayed:\n *   - For Error dataset alerts: [issue, count(), count_unique(user)]\n *   - For Transaction dataset alerts: [transaction, count()]\n * - Start and end are scoped to the same period as the alert rule\n */\nexport function getIncidentDiscoverUrl(opts: {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n  extraQueryParams?: Partial<NewQuery>;\n}) {\n  const {orgSlug, projects, incident, stats, extraQueryParams} = opts;\n\n  if (!projects || !projects.length || !incident || !stats) {\n    return '';\n  }\n\n  const timeWindowString = `${incident.alertRule.timeWindow}m`;\n  const {start, end} = getStartEndFromStats(stats);\n\n  const discoverQuery: NewQuery = {\n    id: undefined,\n    name: (incident && incident.title) || '',\n    orderby: `-${getAggregateAlias(incident.alertRule.aggregate)}`,\n    yAxis: incident.alertRule.aggregate,\n    query: incident?.discoverQuery ?? '',\n    projects: projects\n      .filter(({slug}) => incident.projects.includes(slug))\n      .map(({id}) => Number(id)),\n    version: 2,\n    fields:\n      incident.alertRule.dataset === Dataset.ERRORS\n        ? ['issue', 'count()', 'count_unique(user)']\n        : ['transaction', incident.alertRule.aggregate],\n    start,\n    end,\n    ...extraQueryParams,\n  };\n\n  const discoverView = EventView.fromSavedQuery(discoverQuery);\n  const {query, ...toObject} = discoverView.getResultsViewUrlTarget(orgSlug);\n\n  return {\n    query: {...query, interval: timeWindowString},\n    ...toObject,\n  };\n}\n","import Link from 'app/components/links/link';\nimport {t} from 'app/locale';\nimport {Project} from 'app/types';\nimport {DisplayModes} from 'app/utils/discover/types';\nimport {tokenizeSearch} from 'app/utils/tokenizeSearch';\nimport {Incident, IncidentStats} from 'app/views/alerts/types';\nimport {getStartEndFromStats} from 'app/views/alerts/utils';\nimport {getIncidentDiscoverUrl} from 'app/views/alerts/utils/getIncidentDiscoverUrl';\nimport {transactionSummaryRouteWithQuery} from 'app/views/performance/transactionSummary/utils';\n\nimport {Dataset} from './types';\n\ntype PresetCta = {\n  /**\n   * The location to direct to upon clicking the CTA.\n   */\n  to: React.ComponentProps<typeof Link>['to'];\n  /**\n   * The CTA text\n   */\n  buttonText: string;\n  /**\n   * The tooltip title for the CTA button, may be empty.\n   */\n  title?: string;\n};\n\ntype PresetCtaOpts = {\n  orgSlug: string;\n  projects: Project[];\n  incident?: Incident;\n  stats?: IncidentStats;\n};\n\ntype Preset = {\n  /**\n   * The regex used to match aggregates to this preset.\n   */\n  match: RegExp;\n  /**\n   * The name of the preset\n   */\n  name: string;\n  /**\n   * The dataset that this preset applys to.\n   */\n  validDataset: Dataset[];\n  /**\n   * The default aggregate to use when selecting this preset\n   */\n  default: string;\n  /**\n   * Generates the CTA component\n   */\n  makeCtaParams: (opts: PresetCtaOpts) => PresetCta;\n};\n\nexport const PRESET_AGGREGATES: Preset[] = [\n  {\n    name: t('Error count'),\n    match: /^count\\(\\)/,\n    validDataset: [Dataset.ERRORS],\n    default: 'count()',\n    /**\n     * Simple \"Open in Discover\" button\n     */\n    makeCtaParams: makeDefaultCta,\n  },\n  {\n    name: t('Users affected'),\n    match: /^count_unique\\(tags\\[sentry:user\\]\\)/,\n    validDataset: [Dataset.ERRORS],\n    default: 'count_unique(tags[sentry:user])',\n    /**\n     * Simple \"Open in Discover\" button\n     */\n    makeCtaParams: makeDefaultCta,\n  },\n  {\n    name: t('Latency'),\n    match: /^(p[0-9]{2,3}|percentile\\(transaction\\.duration,[^)]+\\)|avg\\([^)]+\\))/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'percentile(transaction.duration, 0.95)',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts =>\n      makeGenericTransactionCta({\n        opts,\n        tooltip: t('Latency by Transaction'),\n      }),\n  },\n  {\n    name: t('Apdex'),\n    match: /^apdex\\([0-9.]+\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'apdex(300)',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts =>\n      makeGenericTransactionCta({\n        opts,\n        tooltip: t('Apdex by Transaction'),\n      }),\n  },\n  {\n    name: t('Transaction Count'),\n    match: /^count\\(\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'count()',\n    /**\n     * see: makeGenericTransactionCta\n     */\n    makeCtaParams: opts => makeGenericTransactionCta({opts}),\n  },\n  {\n    name: t('Failure rate'),\n    match: /^failure_rate\\(\\)/,\n    validDataset: [Dataset.TRANSACTIONS],\n    default: 'failure_rate()',\n    /**\n     * See makeFailureRateCta\n     */\n    makeCtaParams: makeFailureRateCta,\n  },\n];\n\n/**\n * - CASE 1: If has a specific transaction filter\n *   - CTA is: \"View Transaction Summary\"\n *   - Tooltip is the transaction name\n *   - the same period as the alert graph (i.e. with alert start time in the middle)\n *\n * - CASE 2: If transaction is NOT filtered, or has a * filter:\n *   - \"Open in Discover\" button with optional tooltip which opens a discover view with...\n *      - fields {transaction, count(), <metric>} sorted by count()\n *      - top-5 activated\n */\nfunction makeGenericTransactionCta(opts: {\n  opts: PresetCtaOpts;\n  tooltip?: string;\n}): PresetCta {\n  const {\n    opts: {orgSlug, projects, incident, stats},\n    tooltip,\n  } = opts;\n\n  if (!incident || !stats) {\n    return {to: '', buttonText: t('Incident details')};\n  }\n\n  const query = tokenizeSearch(incident.discoverQuery ?? '');\n  const transaction = query\n    .getTagValues('transaction')\n    ?.find(filter => !filter.includes('*'));\n\n  // CASE 1\n  if (transaction !== undefined) {\n    const period = getStartEndFromStats(stats);\n\n    const summaryUrl = transactionSummaryRouteWithQuery({\n      orgSlug,\n      transaction,\n      projectID: projects\n        .filter(({slug}) => incident.projects.includes(slug))\n        .map(({id}) => id),\n      query: {...period},\n    });\n\n    return {\n      to: summaryUrl,\n      buttonText: t('View Transaction Summary'),\n      title: transaction,\n    };\n  }\n\n  // CASE 2\n  const extraQueryParams = {\n    fields: [...new Set(['transaction', 'count()', incident.alertRule.aggregate])],\n    orderby: '-count',\n    display: DisplayModes.TOP5,\n  };\n\n  const discoverUrl = getIncidentDiscoverUrl({\n    orgSlug,\n    projects,\n    incident,\n    stats,\n    extraQueryParams,\n  });\n\n  return {\n    to: discoverUrl,\n    buttonText: t('Open in Discover'),\n    title: tooltip,\n  };\n}\n\n/**\n * - CASE 1: Filtered to a specific transaction, \"Open in Discover\" with...\n *   - fields [transaction.status, count()] sorted by count(),\n *   - \"Top 5 period\" activated.\n *\n * - CASE 2: If filtered on multiple transactions, \"Open in Discover\" button\n *   with tooltip \"Failure rate by transaction\" which opens a discover view\n *   - fields [transaction, failure_rate()] sorted by failure_rate\n *   - top 5 activated\n */\nfunction makeFailureRateCta({orgSlug, incident, projects, stats}: PresetCtaOpts) {\n  if (!incident || !stats) {\n    return {to: '', buttonText: t('Incident details')};\n  }\n\n  const query = tokenizeSearch(incident.discoverQuery ?? '');\n  const transaction = query\n    .getTagValues('transaction')\n    ?.find(filter => !filter.includes('*'));\n\n  const extraQueryParams =\n    transaction !== undefined\n      ? // CASE 1\n        {\n          fields: ['transaction.status', 'count()'],\n          orderby: '-count',\n          display: DisplayModes.TOP5,\n        }\n      : // Case 2\n        {\n          fields: ['transaction', 'failure_rate()'],\n          orderby: '-failure_rate',\n          display: DisplayModes.TOP5,\n        };\n\n  const discoverUrl = getIncidentDiscoverUrl({\n    orgSlug,\n    projects,\n    incident,\n    stats,\n    extraQueryParams,\n  });\n\n  return {\n    to: discoverUrl,\n    buttonText: t('Open in Discover'),\n    title: transaction === undefined ? t('Failure rate by transaction') : undefined,\n  };\n}\n\n/**\n * Get the CTA used for alerts that do not have a preset\n */\nexport function makeDefaultCta({\n  orgSlug,\n  projects,\n  incident,\n  stats,\n}: PresetCtaOpts): PresetCta {\n  if (!incident) {\n    return {\n      buttonText: t('Open in Discover'),\n      to: '',\n    };\n  }\n\n  const extraQueryParams = {\n    display: DisplayModes.TOP5,\n  };\n\n  return {\n    buttonText: t('Open in Discover'),\n    to: getIncidentDiscoverUrl({orgSlug, projects, incident, stats, extraQueryParams}),\n  };\n}\n"],"sourceRoot":""}