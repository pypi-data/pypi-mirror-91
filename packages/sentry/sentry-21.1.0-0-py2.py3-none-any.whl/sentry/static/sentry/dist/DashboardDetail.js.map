{"version":3,"sources":["webpack:///./app/utils/discover/charts.tsx","webpack:///./app/components/charts/errorPanel.tsx","webpack:///./app/components/charts/lineChart.tsx","webpack:///./app/components/charts/chartZoom.tsx","webpack:///./app/components/charts/transitionChart.tsx","webpack:///./app/components/charts/loadingPanel.tsx","webpack:///./app/actionCreators/events.tsx","webpack:///./app/utils/getPeriod.tsx"],"names":["tooltipFormatter","value","seriesName","aggregateOutputType","toLocaleString","formatPercentage","getDuration","toString","axisLabelFormatter","abbreviation","formatAbbreviatedNumber","axisDuration","WEEK","label","toFixed","t","DAY","HOUR","MINUTE","SECOND","ErrorPanel","p","height","LineChart","this","props","series","seriesOptions","map","data","dataArray","options","LineSeries","name","animation","animationThreshold","animationDuration","React","Component","getDate","date","moment","utc","format","HTML5_FMT","DATETIME_LOCAL_SECONDS","ChartZoom","history","currentPeriod","zooming","saveCurrentPeriod","period","start","end","setPeriod","saveHistory","router","onZoom","startFormatted","endFormatted","push","callIfFunction","updateDateTime","getUtcToLocalDateObject","handleChartReady","chart","dispatchAction","type","key","dataZoomSelectActive","onChartReady","handleZoomRestore","evt","length","onRestore","handleDataZoom","axis","getModel","option","xAxis","rangeStart","rangeEnd","previousPeriod","pop","onDataZoom","handleChartFinished","onFinished","disabled","_utc","_start","_end","children","xAxisIndex","undefined","isGroupedByDate","dataZoom","DataZoomInside","showTimeInTooltip","toolBox","ToolBox","title","zoom","back","iconStyle","borderWidth","color","opacity","TransitionChart","state","prevReloading","reloading","prevLoading","loading","data-test-id","Fragment","String","nextReloading","nextLoading","defaultProps","LoadingPanel","doEventsRequest","api","organization","project","environment","interval","includePrevious","query","yAxis","field","topEvents","orderby","shouldDoublePeriod","canIncludePreviousPeriod","urlQuery","Object","fromEntries","entries","filter","periodObj","getPeriod","requestPromise","slug","fetchTagFacets","orgSlug","a","urlParams","pick","values","URL_PARAM","queryOption","fetchTotalCount","then","res","count","DEFAULT_STATS_PERIOD","statsPeriod","match","periodNumber","periodLength","parseInt","Error","formattedStart","getUtcDateString","formattedEnd","diff","previousPeriodStart","subtract"],"mappings":"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","file":"DashboardDetail.js","sourcesContent":["import {t} from 'app/locale';\nimport {aggregateOutputType} from 'app/utils/discover/fields';\nimport {\n  DAY,\n  formatAbbreviatedNumber,\n  formatPercentage,\n  getDuration,\n  HOUR,\n  MINUTE,\n  SECOND,\n  WEEK,\n} from 'app/utils/formatters';\n\n/**\n * Formatter for chart tooltips that handle a variety of discover result values\n */\nexport function tooltipFormatter(value: number, seriesName: string = ''): string {\n  switch (aggregateOutputType(seriesName)) {\n    case 'integer':\n    case 'number':\n      return value.toLocaleString();\n    case 'percentage':\n      return formatPercentage(value, 2);\n    case 'duration':\n      return getDuration(value / 1000, 2, true);\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Formatter for chart axis labels that handle a variety of discover result values\n * This function is *very similar* to tooltipFormatter but outputs data with less precision.\n */\nexport function axisLabelFormatter(\n  value: number,\n  seriesName: string,\n  abbreviation: boolean = false\n): string {\n  switch (aggregateOutputType(seriesName)) {\n    case 'integer':\n    case 'number':\n      return abbreviation ? formatAbbreviatedNumber(value) : value.toLocaleString();\n    case 'percentage':\n      return formatPercentage(value, 0);\n    case 'duration':\n      return axisDuration(value);\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Specialized duration formatting for axis labels.\n * In that context we are ok sacrificing accuracy for more\n * consistent sizing.\n *\n * @param value Number of milliseconds to format.\n */\nexport function axisDuration(value: number): string {\n  if (value === 0) {\n    return '0';\n  }\n  if (value >= WEEK) {\n    const label = (value / WEEK).toFixed(0);\n    return t('%swk', label);\n  }\n  if (value >= DAY) {\n    const label = (value / DAY).toFixed(0);\n    return t('%sd', label);\n  }\n  if (value >= HOUR) {\n    const label = (value / HOUR).toFixed(0);\n    return t('%shr', label);\n  }\n  if (value >= MINUTE) {\n    const label = (value / MINUTE).toFixed(0);\n    return t('%smin', label);\n  }\n  if (value >= SECOND) {\n    const label = (value / SECOND).toFixed(0);\n    return t('%ss', label);\n  }\n  const label = (value / SECOND).toFixed(1);\n  return t('%ss', label);\n}\n","import styled from '@emotion/styled';\n\nconst ErrorPanel = styled('div')<{height?: string}>`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  flex: 1;\n  flex-shrink: 0;\n  overflow: hidden;\n  height: ${p => p.height || '200px'};\n  position: relative;\n  border-color: transparent;\n  margin-bottom: 0;\n`;\n\nexport default ErrorPanel;\n","import React from 'react';\nimport {EChartOption} from 'echarts';\n\nimport {Series} from 'app/types/echarts';\n\nimport LineSeries from './series/lineSeries';\nimport BaseChart from './baseChart';\n\ntype ChartProps = React.ComponentProps<typeof BaseChart>;\n\nexport type LineChartSeries = Series &\n  Omit<EChartOption.SeriesLine, 'data' | 'name' | 'lineStyle'> & {\n    dataArray?: EChartOption.SeriesLine['data'];\n    lineStyle?: any; // TODO(ts): Fix when echarts type is updated so that EchartOption.LineStyle matches SeriesLine['lineStyle']\n  };\n\ntype Props = Omit<ChartProps, 'series'> & {\n  series: LineChartSeries[];\n  seriesOptions?: EChartOption.SeriesLine;\n};\n\nexport default class LineChart extends React.Component<Props> {\n  render() {\n    const {series, seriesOptions, ...props} = this.props;\n\n    return (\n      <BaseChart\n        {...props}\n        series={series.map(({seriesName, data, dataArray, ...options}) =>\n          LineSeries({\n            ...seriesOptions,\n            ...options,\n            name: seriesName,\n            data: dataArray || data.map(({value, name}) => [name, value]),\n            animation: false,\n            animationThreshold: 1,\n            animationDuration: 0,\n          })\n        )}\n      />\n    );\n  }\n}\n","import React from 'react';\nimport {WithRouterProps} from 'react-router/lib/withRouter';\nimport {EChartOption} from 'echarts/lib/echarts';\nimport moment from 'moment';\nimport PropTypes from 'prop-types';\n\nimport {updateDateTime} from 'app/actionCreators/globalSelection';\nimport DataZoomInside from 'app/components/charts/components/dataZoomInside';\nimport ToolBox from 'app/components/charts/components/toolBox';\nimport SentryTypes from 'app/sentryTypes';\nimport {DateString} from 'app/types';\nimport {\n  EChartChartReadyHandler,\n  EChartDataZoomHandler,\n  EChartFinishedHandler,\n  EChartRestoreHandler,\n} from 'app/types/echarts';\nimport {callIfFunction} from 'app/utils/callIfFunction';\nimport {getUtcToLocalDateObject} from 'app/utils/dates';\n\nconst getDate = date =>\n  date ? moment.utc(date).format(moment.HTML5_FMT.DATETIME_LOCAL_SECONDS) : null;\n\ntype Period = {\n  period: string;\n  start: DateString;\n  end: DateString;\n};\n\nconst ZoomPropKeys = [\n  'period',\n  'xAxis',\n  'onChartReady',\n  'onDataZoom',\n  'onRestore',\n  'onFinished',\n] as const;\n\nexport type ZoomRenderProps = Pick<Props, typeof ZoomPropKeys[number]> & {\n  utc?: boolean;\n  start?: Date;\n  end?: Date;\n  isGroupedByDate?: boolean;\n  showTimeInTooltip?: boolean;\n  dataZoom?: EChartOption.DataZoom[];\n  toolBox?: EChartOption['toolbox'];\n};\n\ntype Props = {\n  router?: WithRouterProps['router'];\n  children: (props: ZoomRenderProps) => React.ReactNode;\n  disabled?: boolean;\n  xAxis?: EChartOption.XAxis;\n  xAxisIndex?: number | number[];\n  start?: DateString;\n  end?: DateString;\n  period?: string;\n  utc?: boolean | null;\n  onChartReady?: EChartChartReadyHandler;\n  onDataZoom?: EChartDataZoomHandler;\n  onFinished?: EChartFinishedHandler;\n  onRestore?: EChartRestoreHandler;\n  onZoom?: (Period) => void;\n};\n\n/**\n * This is a very opinionated component that takes a render prop through `children`. It\n * will provide props to be passed to `BaseChart` to enable support of zooming without\n * eCharts' clunky zoom toolboxes.\n *\n * This also is very tightly coupled with the Global Selection Header. We can make it more\n * generic if need be in the future.\n */\nclass ChartZoom extends React.Component<Props> {\n  static propTypes = {\n    router: PropTypes.object,\n    period: PropTypes.string,\n    start: PropTypes.instanceOf(Date),\n    end: PropTypes.instanceOf(Date),\n    utc: PropTypes.bool,\n    disabled: PropTypes.bool,\n\n    xAxis: SentryTypes.EChartsXAxis,\n    /**\n     * If you need the dataZoom control to control more than one chart.\n     * you can provide a list of the axis indexes.\n     */\n    xAxisIndex: PropTypes.arrayOf(PropTypes.number),\n\n    // Callback for when chart has been zoomed\n    onZoom: PropTypes.func,\n    // Callbacks for eCharts events\n    onRestore: PropTypes.func,\n    onChartReady: PropTypes.func,\n    onDataZoom: PropTypes.func,\n    onFinished: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n\n    // Zoom history\n    this.history = [];\n\n    // Initialize current period instance state for zoom history\n    this.saveCurrentPeriod(props);\n  }\n\n  componentDidUpdate() {\n    if (this.props.disabled) {\n      return;\n    }\n\n    // When component updates, make sure we sync current period state\n    // for use in zoom history\n    this.saveCurrentPeriod(this.props);\n  }\n\n  history: Period[];\n  currentPeriod?: Period;\n  zooming: (() => void) | null = null;\n\n  /**\n   * Save current period state from period in props to be used\n   * in handling chart's zoom history state\n   */\n  saveCurrentPeriod = props => {\n    this.currentPeriod = {\n      period: props.period,\n      start: getDate(props.start),\n      end: getDate(props.end),\n    };\n  };\n\n  /**\n   * Sets the new period due to a zoom related action\n   *\n   * Saves the current period to an instance property so that we\n   * can control URL state when zoom history is being manipulated\n   * by the chart controls.\n   *\n   * Saves a callback function to be called after chart animation is completed\n   */\n  setPeriod = ({period, start, end}, saveHistory = false) => {\n    const {router, onZoom} = this.props;\n    const startFormatted = getDate(start);\n    const endFormatted = getDate(end);\n\n    // Save period so that we can revert back to it when using echarts \"back\" navigation\n    if (saveHistory) {\n      this.history.push(this.currentPeriod!);\n    }\n\n    // Callback to let parent component know zoom has changed\n    // This is required for some more perceived responsiveness since\n    // we delay updating URL state so that chart animation can finish\n    //\n    // Parent container can use this to change into a loading state before\n    // URL parameters are changed\n    callIfFunction(onZoom, {\n      period,\n      start: startFormatted,\n      end: endFormatted,\n    });\n\n    this.zooming = () => {\n      updateDateTime(\n        {\n          period,\n          start: startFormatted\n            ? getUtcToLocalDateObject(startFormatted)\n            : startFormatted,\n          end: endFormatted ? getUtcToLocalDateObject(endFormatted) : endFormatted,\n        },\n        router\n      );\n\n      this.saveCurrentPeriod({period, start, end});\n    };\n  };\n\n  /**\n   * Enable zoom immediately instead of having to toggle to zoom\n   */\n  handleChartReady = chart => {\n    chart.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: true,\n    });\n\n    callIfFunction(this.props.onChartReady, chart);\n  };\n\n  /**\n   * Restores the chart to initial viewport/zoom level\n   *\n   * Updates URL state to reflect initial params\n   */\n  handleZoomRestore = (evt, chart) => {\n    if (!this.history.length) {\n      return;\n    }\n\n    this.setPeriod(this.history[0]);\n\n    // reset history\n    this.history = [];\n\n    callIfFunction(this.props.onRestore, evt, chart);\n  };\n\n  handleDataZoom = (evt, chart) => {\n    const model = chart.getModel();\n    const {xAxis} = model.option;\n    const axis = xAxis[0];\n\n    // if `rangeStart` and `rangeEnd` are null, then we are going back\n    if (axis.rangeStart === null && axis.rangeEnd === null) {\n      const previousPeriod = this.history.pop();\n\n      if (!previousPeriod) {\n        return;\n      }\n\n      this.setPeriod(previousPeriod);\n    } else {\n      const start = moment.utc(axis.rangeStart);\n\n      // Add a day so we go until the end of the day (e.g. next day at midnight)\n      const end = moment.utc(axis.rangeEnd);\n\n      this.setPeriod({period: null, start, end}, true);\n    }\n\n    callIfFunction(this.props.onDataZoom, evt, chart);\n  };\n\n  /**\n   * Chart event when *any* rendering+animation finishes\n   *\n   * `this.zooming` acts as a callback function so that\n   * we can let the native zoom animation on the chart complete\n   * before we update URL state and re-render\n   */\n  handleChartFinished = () => {\n    if (typeof this.zooming === 'function') {\n      this.zooming();\n      this.zooming = null;\n    }\n    callIfFunction(this.props.onFinished);\n  };\n\n  render() {\n    const {\n      utc: _utc,\n      start: _start,\n      end: _end,\n      disabled,\n      children,\n      xAxisIndex,\n\n      router: _router,\n      onZoom: _onZoom,\n      onRestore: _onRestore,\n      onChartReady: _onChartReady,\n      onDataZoom: _onDataZoom,\n      onFinished: _onFinished,\n      ...props\n    } = this.props;\n\n    const utc = _utc ?? undefined;\n    const start = _start ? getUtcToLocalDateObject(_start) : undefined;\n    const end = _end ? getUtcToLocalDateObject(_end) : undefined;\n\n    if (disabled) {\n      return children({\n        utc,\n        start,\n        end,\n        ...props,\n      });\n    }\n\n    const renderProps = {\n      // Zooming only works when grouped by date\n      isGroupedByDate: true,\n      onChartReady: this.handleChartReady,\n      utc,\n      start,\n      end,\n      dataZoom: DataZoomInside({xAxisIndex}),\n      showTimeInTooltip: true,\n      toolBox: ToolBox(\n        {},\n        {\n          dataZoom: {\n            title: {\n              zoom: '',\n              back: '',\n            },\n            iconStyle: {\n              borderWidth: 0,\n              color: 'transparent',\n              opacity: 0,\n            },\n          },\n        }\n      ),\n      onDataZoom: this.handleDataZoom,\n      onFinished: this.handleChartFinished,\n      onRestore: this.handleZoomRestore,\n      ...props,\n    };\n\n    return children(renderProps);\n  }\n}\n\nexport default ChartZoom;\n","import React from 'react';\n\nimport LoadingPanel from 'app/components/charts/loadingPanel';\n\nconst defaultProps = {\n  height: '200px',\n};\n\ntype Props = {\n  reloading: boolean;\n  loading: boolean;\n} & typeof defaultProps;\n\ntype State = {\n  prevReloading: boolean;\n  prevLoading: boolean;\n  key: number;\n};\n\nclass TransitionChart extends React.Component<Props, State> {\n  static defaultProps = defaultProps;\n\n  state = {\n    prevReloading: this.props.reloading,\n    prevLoading: this.props.loading,\n    key: 1,\n  };\n\n  static getDerivedStateFromProps(props: Props, state: State) {\n    // Transitions are controlled using variables called:\n    // - loading and,\n    // - reloading (also called pending in other apps)\n    //\n    // This component remounts the chart to ensure the stable transition\n    // from one data set to the next.\n\n    const prevReloading = state.prevReloading;\n    const nextReloading = props.reloading;\n\n    const prevLoading = state.prevLoading;\n    const nextLoading = props.loading;\n\n    // whenever loading changes, we explicitly remount the children by updating\n    // the key prop; regardless of what state reloading is in\n    if (prevLoading !== nextLoading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key + 1,\n      };\n    }\n\n    // invariant: prevLoading === nextLoading\n\n    // if loading is true, and hasn't changed from the previous re-render,\n    // do not remount the children.\n    if (nextLoading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key,\n      };\n    }\n\n    // invariant: loading is false\n\n    // whenever the chart is transitioning from the reloading (pending) state to a non-loading state,\n    // remount the children\n    if (prevReloading && !nextReloading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key + 1,\n      };\n    }\n\n    // do not remount the children in these remaining cases:\n    // !prevReloading && !nextReloading (re-render with no prop change)\n    // prevReloading && nextReloading (re-render with no prop change)\n    // !prevReloading && nextReloading (from loaded to pending state)\n\n    return {\n      prevReloading: nextReloading,\n      prevLoading: nextLoading,\n      key: state.key,\n    };\n  }\n\n  render() {\n    const {height, loading, reloading} = this.props;\n\n    if (loading && !reloading) {\n      return <LoadingPanel height={height} data-test-id=\"events-request-loading\" />;\n    }\n\n    // We make use of the key prop to explicitly remount the children\n    // https://reactjs.org/docs/lists-and-keys.html#keys\n    return (\n      <React.Fragment key={String(this.state.key)}>{this.props.children}</React.Fragment>\n    );\n  }\n}\n\nexport default TransitionChart;\n","import React from 'react';\nimport styled from '@emotion/styled';\n\nimport LoadingMask from 'app/components/loadingMask';\n\ntype Props = {\n  height?: string;\n} & React.HTMLProps<HTMLDivElement>;\n\nconst LoadingPanel = styled(({height: _height, ...props}: Props) => (\n  <div {...props}>\n    <LoadingMask />\n  </div>\n))`\n  flex: 1;\n  flex-shrink: 0;\n  overflow: hidden;\n  height: ${p => p.height};\n  position: relative;\n  border-color: transparent;\n  margin-bottom: 0;\n`;\n\nLoadingPanel.defaultProps = {\n  height: '200px',\n};\n\nexport default LoadingPanel;\n","import {LocationDescriptor} from 'history';\nimport pick from 'lodash/pick';\n\nimport {Client} from 'app/api';\nimport {canIncludePreviousPeriod} from 'app/components/charts/utils';\nimport {URL_PARAM} from 'app/constants/globalSelectionHeader';\nimport {\n  DateString,\n  EventsStats,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'app/types';\nimport {LocationQuery} from 'app/utils/discover/eventView';\nimport {getPeriod} from 'app/utils/getPeriod';\n\ntype Options = {\n  organization: OrganizationSummary;\n  project?: Readonly<number[]>;\n  environment?: Readonly<string[]>;\n  period?: string;\n  start?: DateString;\n  end?: DateString;\n  interval?: string;\n  includePrevious?: boolean;\n  limit?: number;\n  query?: string;\n  yAxis?: string | string[];\n  field?: string[];\n  topEvents?: number;\n  orderby?: string;\n};\n\n/**\n * Make requests to `events-stats` endpoint\n *\n * @param {Object} api API client instance\n * @param {Object} options Request parameters\n * @param {Object} options.organization Organization object\n * @param {Number[]} options.project List of project ids\n * @param {String[]} options.environment List of environments to query for\n * @param {String} options.period Time period to query for, in the format: <integer><units> where units are \"d\" or \"h\"\n * @param {String} options.interval Time interval to group results in, in the format: <integer><units> where units are \"d\", \"h\", \"m\", \"s\"\n * @param {Boolean} options.includePrevious Should request also return reqsults for previous period?\n * @param {Number} options.limit The number of rows to return\n * @param {String} options.query Search query\n */\nexport const doEventsRequest = (\n  api: Client,\n  {\n    organization,\n    project,\n    environment,\n    period,\n    start,\n    end,\n    interval,\n    includePrevious,\n    query,\n    yAxis,\n    field,\n    topEvents,\n    orderby,\n  }: Options\n): Promise<EventsStats | MultiSeriesEventsStats> => {\n  const shouldDoublePeriod = canIncludePreviousPeriod(includePrevious, period);\n  const urlQuery = Object.fromEntries(\n    Object.entries({\n      interval,\n      project,\n      environment,\n      query,\n      yAxis,\n      field,\n      topEvents,\n      orderby,\n    }).filter(([, value]) => typeof value !== 'undefined')\n  );\n\n  // Doubling period for absolute dates is not accurate unless starting and\n  // ending times are the same (at least for daily intervals). This is\n  // the tradeoff for now.\n  const periodObj = getPeriod({period, start, end}, {shouldDoublePeriod});\n\n  return api.requestPromise(`/organizations/${organization.slug}/events-stats/`, {\n    query: {\n      ...urlQuery,\n      ...periodObj,\n    },\n  });\n};\n\nexport type EventQuery = {\n  field: string[];\n  project?: string | string[];\n  sort?: string | string[];\n  query: string;\n  per_page?: number;\n  referrer?: string;\n  environment?: string[];\n  noPagination?: boolean;\n};\n\nexport type TagSegment = {\n  count: number;\n  name: string;\n  value: string;\n  url: LocationDescriptor;\n  isOther?: boolean;\n  key?: string;\n};\n\nexport type Tag = {\n  key: string;\n  topValues: Array<TagSegment>;\n};\n\n/**\n * Fetches tag facets for a query\n */\nexport async function fetchTagFacets(\n  api: Client,\n  orgSlug: string,\n  query: EventQuery\n): Promise<Tag[]> {\n  const urlParams = pick(query, Object.values(URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  return api.requestPromise(`/organizations/${orgSlug}/events-facets/`, {\n    query: queryOption,\n  });\n}\n\n/**\n * Fetches total count of events for a given query\n */\nexport async function fetchTotalCount(\n  api: Client,\n  orgSlug: String,\n  query: EventQuery & LocationQuery\n): Promise<number> {\n  const urlParams = pick(query, Object.values(URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  type Response = {\n    count: number;\n  };\n\n  return api\n    .requestPromise(`/organizations/${orgSlug}/events-meta/`, {\n      query: queryOption,\n    })\n    .then((res: Response) => res.count);\n}\n","import moment from 'moment';\n\nimport {DEFAULT_STATS_PERIOD} from 'app/constants';\nimport {getUtcDateString} from 'app/utils/dates';\n\ntype DateObject = {\n  /**\n   * Relative period string in format \"<int><unit>\" (e.g. 4d for 4 days)\n   */\n  period?: string;\n  /**\n   * Starting date object\n   */\n  start?: string | Date | null;\n  /**\n   * Ending date object\n   */\n  end?: string | Date | null;\n};\n\ntype Options = {\n  /**\n   * Doubles the given period (useful for getting previous period data)\n   */\n  shouldDoublePeriod?: boolean;\n};\n\n/**\n * Gets the period to query with if we need to double the initial period in order\n * to get data for the previous period\n *\n * Returns an object with either a period or start/end dates ({statsPeriod: string} or {start: string, end: string})\n */\nexport const getPeriod = (\n  {period, start, end}: DateObject,\n  {shouldDoublePeriod}: Options = {}\n) => {\n  if (!period && !start && !end) {\n    period = DEFAULT_STATS_PERIOD;\n  }\n\n  // you can not specify both relative and absolute periods\n  // relative period takes precedence\n  if (period) {\n    if (!shouldDoublePeriod) {\n      return {statsPeriod: period};\n    }\n    const [, periodNumber, periodLength] = period.match(/([0-9]+)([mhdw])/)!;\n\n    return {statsPeriod: `${parseInt(periodNumber, 10) * 2}${periodLength}`};\n  }\n\n  if (!start || !end) {\n    throw new Error('start and end required');\n  }\n\n  const formattedStart = getUtcDateString(start);\n  const formattedEnd = getUtcDateString(end);\n\n  if (shouldDoublePeriod) {\n    // get duration of end - start and double\n    const diff = moment(end).diff(moment(start));\n\n    const previousPeriodStart = moment(start).subtract(diff);\n\n    // This is not as accurate as having 2 start/end objs\n    return {\n      start: getUtcDateString(previousPeriodStart),\n      end: formattedEnd,\n    };\n  }\n\n  return {\n    start: formattedStart,\n    end: formattedEnd,\n  };\n};\n"],"sourceRoot":""}