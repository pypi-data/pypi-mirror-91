import collections
import concurrent.futures
import logging
import time
from datetime import timedelta

from concurrentevents._exceptions import Cancel, StartError, EventError, HandlerError
from concurrentevents.tools.threadmonitor import thread_monitoring

logger = logging.getLogger('concurrentevents')


class EventManager:
    def __init__(self, threads=0):
        """
        A bare bones event framework using concurrent futures for threading
        :param int threads: The number of threads, default to none for automatic calculation
        """
        if threads < -1 if isinstance(threads, int) else True:
            raise ValueError(f"EventManager threads argument must be a int greater than 0 not {threads}")

        # Main dictionary for all event functionality
        # Stores handlers mapped to events to allow for quick access to specific ordered functions
        # Outline:
        #   key: Event
        #   value: List of handler functions
        self.handlers = collections.defaultdict(list)

        # Futures Dictionary
        # This is a private dictionary used internally so that the main thread can manage and clean
        #   the running futures generated by the event system
        # Outline:
        #   key: Future Object
        #   value: (fn, args, kwargs)
        self.__futures = {}

        self.__thread_pool = concurrent.futures.ThreadPoolExecutor(max_workers=threads or None)

        # This boolean is set so that after firing the start event on the main thread there
        #   are no other instances of it that could be created and thus no duplicate cleaners
        self.started = False

        # Exit value which can either be None or an int representing timeout for threads on exit
        self.exit = None

    def add_handlers(self, *handlers):
        """
        Submits handlers into `EventManager` for organization and use
        :param handlers: A list of objects or functions that will be added to the handler dictionary
        """
        for h in handlers:
            try:
                for var in dir(h):
                    fn = getattr(h, var)
                    if callable(fn) and hasattr(fn, 'event'):
                        logger.debug(f"{var} is handling {fn.event}")
                        self.handlers[fn.event].append(fn)

                h.fire = lambda event, *args, **kwargs: self.fire(event, *args, **kwargs)
            except Exception as e:
                raise HandlerError(f"{fn} is not a valid handler {e}")

    def __handle(self, event, *args, **kwargs):
        if event in self.handlers.keys():
            handlers = sorted(self.handlers[event], key=lambda h: h.priority)
            logger.debug(f"{[h.__name__ for h in handlers]} handling {event}(args={args}, kwargs={kwargs})")

            try:
                for h in handlers:
                    h(*args, **kwargs)
            except Cancel:
                logger.debug(f"{event}(args={args}, kwargs={kwargs}) canceled")
            except SystemExit:
                logger.debug(f"{event}(args={args}, kwargs={kwargs}) raised SystemExit timeout")

    def _submit(self, f, *args, **kwargs):
        """
        Interacts with the threadpool and futures dictionary to organize and track events

        This is implemented as the only methodology to put a function into the threadpool because,
        it forces all futures generated by putting something in the threadpool to be added to the
        futures list

        :param `function` f: A function object
        :param `*args`: Arguments for f
        :param `**kwargs`: Keyword arguments for f
        """
        future = self.__thread_pool.submit(f, *args, **kwargs)
        self.__futures[future] = (f, args, kwargs)
        return future

    def fire(self, event, *args, **kwargs):
        """
        A filter method for events that checks to see if it needs to be sent to the Thread Pool

        The purpose of this function is to validate not modify anything that
        wanted to be fired as an event.
        This intermediary step helps to eliminate anything that gets fired but
        isn't an event and any events that don't have handlers

        :param str event: A string representing a set of handlers for an event

        :raises EventError: Raised for when a non event is passed into the event param
        :raises KeyError: Raised for when there no handlers for the event
        """
        if event == 'Start':
            raise EventError('Can not fire Start as it is automatically fired from EventManager')

        if event == 'Exit':
            if not self.exit:
                if isinstance(kwargs['timeout'], int) if 'timeout' in kwargs else False:
                    self.exit = int(kwargs['timeout'])
                    kwargs.pop('timeout')
                else:
                    self.exit = 300

        if event not in self.handlers.keys():
            raise KeyError(f"No Handlers For {event}")

        self._submit(self.__handle, event, *args, **kwargs)

    def start(self, timeout=10):
        """
        Starts the event sequence

        Fires the start event to trigger the beginning of all functionality
        After firing the start event the main while loop is started for debug
        and cleaning of completed futures

        :param int timeout: A timeout used for events running at exit

        """
        if 'Start' not in self.handlers.keys():
            raise StartError("EventManager can't start without handlers for the Start event")

        s = time.time()

        if self.started:
            raise StartError("EventManager is already running")
        self.started = True

        self._submit(self.__handle, 'Start')

        info = (len(self.__futures), sum(ft.running() for ft in self.__futures), thread_monitoring.__repr__())

        while not (self.exit or len(self.__futures) == 0):
            new_info = (len(self.__futures), sum(ft.running() for ft in self.__futures), thread_monitoring.__repr__())
            if new_info != info:
                logger.debug("Status (futures={}, running={}, monitored={})".format(*new_info))
                info = new_info

            for f, fn in self.__futures.copy().items():
                if f.done():
                    try:
                        f.result()
                    except concurrent.futures._base.CancelledError:
                        logger.debug(
                            f"{fn[0]}(args={fn[1]}, kwargs={fn[2]}) future canceled. This should not happen!")  # pragma: no cover
                    except:
                        logger.exception(fn)
                    self.__futures.pop(f)

            time.sleep(0.25)

        if self.exit is None:
            self._submit(self.__handle, 'Exit')
            self.exit = timeout

        concurrent.futures.wait(list(self.__futures.keys()), timeout=self.exit)

        logger.debug(f"Runtime {timedelta(seconds=time.time() - s)}")

        self.__thread_pool.shutdown()
