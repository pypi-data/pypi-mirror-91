# coding: utf-8

"""
    Algorithmia Management APIs

    APIs for managing actions on the Algorithmia platform  # noqa: E501

    The version of the OpenAPI document: 1.3.0
    Contact: support@algorithmia.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from algorithmia_api_client.api_client import ApiClient
from algorithmia_api_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_organization_api_key(self, org_name, username, api_key_creation, **kwargs):  # noqa: E501
        """Create an organization API key for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_organization_api_key(org_name, username, api_key_creation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param str username: The user's username (required)
        :param ApiKeyCreation api_key_creation: Create API Key Request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ApiKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_organization_api_key_with_http_info(org_name, username, api_key_creation, **kwargs)  # noqa: E501

    def add_organization_api_key_with_http_info(self, org_name, username, api_key_creation, **kwargs):  # noqa: E501
        """Create an organization API key for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_organization_api_key_with_http_info(org_name, username, api_key_creation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param str username: The user's username (required)
        :param ApiKeyCreation api_key_creation: Create API Key Request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ApiKey, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name',
            'username',
            'api_key_creation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_organization_api_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `add_organization_api_key`")  # noqa: E501
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `add_organization_api_key`")  # noqa: E501
        # verify the required parameter 'api_key_creation' is set
        if self.api_client.client_side_validation and ('api_key_creation' not in local_var_params or  # noqa: E501
                                                        local_var_params['api_key_creation'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `api_key_creation` when calling `add_organization_api_key`")  # noqa: E501

        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `add_organization_api_key`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `add_organization_api_key`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'api_key_creation' in local_var_params:
            body_params = local_var_params['api_key_creation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/organizations/{orgName}/members/{username}/keys', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_organization_member(self, org_name, username, **kwargs):  # noqa: E501
        """Add a user as a member of a given organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_organization_member(org_name, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param str username: The user's username (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_organization_member_with_http_info(org_name, username, **kwargs)  # noqa: E501

    def add_organization_member_with_http_info(self, org_name, username, **kwargs):  # noqa: E501
        """Add a user as a member of a given organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_organization_member_with_http_info(org_name, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param str username: The user's username (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_organization_member" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `add_organization_member`")  # noqa: E501
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `add_organization_member`")  # noqa: E501

        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `add_organization_member`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `add_organization_member`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/organizations/{orgName}/members/{username}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def algo_algorithm_id_algo_callable_version_post(self, algorithm_id, algo_callable_version, body, **kwargs):  # noqa: E501
        """Invoke Algorithm via immutable identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.algo_algorithm_id_algo_callable_version_post(algorithm_id, algo_callable_version, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param str algo_callable_version: The specific version of the algorithm you wish to call. May be left blank, in which case the latest publicly published version will be used. Examples: - `latestPrivate`: Resolves to the latest version you have published privately. - `06147a5f7726757845d04d5b24b6e2b1c797fc74`: Resolves to a specific hash version of your algorithm. Useful for testing a specific algorithm build. - `1.1.1`: Fully specified semantic version. - `1.2.*`: Specified to the minor level. Will resolve to the latest publicly published version with a minor version of 1.2 - `1.*`: Specified to a major version. Will resolve to the latest publicly published version with major version 1  (required)
        :param str body: (required)
        :param float timeout: Specifies the amount of time in seconds to wait for the algorithm to respond before returning an error. Defaults to 300 (5 min.)
        :param bool stdout: Specifies whether data passed to `stdout` during invocation should be returned to the caller. This parameter is only respected when the caller is the algorithm author.
        :param str output: Allows customization of the response. `raw` signfies that you wish the algorithm's response to be returned to you without a JSON wrapper, while `void` signifies that you do not wish to wait for an algorithm response. In the latter case, the call will return immediately once the invocation has begun.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneOfAlgorithmAsynchronousInvocationResultAlgorithmSynchronousInvocationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.algo_algorithm_id_algo_callable_version_post_with_http_info(algorithm_id, algo_callable_version, body, **kwargs)  # noqa: E501

    def algo_algorithm_id_algo_callable_version_post_with_http_info(self, algorithm_id, algo_callable_version, body, **kwargs):  # noqa: E501
        """Invoke Algorithm via immutable identifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.algo_algorithm_id_algo_callable_version_post_with_http_info(algorithm_id, algo_callable_version, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param str algo_callable_version: The specific version of the algorithm you wish to call. May be left blank, in which case the latest publicly published version will be used. Examples: - `latestPrivate`: Resolves to the latest version you have published privately. - `06147a5f7726757845d04d5b24b6e2b1c797fc74`: Resolves to a specific hash version of your algorithm. Useful for testing a specific algorithm build. - `1.1.1`: Fully specified semantic version. - `1.2.*`: Specified to the minor level. Will resolve to the latest publicly published version with a minor version of 1.2 - `1.*`: Specified to a major version. Will resolve to the latest publicly published version with major version 1  (required)
        :param str body: (required)
        :param float timeout: Specifies the amount of time in seconds to wait for the algorithm to respond before returning an error. Defaults to 300 (5 min.)
        :param bool stdout: Specifies whether data passed to `stdout` during invocation should be returned to the caller. This parameter is only respected when the caller is the algorithm author.
        :param str output: Allows customization of the response. `raw` signfies that you wish the algorithm's response to be returned to you without a JSON wrapper, while `void` signifies that you do not wish to wait for an algorithm response. In the latter case, the call will return immediately once the invocation has begun.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneOfAlgorithmAsynchronousInvocationResultAlgorithmSynchronousInvocationResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'algorithm_id',
            'algo_callable_version',
            'body',
            'timeout',
            'stdout',
            'output'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method algo_algorithm_id_algo_callable_version_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'algorithm_id' is set
        if self.api_client.client_side_validation and ('algorithm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['algorithm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algorithm_id` when calling `algo_algorithm_id_algo_callable_version_post`")  # noqa: E501
        # verify the required parameter 'algo_callable_version' is set
        if self.api_client.client_side_validation and ('algo_callable_version' not in local_var_params or  # noqa: E501
                                                        local_var_params['algo_callable_version'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algo_callable_version` when calling `algo_algorithm_id_algo_callable_version_post`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `algo_algorithm_id_algo_callable_version_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'algorithm_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['algorithm_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algorithm_id` when calling `algo_algorithm_id_algo_callable_version_post`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'algo_callable_version' in local_var_params and not re.search(r'(^$|latestPrivate|^[a-z0-9]?$|^\d(\.(\d+|\*))?(\.(\d+|\*))?$)', local_var_params['algo_callable_version']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algo_callable_version` when calling `algo_algorithm_id_algo_callable_version_post`, must conform to the pattern `/(^$|latestPrivate|^[a-z0-9]?$|^\d(\.(\d+|\*))?(\.(\d+|\*))?$)/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'algorithm_id' in local_var_params:
            path_params['algorithmId'] = local_var_params['algorithm_id']  # noqa: E501
        if 'algo_callable_version' in local_var_params:
            path_params['algoCallableVersion'] = local_var_params['algo_callable_version']  # noqa: E501

        query_params = []
        if 'timeout' in local_var_params and local_var_params['timeout'] is not None:  # noqa: E501
            query_params.append(('timeout', local_var_params['timeout']))  # noqa: E501
        if 'stdout' in local_var_params and local_var_params['stdout'] is not None:  # noqa: E501
            query_params.append(('stdout', local_var_params['stdout']))  # noqa: E501
        if 'output' in local_var_params and local_var_params['output'] is not None:  # noqa: E501
            query_params.append(('output', local_var_params['output']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/text', 'application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algo/{algorithmId}/{algoCallableVersion}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneOfAlgorithmAsynchronousInvocationResultAlgorithmSynchronousInvocationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def algo_username_algoname_algo_callable_version_post(self, username, algoname, algo_callable_version, body, **kwargs):  # noqa: E501
        """Invoke Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.algo_username_algoname_algo_callable_version_post(username, algoname, algo_callable_version, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param str algo_callable_version: The specific version of the algorithm you wish to call. May be left blank, in which case the latest publicly published version will be used. Examples: - `latestPrivate`: Resolves to the latest version you have published privately. - `06147a5f7726757845d04d5b24b6e2b1c797fc74`: Resolves to a specific hash version of your algorithm. Useful for testing a specific algorithm build. - `1.1.1`: Fully specified semantic version. - `1.2.*`: Specified to the minor level. Will resolve to the latest publicly published version with a minor version of 1.2 - `1.*`: Specified to a major version. Will resolve to the latest publicly published version with major version 1  (required)
        :param str body: (required)
        :param float timeout: Specifies the amount of time in seconds to wait for the algorithm to respond before returning an error. Defaults to 300 (5 min.)
        :param bool stdout: Specifies whether data passed to `stdout` during invocation should be returned to the caller. This parameter is only respected when the caller is the algorithm author.
        :param str output: Allows customization of the response. `raw` signfies that you wish the algorithm's response to be returned to you without a JSON wrapper, while `void` signifies that you do not wish to wait for an algorithm response. In the latter case, the call will return immediately once the invocation has begun.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OneOfAlgorithmAsynchronousInvocationResultAlgorithmSynchronousInvocationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.algo_username_algoname_algo_callable_version_post_with_http_info(username, algoname, algo_callable_version, body, **kwargs)  # noqa: E501

    def algo_username_algoname_algo_callable_version_post_with_http_info(self, username, algoname, algo_callable_version, body, **kwargs):  # noqa: E501
        """Invoke Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.algo_username_algoname_algo_callable_version_post_with_http_info(username, algoname, algo_callable_version, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param str algo_callable_version: The specific version of the algorithm you wish to call. May be left blank, in which case the latest publicly published version will be used. Examples: - `latestPrivate`: Resolves to the latest version you have published privately. - `06147a5f7726757845d04d5b24b6e2b1c797fc74`: Resolves to a specific hash version of your algorithm. Useful for testing a specific algorithm build. - `1.1.1`: Fully specified semantic version. - `1.2.*`: Specified to the minor level. Will resolve to the latest publicly published version with a minor version of 1.2 - `1.*`: Specified to a major version. Will resolve to the latest publicly published version with major version 1  (required)
        :param str body: (required)
        :param float timeout: Specifies the amount of time in seconds to wait for the algorithm to respond before returning an error. Defaults to 300 (5 min.)
        :param bool stdout: Specifies whether data passed to `stdout` during invocation should be returned to the caller. This parameter is only respected when the caller is the algorithm author.
        :param str output: Allows customization of the response. `raw` signfies that you wish the algorithm's response to be returned to you without a JSON wrapper, while `void` signifies that you do not wish to wait for an algorithm response. In the latter case, the call will return immediately once the invocation has begun.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OneOfAlgorithmAsynchronousInvocationResultAlgorithmSynchronousInvocationResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname',
            'algo_callable_version',
            'body',
            'timeout',
            'stdout',
            'output'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method algo_username_algoname_algo_callable_version_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `algo_username_algoname_algo_callable_version_post`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `algo_username_algoname_algo_callable_version_post`")  # noqa: E501
        # verify the required parameter 'algo_callable_version' is set
        if self.api_client.client_side_validation and ('algo_callable_version' not in local_var_params or  # noqa: E501
                                                        local_var_params['algo_callable_version'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algo_callable_version` when calling `algo_username_algoname_algo_callable_version_post`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `algo_username_algoname_algo_callable_version_post`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `algo_username_algoname_algo_callable_version_post`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'algo_callable_version' in local_var_params and not re.search(r'(^$|latestPrivate|^[a-z0-9]?$|^\d(\.(\d+|\*))?(\.(\d+|\*))?$)', local_var_params['algo_callable_version']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algo_callable_version` when calling `algo_username_algoname_algo_callable_version_post`, must conform to the pattern `/(^$|latestPrivate|^[a-z0-9]?$|^\d(\.(\d+|\*))?(\.(\d+|\*))?$)/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501
        if 'algo_callable_version' in local_var_params:
            path_params['algoCallableVersion'] = local_var_params['algo_callable_version']  # noqa: E501

        query_params = []
        if 'timeout' in local_var_params and local_var_params['timeout'] is not None:  # noqa: E501
            query_params.append(('timeout', local_var_params['timeout']))  # noqa: E501
        if 'stdout' in local_var_params and local_var_params['stdout'] is not None:  # noqa: E501
            query_params.append(('stdout', local_var_params['stdout']))  # noqa: E501
        if 'output' in local_var_params and local_var_params['output'] is not None:  # noqa: E501
            query_params.append(('output', local_var_params['output']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/text', 'application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algo/{username}/{algoname}/{algoCallableVersion}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OneOfAlgorithmAsynchronousInvocationResultAlgorithmSynchronousInvocationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def commit_log_for_repository(self, username, algoname, **kwargs):  # noqa: E501
        """Gets the list of commits for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.commit_log_for_repository(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param str since: The first commit SHA of the repository to list in the commits. This is included in the result list.
        :param str until: The last commit SHA of the repository to list in the commits. This is included in the result list.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RepositoryCommitLog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.commit_log_for_repository_with_http_info(username, algoname, **kwargs)  # noqa: E501

    def commit_log_for_repository_with_http_info(self, username, algoname, **kwargs):  # noqa: E501
        """Gets the list of commits for a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.commit_log_for_repository_with_http_info(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param str since: The first commit SHA of the repository to list in the commits. This is included in the result list.
        :param str until: The last commit SHA of the repository to list in the commits. This is included in the result list.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RepositoryCommitLog, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname',
            'since',
            'until'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method commit_log_for_repository" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `commit_log_for_repository`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `commit_log_for_repository`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `commit_log_for_repository`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []
        if 'since' in local_var_params and local_var_params['since'] is not None:  # noqa: E501
            query_params.append(('since', local_var_params['since']))  # noqa: E501
        if 'until' in local_var_params and local_var_params['until'] is not None:  # noqa: E501
            query_params.append(('until', local_var_params['until']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}/log', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepositoryCommitLog',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def compile_algorithm(self, username, algoname, **kwargs):  # noqa: E501
        """Compile algorithm  # noqa: E501

        Compiles the latest available source code for an algorithm, resulting in a new hash version of an algorithm available for publishing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.compile_algorithm(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VersionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.compile_algorithm_with_http_info(username, algoname, **kwargs)  # noqa: E501

    def compile_algorithm_with_http_info(self, username, algoname, **kwargs):  # noqa: E501
        """Compile algorithm  # noqa: E501

        Compiles the latest available source code for an algorithm, resulting in a new hash version of an algorithm available for publishing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.compile_algorithm_with_http_info(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VersionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method compile_algorithm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `compile_algorithm`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `compile_algorithm`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `compile_algorithm`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}/compile', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VersionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def compile_algorithm_by_id(self, algorithm_id, **kwargs):  # noqa: E501
        """Compile algorithm  # noqa: E501

        Compiles the latest available source code for an algorithm, resulting in a new hash version of an algorithm available for publishing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.compile_algorithm_by_id(algorithm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VersionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.compile_algorithm_by_id_with_http_info(algorithm_id, **kwargs)  # noqa: E501

    def compile_algorithm_by_id_with_http_info(self, algorithm_id, **kwargs):  # noqa: E501
        """Compile algorithm  # noqa: E501

        Compiles the latest available source code for an algorithm, resulting in a new hash version of an algorithm available for publishing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.compile_algorithm_by_id_with_http_info(algorithm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VersionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'algorithm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method compile_algorithm_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'algorithm_id' is set
        if self.api_client.client_side_validation and ('algorithm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['algorithm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algorithm_id` when calling `compile_algorithm_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'algorithm_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['algorithm_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algorithm_id` when calling `compile_algorithm_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'algorithm_id' in local_var_params:
            path_params['algorithmId'] = local_var_params['algorithm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmId}/compile', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VersionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def complete_scm_authorization(self, code, scm_id, **kwargs):  # noqa: E501
        """Complete SCM Authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. Once a user has successfully authorized with the SCM's authorization server, said server will call this endpoint and supply the authorization code as a query parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.complete_scm_authorization(code, scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str code: OAuth authorization code which we will be exchanged for an access token. (required)
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.complete_scm_authorization_with_http_info(code, scm_id, **kwargs)  # noqa: E501

    def complete_scm_authorization_with_http_info(self, code, scm_id, **kwargs):  # noqa: E501
        """Complete SCM Authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. Once a user has successfully authorized with the SCM's authorization server, said server will call this endpoint and supply the authorization code as a query parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.complete_scm_authorization_with_http_info(code, scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str code: OAuth authorization code which we will be exchanged for an access token. (required)
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'code',
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method complete_scm_authorization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'code' is set
        if self.api_client.client_side_validation and ('code' not in local_var_params or  # noqa: E501
                                                        local_var_params['code'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `code` when calling `complete_scm_authorization`")  # noqa: E501
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `complete_scm_authorization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []
        if 'code' in local_var_params and local_var_params['code'] is not None:  # noqa: E501
            query_params.append(('code', local_var_params['code']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scms/{scmId}/oauth/finish', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def connector_connector_id_connector_path_delete(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Delete Directory or File  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connector_connector_id_connector_path_delete(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param bool force: If you pass `true` for this parameter, will delete the directory even if it contains files.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.connector_connector_id_connector_path_delete_with_http_info(connector_id, connector_path, **kwargs)  # noqa: E501

    def connector_connector_id_connector_path_delete_with_http_info(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Delete Directory or File  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.connector_connector_id_connector_path_delete_with_http_info(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param bool force: If you pass `true` for this parameter, will delete the directory even if it contains files.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2001, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connector_id',
            'connector_path',
            'force'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connector_connector_id_connector_path_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connector_id' is set
        if self.api_client.client_side_validation and ('connector_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_id` when calling `connector_connector_id_connector_path_delete`")  # noqa: E501
        # verify the required parameter 'connector_path' is set
        if self.api_client.client_side_validation and ('connector_path' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_path` when calling `connector_connector_id_connector_path_delete`")  # noqa: E501

        if self.api_client.client_side_validation and 'connector_id' in local_var_params and not re.search(r'^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$', local_var_params['connector_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_id` when calling `connector_connector_id_connector_path_delete`, must conform to the pattern `/^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'connector_path' in local_var_params and not re.search(r'^([^\/]+\/?)*$', local_var_params['connector_path']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_path` when calling `connector_connector_id_connector_path_delete`, must conform to the pattern `/^([^\/]+\/?)*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'connector_id' in local_var_params:
            path_params['connectorId'] = local_var_params['connector_id']  # noqa: E501
        if 'connector_path' in local_var_params:
            path_params['connectorPath'] = local_var_params['connector_path']  # noqa: E501

        query_params = []
        if 'force' in local_var_params and local_var_params['force'] is not None:  # noqa: E501
            query_params.append(('force', local_var_params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/connector/{connectorId}/{connectorPath}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create(self, organization_type, **kwargs):  # noqa: E501
        """Create an OrganizationType  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create(organization_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OrganizationType organization_type: Request with OrganizationType (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OrganizationType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_with_http_info(organization_type, **kwargs)  # noqa: E501

    def create_with_http_info(self, organization_type, **kwargs):  # noqa: E501
        """Create an OrganizationType  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_with_http_info(organization_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param OrganizationType organization_type: Request with OrganizationType (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OrganizationType, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_type' is set
        if self.api_client.client_side_validation and ('organization_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_type` when calling `create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_type' in local_var_params:
            body_params = local_var_params['organization_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/organization/types', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_algorithm(self, username, create_request, **kwargs):  # noqa: E501
        """Create Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_algorithm(username, create_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param CreateRequest create_request: Algorithm Create Request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HashResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_algorithm_with_http_info(username, create_request, **kwargs)  # noqa: E501

    def create_algorithm_with_http_info(self, username, create_request, **kwargs):  # noqa: E501
        """Create Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_algorithm_with_http_info(username, create_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param CreateRequest create_request: Algorithm Create Request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HashResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'create_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_algorithm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `create_algorithm`")  # noqa: E501
        # verify the required parameter 'create_request' is set
        if self.api_client.client_side_validation and ('create_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['create_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `create_request` when calling `create_algorithm`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `create_algorithm`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_request' in local_var_params:
            body_params = local_var_params['create_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HashResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_directory(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Create Directory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_directory(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_directory_with_http_info(connector_id, connector_path, **kwargs)  # noqa: E501

    def create_directory_with_http_info(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Create Directory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_directory_with_http_info(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connector_id',
            'connector_path',
            'unknown_base_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_directory" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connector_id' is set
        if self.api_client.client_side_validation and ('connector_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_id` when calling `create_directory`")  # noqa: E501
        # verify the required parameter 'connector_path' is set
        if self.api_client.client_side_validation and ('connector_path' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_path` when calling `create_directory`")  # noqa: E501

        if self.api_client.client_side_validation and 'connector_id' in local_var_params and not re.search(r'^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$', local_var_params['connector_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_id` when calling `create_directory`, must conform to the pattern `/^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'connector_path' in local_var_params and not re.search(r'^([^\/]+\/?)*$', local_var_params['connector_path']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_path` when calling `create_directory`, must conform to the pattern `/^([^\/]+\/?)*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'connector_id' in local_var_params:
            path_params['connectorId'] = local_var_params['connector_id']  # noqa: E501
        if 'connector_path' in local_var_params:
            path_params['connectorPath'] = local_var_params['connector_path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/connector/{connectorId}/{connectorPath}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_key_for_organization(self, org_name, organization_api_key_creation, **kwargs):  # noqa: E501
        """Create an AlgorithmKey for an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_key_for_organization(org_name, organization_api_key_creation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param OrganizationApiKeyCreation organization_api_key_creation: Create API Key for an Organization Request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ApiKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_key_for_organization_with_http_info(org_name, organization_api_key_creation, **kwargs)  # noqa: E501

    def create_key_for_organization_with_http_info(self, org_name, organization_api_key_creation, **kwargs):  # noqa: E501
        """Create an AlgorithmKey for an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_key_for_organization_with_http_info(org_name, organization_api_key_creation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param OrganizationApiKeyCreation organization_api_key_creation: Create API Key for an Organization Request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ApiKey, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name',
            'organization_api_key_creation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_key_for_organization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `create_key_for_organization`")  # noqa: E501
        # verify the required parameter 'organization_api_key_creation' is set
        if self.api_client.client_side_validation and ('organization_api_key_creation' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization_api_key_creation'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_api_key_creation` when calling `create_key_for_organization`")  # noqa: E501

        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `create_key_for_organization`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_api_key_creation' in local_var_params:
            body_params = local_var_params['organization_api_key_creation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/organizations/{orgName}/keys', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_key_for_user(self, username, api_key_creation, **kwargs):  # noqa: E501
        """Create an API key for a given user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_key_for_user(username, api_key_creation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param ApiKeyCreation api_key_creation: Create API Key Request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ApiKey
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_key_for_user_with_http_info(username, api_key_creation, **kwargs)  # noqa: E501

    def create_key_for_user_with_http_info(self, username, api_key_creation, **kwargs):  # noqa: E501
        """Create an API key for a given user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_key_for_user_with_http_info(username, api_key_creation, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param ApiKeyCreation api_key_creation: Create API Key Request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ApiKey, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'api_key_creation'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_key_for_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `create_key_for_user`")  # noqa: E501
        # verify the required parameter 'api_key_creation' is set
        if self.api_client.client_side_validation and ('api_key_creation' not in local_var_params or  # noqa: E501
                                                        local_var_params['api_key_creation'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `api_key_creation` when calling `create_key_for_user`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `create_key_for_user`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'api_key_creation' in local_var_params:
            body_params = local_var_params['api_key_creation']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{username}/keys', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApiKey',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_organization(self, organization, **kwargs):  # noqa: E501
        """Creates an Organization owned by the caller  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_organization(organization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Organization organization: Request with Organization (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Organization
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_organization_with_http_info(organization, **kwargs)  # noqa: E501

    def create_organization_with_http_info(self, organization, **kwargs):  # noqa: E501
        """Creates an Organization owned by the caller  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_organization_with_http_info(organization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Organization organization: Request with Organization (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Organization, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'organization'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_organization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization' is set
        if self.api_client.client_side_validation and ('organization' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization` when calling `create_organization`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization' in local_var_params:
            body_params = local_var_params['organization']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/organizations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Organization',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_scm(self, scm, **kwargs):  # noqa: E501
        """Create an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_scm(scm, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Scm scm: Attempting to create an SCM of the type `internal` will return an `ScmDisallowedOperationError`, as this is a special class of SCM leveraged by Algorithmia directly. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Scm
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_scm_with_http_info(scm, **kwargs)  # noqa: E501

    def create_scm_with_http_info(self, scm, **kwargs):  # noqa: E501
        """Create an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_scm_with_http_info(scm, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Scm scm: Attempting to create an SCM of the type `internal` will return an `ScmDisallowedOperationError`, as this is a special class of SCM leveraged by Algorithmia directly. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Scm, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm' is set
        if self.api_client.client_side_validation and ('scm' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm` when calling `create_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'scm' in local_var_params:
            body_params = local_var_params['scm']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/scms', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Scm',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_user(self, user, **kwargs):  # noqa: E501
        """Creates an Algorithmia user in the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param User user: Request with User (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_user_with_http_info(user, **kwargs)  # noqa: E501

    def create_user_with_http_info(self, user, **kwargs):  # noqa: E501
        """Creates an Algorithmia user in the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_user_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param User user: Request with User (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in local_var_params or  # noqa: E501
                                                        local_var_params['user'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user` when calling `create_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in local_var_params:
            body_params = local_var_params['user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_algorithm(self, username, algoname, **kwargs):  # noqa: E501
        """Delete Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_algorithm(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_algorithm_with_http_info(username, algoname, **kwargs)  # noqa: E501

    def delete_algorithm_with_http_info(self, username, algoname, **kwargs):  # noqa: E501
        """Delete Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_algorithm_with_http_info(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_algorithm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `delete_algorithm`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `delete_algorithm`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `delete_algorithm`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_by_name(self, org_type_name, **kwargs):  # noqa: E501
        """Remove an organization type by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_by_name(org_type_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_type_name: Organization Type name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_by_name_with_http_info(org_type_name, **kwargs)  # noqa: E501

    def delete_by_name_with_http_info(self, org_type_name, **kwargs):  # noqa: E501
        """Remove an organization type by name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_by_name_with_http_info(org_type_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_type_name: Organization Type name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_type_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_by_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_type_name' is set
        if self.api_client.client_side_validation and ('org_type_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_type_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_type_name` when calling `delete_by_name`")  # noqa: E501

        if self.api_client.client_side_validation and 'org_type_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_type_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_type_name` when calling `delete_by_name`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_type_name' in local_var_params:
            path_params['orgTypeName'] = local_var_params['org_type_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/organization/types/{orgTypeName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_entry(self, keyname, **kwargs):  # noqa: E501
        """Delete a config entry represented by the provided keyname  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_entry(keyname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str keyname: The keyname for the config map entry (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_config_entry_with_http_info(keyname, **kwargs)  # noqa: E501

    def delete_config_entry_with_http_info(self, keyname, **kwargs):  # noqa: E501
        """Delete a config entry represented by the provided keyname  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_entry_with_http_info(keyname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str keyname: The keyname for the config map entry (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'keyname'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_entry" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'keyname' is set
        if self.api_client.client_side_validation and ('keyname' not in local_var_params or  # noqa: E501
                                                        local_var_params['keyname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `keyname` when calling `delete_config_entry`")  # noqa: E501

        if self.api_client.client_side_validation and ('keyname' in local_var_params and  # noqa: E501
                                                        len(local_var_params['keyname']) > 64):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `keyname` when calling `delete_config_entry`, length must be less than or equal to `64`")  # noqa: E501
        if self.api_client.client_side_validation and 'keyname' in local_var_params and not re.search(r'^[\w][\w-.]*[\w]$', local_var_params['keyname']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `keyname` when calling `delete_config_entry`, must conform to the pattern `/^[\w][\w-.]*[\w]$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'keyname' in local_var_params:
            path_params['keyname'] = local_var_params['keyname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/config/frontend/{keyname}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_event_listener_for_user_by_id(self, user_id, event_listener_id, **kwargs):  # noqa: E501
        """Delete an event listener  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_event_listener_for_user_by_id(user_id, event_listener_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param str event_listener_id: The ID of an event listener (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_event_listener_for_user_by_id_with_http_info(user_id, event_listener_id, **kwargs)  # noqa: E501

    def delete_event_listener_for_user_by_id_with_http_info(self, user_id, event_listener_id, **kwargs):  # noqa: E501
        """Delete an event listener  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_event_listener_for_user_by_id_with_http_info(user_id, event_listener_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param str event_listener_id: The ID of an event listener (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id',
            'event_listener_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_event_listener_for_user_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `delete_event_listener_for_user_by_id`")  # noqa: E501
        # verify the required parameter 'event_listener_id' is set
        if self.api_client.client_side_validation and ('event_listener_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['event_listener_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `event_listener_id` when calling `delete_event_listener_for_user_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'user_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['user_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `user_id` when calling `delete_event_listener_for_user_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'event_listener_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['event_listener_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `event_listener_id` when calling `delete_event_listener_for_user_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501
        if 'event_listener_id' in local_var_params:
            path_params['eventListenerId'] = local_var_params['event_listener_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/event-listeners/{eventListenerId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_favicon(self, **kwargs):  # noqa: E501
        """Delete favicon for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_favicon(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_favicon_with_http_info(**kwargs)  # noqa: E501

    def delete_favicon_with_http_info(self, **kwargs):  # noqa: E501
        """Delete favicon for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_favicon_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_favicon" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/config/favicon', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_logo(self, **kwargs):  # noqa: E501
        """Delete logo for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_logo(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_logo_with_http_info(**kwargs)  # noqa: E501

    def delete_logo_with_http_info(self, **kwargs):  # noqa: E501
        """Delete logo for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_logo_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_logo" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/config/logo', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_organization(self, org_name, **kwargs):  # noqa: E501
        """Delete an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_organization(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_organization_with_http_info(org_name, **kwargs)  # noqa: E501

    def delete_organization_with_http_info(self, org_name, **kwargs):  # noqa: E501
        """Delete an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_organization_with_http_info(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_organization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `delete_organization`")  # noqa: E501

        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `delete_organization`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/organizations/{orgName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_scm(self, scm_id, **kwargs):  # noqa: E501
        """Delete an SCM  # noqa: E501

        Note that at least one SCM must be enabled at any given time. If the SCM is currently enabled, is being used by an algorithm, or is an \"internal\" SCM, this call will fail and an appropriate error code will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_scm(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_scm_with_http_info(scm_id, **kwargs)  # noqa: E501

    def delete_scm_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Delete an SCM  # noqa: E501

        Note that at least one SCM must be enabled at any given time. If the SCM is currently enabled, is being used by an algorithm, or is an \"internal\" SCM, this call will fail and an appropriate error code will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_scm_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `delete_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/scms/{scmId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user(self, username, **kwargs):  # noqa: E501
        """Delete a user represented by the provided username  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_user_with_http_info(username, **kwargs)  # noqa: E501

    def delete_user_with_http_info(self, username, **kwargs):  # noqa: E501
        """Delete a user represented by the provided username  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_with_http_info(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `delete_user`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `delete_user`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{username}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_by_id(self, user_id, **kwargs):  # noqa: E501
        """Delete a user represented by the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_by_id(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_user_by_id_with_http_info(user_id, **kwargs)  # noqa: E501

    def delete_user_by_id_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete a user represented by the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_by_id_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `delete_user_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'user_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['user_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `user_id` when calling `delete_user_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit(self, org_name, organization, **kwargs):  # noqa: E501
        """edit  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit(org_name, organization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param Organization organization: Request with Organization (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.edit_with_http_info(org_name, organization, **kwargs)  # noqa: E501

    def edit_with_http_info(self, org_name, organization, **kwargs):  # noqa: E501
        """edit  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_with_http_info(org_name, organization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param Organization organization: Request with Organization (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name',
            'organization'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `edit`")  # noqa: E501
        # verify the required parameter 'organization' is set
        if self.api_client.client_side_validation and ('organization' not in local_var_params or  # noqa: E501
                                                        local_var_params['organization'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization` when calling `edit`")  # noqa: E501

        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `edit`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization' in local_var_params:
            body_params = local_var_params['organization']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/organizations/{orgName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm(self, username, algoname, **kwargs):  # noqa: E501
        """Get Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VersionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_with_http_info(username, algoname, **kwargs)  # noqa: E501

    def get_algorithm_with_http_info(self, username, algoname, **kwargs):  # noqa: E501
        """Get Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_with_http_info(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VersionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `get_algorithm`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `get_algorithm`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `get_algorithm`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VersionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_build_by_id(self, username, algoname, buildid, **kwargs):  # noqa: E501
        """Get individual algorithm build by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_build_by_id(username, algoname, buildid, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param str buildid: Build ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Build
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_build_by_id_with_http_info(username, algoname, buildid, **kwargs)  # noqa: E501

    def get_algorithm_build_by_id_with_http_info(self, username, algoname, buildid, **kwargs):  # noqa: E501
        """Get individual algorithm build by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_build_by_id_with_http_info(username, algoname, buildid, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param str buildid: Build ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Build, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname',
            'buildid'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_build_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `get_algorithm_build_by_id`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `get_algorithm_build_by_id`")  # noqa: E501
        # verify the required parameter 'buildid' is set
        if self.api_client.client_side_validation and ('buildid' not in local_var_params or  # noqa: E501
                                                        local_var_params['buildid'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `buildid` when calling `get_algorithm_build_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `get_algorithm_build_by_id`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501
        if 'buildid' in local_var_params:
            path_params['buildid'] = local_var_params['buildid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}/builds/{buildid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Build',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_build_logs(self, username, algoname, buildid, **kwargs):  # noqa: E501
        """Get Algorithm build logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_build_logs(username, algoname, buildid, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param str buildid: Build ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BuildLogs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_build_logs_with_http_info(username, algoname, buildid, **kwargs)  # noqa: E501

    def get_algorithm_build_logs_with_http_info(self, username, algoname, buildid, **kwargs):  # noqa: E501
        """Get Algorithm build logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_build_logs_with_http_info(username, algoname, buildid, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param str buildid: Build ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BuildLogs, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname',
            'buildid'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_build_logs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `get_algorithm_build_logs`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `get_algorithm_build_logs`")  # noqa: E501
        # verify the required parameter 'buildid' is set
        if self.api_client.client_side_validation and ('buildid' not in local_var_params or  # noqa: E501
                                                        local_var_params['buildid'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `buildid` when calling `get_algorithm_build_logs`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `get_algorithm_build_logs`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501
        if 'buildid' in local_var_params:
            path_params['buildid'] = local_var_params['buildid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}/builds/{buildid}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BuildLogs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_builds(self, username, algoname, **kwargs):  # noqa: E501
        """Get Algorithm builds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_builds(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PagedBuildsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_builds_with_http_info(username, algoname, **kwargs)  # noqa: E501

    def get_algorithm_builds_with_http_info(self, username, algoname, **kwargs):  # noqa: E501
        """Get Algorithm builds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_builds_with_http_info(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PagedBuildsList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname',
            'limit',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_builds" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `get_algorithm_builds`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `get_algorithm_builds`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `get_algorithm_builds`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}/builds', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedBuildsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_by_id(self, algorithm_id, **kwargs):  # noqa: E501
        """Get Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_by_id(algorithm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VersionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_by_id_with_http_info(algorithm_id, **kwargs)  # noqa: E501

    def get_algorithm_by_id_with_http_info(self, algorithm_id, **kwargs):  # noqa: E501
        """Get Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_by_id_with_http_info(algorithm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VersionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'algorithm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'algorithm_id' is set
        if self.api_client.client_side_validation and ('algorithm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['algorithm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algorithm_id` when calling `get_algorithm_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'algorithm_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['algorithm_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algorithm_id` when calling `get_algorithm_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'algorithm_id' in local_var_params:
            path_params['algorithmId'] = local_var_params['algorithm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VersionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_by_id_build_by_id(self, algorithm_id, buildid, **kwargs):  # noqa: E501
        """Get individual algorithm build by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_by_id_build_by_id(algorithm_id, buildid, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param str buildid: Build ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Build
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_by_id_build_by_id_with_http_info(algorithm_id, buildid, **kwargs)  # noqa: E501

    def get_algorithm_by_id_build_by_id_with_http_info(self, algorithm_id, buildid, **kwargs):  # noqa: E501
        """Get individual algorithm build by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_by_id_build_by_id_with_http_info(algorithm_id, buildid, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param str buildid: Build ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Build, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'algorithm_id',
            'buildid'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_by_id_build_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'algorithm_id' is set
        if self.api_client.client_side_validation and ('algorithm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['algorithm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algorithm_id` when calling `get_algorithm_by_id_build_by_id`")  # noqa: E501
        # verify the required parameter 'buildid' is set
        if self.api_client.client_side_validation and ('buildid' not in local_var_params or  # noqa: E501
                                                        local_var_params['buildid'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `buildid` when calling `get_algorithm_by_id_build_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'algorithm_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['algorithm_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algorithm_id` when calling `get_algorithm_by_id_build_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'algorithm_id' in local_var_params:
            path_params['algorithmId'] = local_var_params['algorithm_id']  # noqa: E501
        if 'buildid' in local_var_params:
            path_params['buildid'] = local_var_params['buildid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmId}/builds/{buildid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Build',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_by_id_build_logs(self, algorithm_id, buildid, **kwargs):  # noqa: E501
        """Get Algorithm build logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_by_id_build_logs(algorithm_id, buildid, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param str buildid: Build ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BuildLogs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_by_id_build_logs_with_http_info(algorithm_id, buildid, **kwargs)  # noqa: E501

    def get_algorithm_by_id_build_logs_with_http_info(self, algorithm_id, buildid, **kwargs):  # noqa: E501
        """Get Algorithm build logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_by_id_build_logs_with_http_info(algorithm_id, buildid, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param str buildid: Build ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BuildLogs, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'algorithm_id',
            'buildid'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_by_id_build_logs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'algorithm_id' is set
        if self.api_client.client_side_validation and ('algorithm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['algorithm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algorithm_id` when calling `get_algorithm_by_id_build_logs`")  # noqa: E501
        # verify the required parameter 'buildid' is set
        if self.api_client.client_side_validation and ('buildid' not in local_var_params or  # noqa: E501
                                                        local_var_params['buildid'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `buildid` when calling `get_algorithm_by_id_build_logs`")  # noqa: E501

        if self.api_client.client_side_validation and 'algorithm_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['algorithm_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algorithm_id` when calling `get_algorithm_by_id_build_logs`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'algorithm_id' in local_var_params:
            path_params['algorithmId'] = local_var_params['algorithm_id']  # noqa: E501
        if 'buildid' in local_var_params:
            path_params['buildid'] = local_var_params['buildid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmId}/builds/{buildid}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BuildLogs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_by_id_builds(self, algorithm_id, **kwargs):  # noqa: E501
        """Get Algorithm builds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_by_id_builds(algorithm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PagedBuildsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_by_id_builds_with_http_info(algorithm_id, **kwargs)  # noqa: E501

    def get_algorithm_by_id_builds_with_http_info(self, algorithm_id, **kwargs):  # noqa: E501
        """Get Algorithm builds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_by_id_builds_with_http_info(algorithm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PagedBuildsList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'algorithm_id',
            'limit',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_by_id_builds" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'algorithm_id' is set
        if self.api_client.client_side_validation and ('algorithm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['algorithm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algorithm_id` when calling `get_algorithm_by_id_builds`")  # noqa: E501

        if self.api_client.client_side_validation and 'algorithm_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['algorithm_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algorithm_id` when calling `get_algorithm_by_id_builds`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'algorithm_id' in local_var_params:
            path_params['algorithmId'] = local_var_params['algorithm_id']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmId}/builds', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedBuildsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_hash_version(self, username, algoname, algohash, **kwargs):  # noqa: E501
        """Get Algorithm by Hash Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_hash_version(username, algoname, algohash, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param str algohash: Algorithm hash (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VersionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_hash_version_with_http_info(username, algoname, algohash, **kwargs)  # noqa: E501

    def get_algorithm_hash_version_with_http_info(self, username, algoname, algohash, **kwargs):  # noqa: E501
        """Get Algorithm by Hash Version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_hash_version_with_http_info(username, algoname, algohash, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param str algohash: Algorithm hash (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VersionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname',
            'algohash'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_hash_version" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `get_algorithm_hash_version`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `get_algorithm_hash_version`")  # noqa: E501
        # verify the required parameter 'algohash' is set
        if self.api_client.client_side_validation and ('algohash' not in local_var_params or  # noqa: E501
                                                        local_var_params['algohash'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algohash` when calling `get_algorithm_hash_version`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `get_algorithm_hash_version`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501
        if 'algohash' in local_var_params:
            path_params['algohash'] = local_var_params['algohash']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}/versions/{algohash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VersionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_scm_connection_status(self, username, algoname, **kwargs):  # noqa: E501
        """Get Algorithm SCM Connection Status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_scm_connection_status(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScmConnectionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_scm_connection_status_with_http_info(username, algoname, **kwargs)  # noqa: E501

    def get_algorithm_scm_connection_status_with_http_info(self, username, algoname, **kwargs):  # noqa: E501
        """Get Algorithm SCM Connection Status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_scm_connection_status_with_http_info(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScmConnectionStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_scm_connection_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `get_algorithm_scm_connection_status`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `get_algorithm_scm_connection_status`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `get_algorithm_scm_connection_status`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}/scm/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScmConnectionStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_usage_result(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """get_algorithm_usage_result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_usage_result(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param int page_size: (required)
        :param list[str] user:
        :param str marker:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AlgorithmUsageResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_usage_result_with_http_info(start_date, end_date, page_size, **kwargs)  # noqa: E501

    def get_algorithm_usage_result_with_http_info(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """get_algorithm_usage_result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_usage_result_with_http_info(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param int page_size: (required)
        :param list[str] user:
        :param str marker:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AlgorithmUsageResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'start_date',
            'end_date',
            'page_size',
            'user',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_usage_result" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'start_date' is set
        if self.api_client.client_side_validation and ('start_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_date` when calling `get_algorithm_usage_result`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if self.api_client.client_side_validation and ('end_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_date` when calling `get_algorithm_usage_result`")  # noqa: E501
        # verify the required parameter 'page_size' is set
        if self.api_client.client_side_validation and ('page_size' not in local_var_params or  # noqa: E501
                                                        local_var_params['page_size'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `page_size` when calling `get_algorithm_usage_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('start_date', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('end_date', local_var_params['end_date']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/usage/algorithms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AlgorithmUsageResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_versions(self, username, algoname, **kwargs):  # noqa: E501
        """Get Algorithm versions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_versions(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param bool published: Algorithm version's published state
        :param bool callable: Algorithm version's callable visibility
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PagedVersionsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_algorithm_versions_with_http_info(username, algoname, **kwargs)  # noqa: E501

    def get_algorithm_versions_with_http_info(self, username, algoname, **kwargs):  # noqa: E501
        """Get Algorithm versions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_versions_with_http_info(username, algoname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param bool published: Algorithm version's published state
        :param bool callable: Algorithm version's callable visibility
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PagedVersionsList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname',
            'limit',
            'marker',
            'published',
            'callable'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_versions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `get_algorithm_versions`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `get_algorithm_versions`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `get_algorithm_versions`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501
        if 'published' in local_var_params and local_var_params['published'] is not None:  # noqa: E501
            query_params.append(('published', local_var_params['published']))  # noqa: E501
        if 'callable' in local_var_params and local_var_params['callable'] is not None:  # noqa: E501
            query_params.append(('callable', local_var_params['callable']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedVersionsList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_organization_types(self, **kwargs):  # noqa: E501
        """Gets all organization types for user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_organization_types(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[OrganizationType]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_organization_types_with_http_info(**kwargs)  # noqa: E501

    def get_all_organization_types_with_http_info(self, **kwargs):  # noqa: E501
        """Gets all organization types for user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_organization_types_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[OrganizationType], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_organization_types" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/organization/types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OrganizationType]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_entry(self, keyname, **kwargs):  # noqa: E501
        """Get a frontend config entry represeted by the provided keyname  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_entry(keyname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str keyname: The keyname for the config map entry (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FrontendConfigurationEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_config_entry_with_http_info(keyname, **kwargs)  # noqa: E501

    def get_config_entry_with_http_info(self, keyname, **kwargs):  # noqa: E501
        """Get a frontend config entry represeted by the provided keyname  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_entry_with_http_info(keyname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str keyname: The keyname for the config map entry (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FrontendConfigurationEntry, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'keyname'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_entry" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'keyname' is set
        if self.api_client.client_side_validation and ('keyname' not in local_var_params or  # noqa: E501
                                                        local_var_params['keyname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `keyname` when calling `get_config_entry`")  # noqa: E501

        if self.api_client.client_side_validation and ('keyname' in local_var_params and  # noqa: E501
                                                        len(local_var_params['keyname']) > 64):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `keyname` when calling `get_config_entry`, length must be less than or equal to `64`")  # noqa: E501
        if self.api_client.client_side_validation and 'keyname' in local_var_params and not re.search(r'^[\w][\w-.]*[\w]$', local_var_params['keyname']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `keyname` when calling `get_config_entry`, must conform to the pattern `/^[\w][\w-.]*[\w]$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'keyname' in local_var_params:
            path_params['keyname'] = local_var_params['keyname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/config/frontend/{keyname}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FrontendConfigurationEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_listener_by_id_for_user_by_id(self, user_id, event_listener_id, **kwargs):  # noqa: E501
        """Get the event listener with provided ID configured for the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_listener_by_id_for_user_by_id(user_id, event_listener_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param str event_listener_id: The ID of an event listener (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EventListener
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_event_listener_by_id_for_user_by_id_with_http_info(user_id, event_listener_id, **kwargs)  # noqa: E501

    def get_event_listener_by_id_for_user_by_id_with_http_info(self, user_id, event_listener_id, **kwargs):  # noqa: E501
        """Get the event listener with provided ID configured for the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_listener_by_id_for_user_by_id_with_http_info(user_id, event_listener_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param str event_listener_id: The ID of an event listener (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EventListener, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id',
            'event_listener_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_listener_by_id_for_user_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `get_event_listener_by_id_for_user_by_id`")  # noqa: E501
        # verify the required parameter 'event_listener_id' is set
        if self.api_client.client_side_validation and ('event_listener_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['event_listener_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `event_listener_id` when calling `get_event_listener_by_id_for_user_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'user_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['user_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `user_id` when calling `get_event_listener_by_id_for_user_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'event_listener_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['event_listener_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `event_listener_id` when calling `get_event_listener_by_id_for_user_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501
        if 'event_listener_id' in local_var_params:
            path_params['eventListenerId'] = local_var_params['event_listener_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/event-listeners/{eventListenerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventListener',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_listeners_for_user_by_id(self, user_id, **kwargs):  # noqa: E501
        """Get the event listeners configured for the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_listeners_for_user_by_id(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PagedResultList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_event_listeners_for_user_by_id_with_http_info(user_id, **kwargs)  # noqa: E501

    def get_event_listeners_for_user_by_id_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get the event listeners configured for the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_listeners_for_user_by_id_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PagedResultList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_listeners_for_user_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `get_event_listeners_for_user_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'user_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['user_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `user_id` when calling `get_event_listeners_for_user_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/event-listeners', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResultList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_favicon(self, **kwargs):  # noqa: E501
        """Get favicon for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_favicon(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_favicon_with_http_info(**kwargs)  # noqa: E501

    def get_favicon_with_http_info(self, **kwargs):  # noqa: E501
        """Get favicon for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_favicon_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_favicon" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/config/favicon', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_or_directory(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Get Directory or File Contents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_or_directory(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param bool acl: Whether the ACL should be included in the response.
        :param str marker: Encoded pagination cursor
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Directory
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_file_or_directory_with_http_info(connector_id, connector_path, **kwargs)  # noqa: E501

    def get_file_or_directory_with_http_info(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Get Directory or File Contents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_or_directory_with_http_info(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param bool acl: Whether the ACL should be included in the response.
        :param str marker: Encoded pagination cursor
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Directory, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connector_id',
            'connector_path',
            'acl',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_or_directory" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connector_id' is set
        if self.api_client.client_side_validation and ('connector_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_id` when calling `get_file_or_directory`")  # noqa: E501
        # verify the required parameter 'connector_path' is set
        if self.api_client.client_side_validation and ('connector_path' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_path` when calling `get_file_or_directory`")  # noqa: E501

        if self.api_client.client_side_validation and 'connector_id' in local_var_params and not re.search(r'^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$', local_var_params['connector_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_id` when calling `get_file_or_directory`, must conform to the pattern `/^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'connector_path' in local_var_params and not re.search(r'^([^\/]+\/?)*$', local_var_params['connector_path']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_path` when calling `get_file_or_directory`, must conform to the pattern `/^([^\/]+\/?)*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'connector_id' in local_var_params:
            path_params['connectorId'] = local_var_params['connector_id']  # noqa: E501
        if 'connector_path' in local_var_params:
            path_params['connectorPath'] = local_var_params['connector_path']  # noqa: E501

        query_params = []
        if 'acl' in local_var_params and local_var_params['acl'] is not None:  # noqa: E501
            query_params.append(('acl', local_var_params['acl']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', '*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/connector/{connectorId}/{connectorPath}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Directory',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_frontend_config_entries(self, **kwargs):  # noqa: E501
        """Lists all frontend configuration values  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_frontend_config_entries(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PagedResultList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_frontend_config_entries_with_http_info(**kwargs)  # noqa: E501

    def get_frontend_config_entries_with_http_info(self, **kwargs):  # noqa: E501
        """Lists all frontend configuration values  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_frontend_config_entries_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PagedResultList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'limit',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_frontend_config_entries" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/config/frontend', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResultList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_full_usage(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """get_full_usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_full_usage(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param int page_size: (required)
        :param list[str] user:
        :param str marker:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FullUsageResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_full_usage_with_http_info(start_date, end_date, page_size, **kwargs)  # noqa: E501

    def get_full_usage_with_http_info(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """get_full_usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_full_usage_with_http_info(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param int page_size: (required)
        :param list[str] user:
        :param str marker:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FullUsageResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'start_date',
            'end_date',
            'page_size',
            'user',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_full_usage" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'start_date' is set
        if self.api_client.client_side_validation and ('start_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_date` when calling `get_full_usage`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if self.api_client.client_side_validation and ('end_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_date` when calling `get_full_usage`")  # noqa: E501
        # verify the required parameter 'page_size' is set
        if self.api_client.client_side_validation and ('page_size' not in local_var_params or  # noqa: E501
                                                        local_var_params['page_size'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `page_size` when calling `get_full_usage`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('start_date', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('end_date', local_var_params['end_date']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/usage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FullUsageResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logo(self, **kwargs):  # noqa: E501
        """Get logo for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logo(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_logo_with_http_info(**kwargs)  # noqa: E501

    def get_logo_with_http_info(self, **kwargs):  # noqa: E501
        """Get logo for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logo_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logo" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/config/logo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_organization(self, org_name, **kwargs):  # noqa: E501
        """Get an organization represented by the provided orgName  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organization(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Organization
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_organization_with_http_info(org_name, **kwargs)  # noqa: E501

    def get_organization_with_http_info(self, org_name, **kwargs):  # noqa: E501
        """Get an organization represented by the provided orgName  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organization_with_http_info(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Organization, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `get_organization`")  # noqa: E501

        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `get_organization`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/organizations/{orgName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Organization',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_organizations(self, **kwargs):  # noqa: E501
        """Lists all organizations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organizations(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PagedResultList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_organizations_with_http_info(**kwargs)  # noqa: E501

    def get_organizations_with_http_info(self, **kwargs):  # noqa: E501
        """Lists all organizations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organizations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PagedResultList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'limit',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_organizations" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/organizations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResultList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_scm(self, scm_id, **kwargs):  # noqa: E501
        """Get SCM  # noqa: E501

        Retrieve a single SCM by its ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scm(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Scm
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_scm_with_http_info(scm_id, **kwargs)  # noqa: E501

    def get_scm_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Get SCM  # noqa: E501

        Retrieve a single SCM by its ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scm_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Scm, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `get_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scms/{scmId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Scm',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_scm_status(self, scm_id, **kwargs):  # noqa: E501
        """Get SCM Authorization Status  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. If the calling user has completed the authorization flow for the SCM in question, this endpoint describes the SCM username that represents the user, as well as any organizations they have access to. If the calling user has not completed the authorization flow, we return an `authorization_status` of `unauthorized`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scm_status(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScmUserOAuthStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_scm_status_with_http_info(scm_id, **kwargs)  # noqa: E501

    def get_scm_status_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Get SCM Authorization Status  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. If the calling user has completed the authorization flow for the SCM in question, this endpoint describes the SCM username that represents the user, as well as any organizations they have access to. If the calling user has not completed the authorization flow, we return an `authorization_status` of `unauthorized`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scm_status_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScmUserOAuthStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scm_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `get_scm_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scms/{scmId}/oauth/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScmUserOAuthStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user(self, username, **kwargs):  # noqa: E501
        """Get a user represented by the provided username  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_with_http_info(username, **kwargs)  # noqa: E501

    def get_user_with_http_info(self, username, **kwargs):  # noqa: E501
        """Get a user represented by the provided username  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_with_http_info(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `get_user`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `get_user`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{username}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_by_id(self, user_id, **kwargs):  # noqa: E501
        """Get a user represented by the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_by_id(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_by_id_with_http_info(user_id, **kwargs)  # noqa: E501

    def get_user_by_id_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get a user represented by the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_by_id_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `get_user_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'user_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['user_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `user_id` when calling `get_user_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_usage_result(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """get_user_usage_result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_usage_result(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param int page_size: (required)
        :param list[str] user:
        :param str marker:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UserUsageResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_usage_result_with_http_info(start_date, end_date, page_size, **kwargs)  # noqa: E501

    def get_user_usage_result_with_http_info(self, start_date, end_date, page_size, **kwargs):  # noqa: E501
        """get_user_usage_result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_usage_result_with_http_info(start_date, end_date, page_size, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param date start_date: (required)
        :param date end_date: (required)
        :param int page_size: (required)
        :param list[str] user:
        :param str marker:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UserUsageResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'start_date',
            'end_date',
            'page_size',
            'user',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_usage_result" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'start_date' is set
        if self.api_client.client_side_validation and ('start_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_date` when calling `get_user_usage_result`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if self.api_client.client_side_validation and ('end_date' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_date'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_date` when calling `get_user_usage_result`")  # noqa: E501
        # verify the required parameter 'page_size' is set
        if self.api_client.client_side_validation and ('page_size' not in local_var_params or  # noqa: E501
                                                        local_var_params['page_size'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `page_size` when calling `get_user_usage_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user' in local_var_params and local_var_params['user'] is not None:  # noqa: E501
            query_params.append(('user', local_var_params['user']))  # noqa: E501
            collection_formats['user'] = 'multi'  # noqa: E501
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('start_date', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('end_date', local_var_params['end_date']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('page_size', local_var_params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/usage/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserUsageResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users(self, **kwargs):  # noqa: E501
        """Lists all managed users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PagedResultList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_users_with_http_info(**kwargs)  # noqa: E501

    def get_users_with_http_info(self, **kwargs):  # noqa: E501
        """Lists all managed users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int limit: The number of results to return in a single page
        :param str marker: Encoded pagination cursor
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PagedResultList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'limit',
            'marker'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'marker' in local_var_params and local_var_params['marker'] is not None:  # noqa: E501
            query_params.append(('marker', local_var_params['marker']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResultList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_utility_algorithms(self, org_name, **kwargs):  # noqa: E501
        """List of Utility Algorithms  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_utility_algorithms(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[UtilityAlgorithm]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_utility_algorithms_with_http_info(org_name, **kwargs)  # noqa: E501

    def get_utility_algorithms_with_http_info(self, org_name, **kwargs):  # noqa: E501
        """List of Utility Algorithms  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_utility_algorithms_with_http_info(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[UtilityAlgorithm], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_utility_algorithms" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `get_utility_algorithms`")  # noqa: E501

        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `get_utility_algorithms`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/organizations/{orgName}/utility-algorithms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UtilityAlgorithm]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def initiate_scm_authorization(self, scm_id, **kwargs):  # noqa: E501
        """Initiate SCM Authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. Allows a user to begin the OAuth authorization flow for a given SCM, thereby allowing Algorithmia to access any necessary SCM resources on their behalf, such as repositories, deploy keys, and webhooks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.initiate_scm_authorization(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.initiate_scm_authorization_with_http_info(scm_id, **kwargs)  # noqa: E501

    def initiate_scm_authorization_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Initiate SCM Authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. Allows a user to begin the OAuth authorization flow for a given SCM, thereby allowing Algorithmia to access any necessary SCM resources on their behalf, such as repositories, deploy keys, and webhooks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.initiate_scm_authorization_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method initiate_scm_authorization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `initiate_scm_authorization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scms/{scmId}/oauth/start', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_keys(self, org_name, **kwargs):  # noqa: E501
        """List all the keys in an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_keys(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_keys_with_http_info(org_name, **kwargs)  # noqa: E501

    def list_keys_with_http_info(self, org_name, **kwargs):  # noqa: E501
        """List all the keys in an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_keys_with_http_info(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_keys" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `list_keys`")  # noqa: E501

        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `list_keys`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/organizations/{orgName}/keys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_members(self, org_name, **kwargs):  # noqa: E501
        """List of members with their roles in a given organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_members(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PagedResultList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_members_with_http_info(org_name, **kwargs)  # noqa: E501

    def list_members_with_http_info(self, org_name, **kwargs):  # noqa: E501
        """List of members with their roles in a given organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_members_with_http_info(org_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PagedResultList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_members" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `list_members`")  # noqa: E501

        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `list_members`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/organizations/{orgName}/members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResultList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_scms(self, **kwargs):  # noqa: E501
        """List SCMs  # noqa: E501

        List SCMs configured for the Algorithmia instance.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_scms(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_scms_with_http_info(**kwargs)  # noqa: E501

    def list_scms_with_http_info(self, **kwargs):  # noqa: E501
        """List SCMs  # noqa: E501

        List SCMs configured for the Algorithmia instance.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_scms_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2002, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_scms" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_event_listeners_for_user_by_id(self, user_id, event_listener_request, **kwargs):  # noqa: E501
        """Creates a new event listener for a user by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_event_listeners_for_user_by_id(user_id, event_listener_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param EventListenerRequest event_listener_request: Request with event listener (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EventListener
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_event_listeners_for_user_by_id_with_http_info(user_id, event_listener_request, **kwargs)  # noqa: E501

    def post_event_listeners_for_user_by_id_with_http_info(self, user_id, event_listener_request, **kwargs):  # noqa: E501
        """Creates a new event listener for a user by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_event_listeners_for_user_by_id_with_http_info(user_id, event_listener_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param EventListenerRequest event_listener_request: Request with event listener (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EventListener, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id',
            'event_listener_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_event_listeners_for_user_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `post_event_listeners_for_user_by_id`")  # noqa: E501
        # verify the required parameter 'event_listener_request' is set
        if self.api_client.client_side_validation and ('event_listener_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['event_listener_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `event_listener_request` when calling `post_event_listeners_for_user_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'user_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['user_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `user_id` when calling `post_event_listeners_for_user_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'event_listener_request' in local_var_params:
            body_params = local_var_params['event_listener_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/event-listeners', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventListener',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_algorithm(self, username, algoname, version_request, **kwargs):  # noqa: E501
        """Publish Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_algorithm(username, algoname, version_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param VersionRequest version_request: Publish Version Request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VersionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.publish_algorithm_with_http_info(username, algoname, version_request, **kwargs)  # noqa: E501

    def publish_algorithm_with_http_info(self, username, algoname, version_request, **kwargs):  # noqa: E501
        """Publish Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_algorithm_with_http_info(username, algoname, version_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param VersionRequest version_request: Publish Version Request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VersionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname',
            'version_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_algorithm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `publish_algorithm`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `publish_algorithm`")  # noqa: E501
        # verify the required parameter 'version_request' is set
        if self.api_client.client_side_validation and ('version_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['version_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `version_request` when calling `publish_algorithm`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `publish_algorithm`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'version_request' in local_var_params:
            body_params = local_var_params['version_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}/versions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VersionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_algorithm_by_id(self, algorithm_id, version_request, **kwargs):  # noqa: E501
        """Publish Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_algorithm_by_id(algorithm_id, version_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param VersionRequest version_request: Publish Version Request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VersionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.publish_algorithm_by_id_with_http_info(algorithm_id, version_request, **kwargs)  # noqa: E501

    def publish_algorithm_by_id_with_http_info(self, algorithm_id, version_request, **kwargs):  # noqa: E501
        """Publish Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_algorithm_by_id_with_http_info(algorithm_id, version_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param VersionRequest version_request: Publish Version Request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VersionResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'algorithm_id',
            'version_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_algorithm_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'algorithm_id' is set
        if self.api_client.client_side_validation and ('algorithm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['algorithm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algorithm_id` when calling `publish_algorithm_by_id`")  # noqa: E501
        # verify the required parameter 'version_request' is set
        if self.api_client.client_side_validation and ('version_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['version_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `version_request` when calling `publish_algorithm_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'algorithm_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['algorithm_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algorithm_id` when calling `publish_algorithm_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'algorithm_id' in local_var_params:
            path_params['algorithmId'] = local_var_params['algorithm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'version_request' in local_var_params:
            body_params = local_var_params['version_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmId}/versions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VersionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def receive_algorithm_by_id_scm_repository_event(self, algorithm_id, body, **kwargs):  # noqa: E501
        """Receiver of all SCM repository events  # noqa: E501

        This endpoint is called exclusively by SCM provider who wish to inform us of changes to repositories backing algorithms.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.receive_algorithm_by_id_scm_repository_event(algorithm_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param object body: Contains information for the event that triggered this webhook. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse202
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.receive_algorithm_by_id_scm_repository_event_with_http_info(algorithm_id, body, **kwargs)  # noqa: E501

    def receive_algorithm_by_id_scm_repository_event_with_http_info(self, algorithm_id, body, **kwargs):  # noqa: E501
        """Receiver of all SCM repository events  # noqa: E501

        This endpoint is called exclusively by SCM provider who wish to inform us of changes to repositories backing algorithms.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.receive_algorithm_by_id_scm_repository_event_with_http_info(algorithm_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param object body: Contains information for the event that triggered this webhook. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse202, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'algorithm_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method receive_algorithm_by_id_scm_repository_event" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'algorithm_id' is set
        if self.api_client.client_side_validation and ('algorithm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['algorithm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algorithm_id` when calling `receive_algorithm_by_id_scm_repository_event`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `receive_algorithm_by_id_scm_repository_event`")  # noqa: E501

        if self.api_client.client_side_validation and 'algorithm_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['algorithm_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algorithm_id` when calling `receive_algorithm_by_id_scm_repository_event`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'algorithm_id' in local_var_params:
            path_params['algorithmId'] = local_var_params['algorithm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['GithubAuth', 'GithubEventIdentification']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmId}/scm/webhook', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse202',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def receive_scm_repository_event(self, username, algoname, body, **kwargs):  # noqa: E501
        """Receiver of all SCM repository events  # noqa: E501

        This endpoint is called exclusively by SCM provider who wish to inform us of changes to repositories backing algorithms.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.receive_scm_repository_event(username, algoname, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param object body: Contains information for the event that triggered this webhook. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse202
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.receive_scm_repository_event_with_http_info(username, algoname, body, **kwargs)  # noqa: E501

    def receive_scm_repository_event_with_http_info(self, username, algoname, body, **kwargs):  # noqa: E501
        """Receiver of all SCM repository events  # noqa: E501

        This endpoint is called exclusively by SCM provider who wish to inform us of changes to repositories backing algorithms.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.receive_scm_repository_event_with_http_info(username, algoname, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param object body: Contains information for the event that triggered this webhook. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse202, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method receive_scm_repository_event" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `receive_scm_repository_event`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `receive_scm_repository_event`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `receive_scm_repository_event`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `receive_scm_repository_event`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['GithubAuth', 'GithubEventIdentification']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}/scm/webhook', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse202',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_organization_member(self, org_name, username, **kwargs):  # noqa: E501
        """Remove a user from an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_organization_member(org_name, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param str username: The user's username (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_organization_member_with_http_info(org_name, username, **kwargs)  # noqa: E501

    def remove_organization_member_with_http_info(self, org_name, username, **kwargs):  # noqa: E501
        """Remove a user from an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_organization_member_with_http_info(org_name, username, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str org_name: Organization name (required)
        :param str username: The user's username (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'org_name',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_organization_member" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'org_name' is set
        if self.api_client.client_side_validation and ('org_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['org_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `org_name` when calling `remove_organization_member`")  # noqa: E501
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `remove_organization_member`")  # noqa: E501

        if self.api_client.client_side_validation and 'org_name' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['org_name']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `org_name` when calling `remove_organization_member`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `remove_organization_member`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'org_name' in local_var_params:
            path_params['orgName'] = local_var_params['org_name']  # noqa: E501
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/organizations/{orgName}/members/{username}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_scm_authorization(self, scm_id, **kwargs):  # noqa: E501
        """Revoke SCM Authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. If the calling user has completed the authorization flow for the SCM in question, this endpoint prompts us to invalidate and discard said access token. After this has occurred, all algorithms created by the user will continue to function, but they will no longer be able to create algorithms backed by the SCM.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_scm_authorization(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revoke_scm_authorization_with_http_info(scm_id, **kwargs)  # noqa: E501

    def revoke_scm_authorization_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Revoke SCM Authorization  # noqa: E501

        Applies only to SCMs which leverage an OAuth authorization flow. If the calling user has completed the authorization flow for the SCM in question, this endpoint prompts us to invalidate and discard said access token. After this has occurred, all algorithms created by the user will continue to function, but they will no longer be able to create algorithms backed by the SCM.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_scm_authorization_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_scm_authorization" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `revoke_scm_authorization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scms/{scmId}/oauth/revoke', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_default_scm(self, scm_id, **kwargs):  # noqa: E501
        """Set Default SCM  # noqa: E501

        Specifies that the SCM should be the default for the cluster. Removes the designation from the previous default SCM. If the SCM in question is currently disabled, this call will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_scm(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.set_default_scm_with_http_info(scm_id, **kwargs)  # noqa: E501

    def set_default_scm_with_http_info(self, scm_id, **kwargs):  # noqa: E501
        """Set Default SCM  # noqa: E501

        Specifies that the SCM should be the default for the cluster. Removes the designation from the previous default SCM. If the SCM in question is currently disabled, this call will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_scm_with_http_info(scm_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_default_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `set_default_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/scms/{scmId}/default', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_algorithm(self, username, algoname, update_request, **kwargs):  # noqa: E501
        """Update Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_algorithm(username, algoname, update_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param UpdateRequest update_request: Algorithm Update Request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HashResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_algorithm_with_http_info(username, algoname, update_request, **kwargs)  # noqa: E501

    def update_algorithm_with_http_info(self, username, algoname, update_request, **kwargs):  # noqa: E501
        """Update Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_algorithm_with_http_info(username, algoname, update_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param str algoname: Algorithm name (required)
        :param UpdateRequest update_request: Algorithm Update Request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HashResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'algoname',
            'update_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_algorithm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `update_algorithm`")  # noqa: E501
        # verify the required parameter 'algoname' is set
        if self.api_client.client_side_validation and ('algoname' not in local_var_params or  # noqa: E501
                                                        local_var_params['algoname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algoname` when calling `update_algorithm`")  # noqa: E501
        # verify the required parameter 'update_request' is set
        if self.api_client.client_side_validation and ('update_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_request` when calling `update_algorithm`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `update_algorithm`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501
        if 'algoname' in local_var_params:
            path_params['algoname'] = local_var_params['algoname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_request' in local_var_params:
            body_params = local_var_params['update_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{username}/{algoname}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HashResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_algorithm_by_id(self, algorithm_id, update_request, **kwargs):  # noqa: E501
        """Update Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_algorithm_by_id(algorithm_id, update_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param UpdateRequest update_request: Algorithm Update Request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: HashResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_algorithm_by_id_with_http_info(algorithm_id, update_request, **kwargs)  # noqa: E501

    def update_algorithm_by_id_with_http_info(self, algorithm_id, update_request, **kwargs):  # noqa: E501
        """Update Algorithm  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_algorithm_by_id_with_http_info(algorithm_id, update_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str algorithm_id: Algorithm UUID (required)
        :param UpdateRequest update_request: Algorithm Update Request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(HashResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'algorithm_id',
            'update_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_algorithm_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'algorithm_id' is set
        if self.api_client.client_side_validation and ('algorithm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['algorithm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `algorithm_id` when calling `update_algorithm_by_id`")  # noqa: E501
        # verify the required parameter 'update_request' is set
        if self.api_client.client_side_validation and ('update_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['update_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `update_request` when calling `update_algorithm_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'algorithm_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['algorithm_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `algorithm_id` when calling `update_algorithm_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'algorithm_id' in local_var_params:
            path_params['algorithmId'] = local_var_params['algorithm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_request' in local_var_params:
            body_params = local_var_params['update_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/algorithms/{algorithmId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HashResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_config_entry(self, keyname, frontend_configuration_entry, **kwargs):  # noqa: E501
        """Update or insert a config entry represented by the provided keyname  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_config_entry(keyname, frontend_configuration_entry, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str keyname: The keyname for the config map entry (required)
        :param FrontendConfigurationEntry frontend_configuration_entry: Request with config entry (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FrontendConfigurationEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_config_entry_with_http_info(keyname, frontend_configuration_entry, **kwargs)  # noqa: E501

    def update_config_entry_with_http_info(self, keyname, frontend_configuration_entry, **kwargs):  # noqa: E501
        """Update or insert a config entry represented by the provided keyname  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_config_entry_with_http_info(keyname, frontend_configuration_entry, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str keyname: The keyname for the config map entry (required)
        :param FrontendConfigurationEntry frontend_configuration_entry: Request with config entry (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FrontendConfigurationEntry, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'keyname',
            'frontend_configuration_entry'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_config_entry" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'keyname' is set
        if self.api_client.client_side_validation and ('keyname' not in local_var_params or  # noqa: E501
                                                        local_var_params['keyname'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `keyname` when calling `update_config_entry`")  # noqa: E501
        # verify the required parameter 'frontend_configuration_entry' is set
        if self.api_client.client_side_validation and ('frontend_configuration_entry' not in local_var_params or  # noqa: E501
                                                        local_var_params['frontend_configuration_entry'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `frontend_configuration_entry` when calling `update_config_entry`")  # noqa: E501

        if self.api_client.client_side_validation and ('keyname' in local_var_params and  # noqa: E501
                                                        len(local_var_params['keyname']) > 64):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `keyname` when calling `update_config_entry`, length must be less than or equal to `64`")  # noqa: E501
        if self.api_client.client_side_validation and 'keyname' in local_var_params and not re.search(r'^[\w][\w-.]*[\w]$', local_var_params['keyname']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `keyname` when calling `update_config_entry`, must conform to the pattern `/^[\w][\w-.]*[\w]$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'keyname' in local_var_params:
            path_params['keyname'] = local_var_params['keyname']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'frontend_configuration_entry' in local_var_params:
            body_params = local_var_params['frontend_configuration_entry']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/config/frontend/{keyname}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FrontendConfigurationEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_directory_acl(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Update Directory  # noqa: E501

        Updates the ACL for an Algorithmia hosted data collection. Note that, at this time, this endpoint is not supported for any other connector beyond Algorithmia's own hosted data solution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_directory_acl(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_directory_acl_with_http_info(connector_id, connector_path, **kwargs)  # noqa: E501

    def update_directory_acl_with_http_info(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Update Directory  # noqa: E501

        Updates the ACL for an Algorithmia hosted data collection. Note that, at this time, this endpoint is not supported for any other connector beyond Algorithmia's own hosted data solution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_directory_acl_with_http_info(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connector_id',
            'connector_path',
            'unknown_base_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_directory_acl" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connector_id' is set
        if self.api_client.client_side_validation and ('connector_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_id` when calling `update_directory_acl`")  # noqa: E501
        # verify the required parameter 'connector_path' is set
        if self.api_client.client_side_validation and ('connector_path' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_path` when calling `update_directory_acl`")  # noqa: E501

        if self.api_client.client_side_validation and 'connector_id' in local_var_params and not re.search(r'^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$', local_var_params['connector_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_id` when calling `update_directory_acl`, must conform to the pattern `/^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'connector_path' in local_var_params and not re.search(r'^([^\/]+\/?)*$', local_var_params['connector_path']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_path` when calling `update_directory_acl`, must conform to the pattern `/^([^\/]+\/?)*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'connector_id' in local_var_params:
            path_params['connectorId'] = local_var_params['connector_id']  # noqa: E501
        if 'connector_path' in local_var_params:
            path_params['connectorPath'] = local_var_params['connector_path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/connector/{connectorId}/{connectorPath}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_listener_for_user_by_id(self, user_id, event_listener_id, **kwargs):  # noqa: E501
        """Update an event listener with provided ID configured for the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_event_listener_for_user_by_id(user_id, event_listener_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param str event_listener_id: The ID of an event listener (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EventListener
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_event_listener_for_user_by_id_with_http_info(user_id, event_listener_id, **kwargs)  # noqa: E501

    def update_event_listener_for_user_by_id_with_http_info(self, user_id, event_listener_id, **kwargs):  # noqa: E501
        """Update an event listener with provided ID configured for the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_event_listener_for_user_by_id_with_http_info(user_id, event_listener_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param str event_listener_id: The ID of an event listener (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EventListener, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id',
            'event_listener_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_listener_for_user_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `update_event_listener_for_user_by_id`")  # noqa: E501
        # verify the required parameter 'event_listener_id' is set
        if self.api_client.client_side_validation and ('event_listener_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['event_listener_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `event_listener_id` when calling `update_event_listener_for_user_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'user_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['user_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `user_id` when calling `update_event_listener_for_user_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'event_listener_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['event_listener_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `event_listener_id` when calling `update_event_listener_for_user_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501
        if 'event_listener_id' in local_var_params:
            path_params['eventListenerId'] = local_var_params['event_listener_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/event-listeners/{eventListenerId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventListener',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_favicon(self, **kwargs):  # noqa: E501
        """Update favicon for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_favicon(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_favicon_with_http_info(**kwargs)  # noqa: E501

    def update_favicon_with_http_info(self, **kwargs):  # noqa: E501
        """Update favicon for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_favicon_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_favicon" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/config/favicon', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_logo(self, **kwargs):  # noqa: E501
        """Update logo for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_logo(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_logo_with_http_info(**kwargs)  # noqa: E501

    def update_logo_with_http_info(self, **kwargs):  # noqa: E501
        """Update logo for the Algorithmia instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_logo_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_logo" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/config/logo', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_scm(self, scm_id, unknown_base_type, **kwargs):  # noqa: E501
        """Update an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_scm(scm_id, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: Only the `enabled` property of an SCM may be updated. If you attempt to disable an SCM that is currently the default, this call will fail, and you will be returned an appropriate error code. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Scm
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_scm_with_http_info(scm_id, unknown_base_type, **kwargs)  # noqa: E501

    def update_scm_with_http_info(self, scm_id, unknown_base_type, **kwargs):  # noqa: E501
        """Update an SCM  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_scm_with_http_info(scm_id, unknown_base_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str scm_id: SCM ID (required)
        :param UNKNOWN_BASE_TYPE unknown_base_type: Only the `enabled` property of an SCM may be updated. If you attempt to disable an SCM that is currently the default, this call will fail, and you will be returned an appropriate error code. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Scm, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'scm_id',
            'unknown_base_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_scm" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'scm_id' is set
        if self.api_client.client_side_validation and ('scm_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scm_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scm_id` when calling `update_scm`")  # noqa: E501
        # verify the required parameter 'unknown_base_type' is set
        if self.api_client.client_side_validation and ('unknown_base_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['unknown_base_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `unknown_base_type` when calling `update_scm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'scm_id' in local_var_params:
            path_params['scmId'] = local_var_params['scm_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unknown_base_type' in local_var_params:
            body_params = local_var_params['unknown_base_type']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth', 'CookieAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/scms/{scmId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Scm',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user(self, username, user, **kwargs):  # noqa: E501
        """Update a user represented by the provided username  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user(username, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param User user: Request with User (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_user_with_http_info(username, user, **kwargs)  # noqa: E501

    def update_user_with_http_info(self, username, user, **kwargs):  # noqa: E501
        """Update a user represented by the provided username  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_with_http_info(username, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str username: The user's username (required)
        :param User user: Request with User (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'username',
            'user'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `update_user`")  # noqa: E501
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in local_var_params or  # noqa: E501
                                                        local_var_params['user'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user` when calling `update_user`")  # noqa: E501

        if self.api_client.client_side_validation and 'username' in local_var_params and not re.search(r'^[a-zA-Z][a-zA-Z0-9_]*$', local_var_params['username']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `username` when calling `update_user`, must conform to the pattern `/^[a-zA-Z][a-zA-Z0-9_]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in local_var_params:
            body_params = local_var_params['user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{username}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user_by_id(self, user_id, user, **kwargs):  # noqa: E501
        """Update a user represented by the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_by_id(user_id, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param User user: Request with User (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_user_by_id_with_http_info(user_id, user, **kwargs)  # noqa: E501

    def update_user_by_id_with_http_info(self, user_id, user, **kwargs):  # noqa: E501
        """Update a user represented by the provided user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_by_id_with_http_info(user_id, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: The user's ID (required)
        :param User user: Request with User (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id',
            'user'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `update_user_by_id`")  # noqa: E501
        # verify the required parameter 'user' is set
        if self.api_client.client_side_validation and ('user' not in local_var_params or  # noqa: E501
                                                        local_var_params['user'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user` when calling `update_user_by_id`")  # noqa: E501

        if self.api_client.client_side_validation and 'user_id' in local_var_params and not re.search(r'^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$', local_var_params['user_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `user_id` when calling `update_user_by_id`, must conform to the pattern `/^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in local_var_params:
            body_params = local_var_params['user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AdminApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_file(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Upload File  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param file body:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upload_file_with_http_info(connector_id, connector_path, **kwargs)  # noqa: E501

    def upload_file_with_http_info(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Upload File  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_with_http_info(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param file body:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connector_id',
            'connector_path',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connector_id' is set
        if self.api_client.client_side_validation and ('connector_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_id` when calling `upload_file`")  # noqa: E501
        # verify the required parameter 'connector_path' is set
        if self.api_client.client_side_validation and ('connector_path' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_path` when calling `upload_file`")  # noqa: E501

        if self.api_client.client_side_validation and 'connector_id' in local_var_params and not re.search(r'^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$', local_var_params['connector_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_id` when calling `upload_file`, must conform to the pattern `/^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'connector_path' in local_var_params and not re.search(r'^([^\/]+\/?)*$', local_var_params['connector_path']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_path` when calling `upload_file`, must conform to the pattern `/^([^\/]+\/?)*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'connector_id' in local_var_params:
            path_params['connectorId'] = local_var_params['connector_id']  # noqa: E501
        if 'connector_path' in local_var_params:
            path_params['connectorPath'] = local_var_params['connector_path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/connector/{connectorId}/{connectorPath}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_file_existence(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Verify File Existence  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_file_existence(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.verify_file_existence_with_http_info(connector_id, connector_path, **kwargs)  # noqa: E501

    def verify_file_existence_with_http_info(self, connector_id, connector_path, **kwargs):  # noqa: E501
        """Verify File Existence  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_file_existence_with_http_info(connector_id, connector_path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str connector_id: Specifies the connector you wish to interact with. For Algorithmia hosted data, simply supply `data`. Otherwise, provide your connector's ID. A connector's ID is represented as its connector type, the `+` character, and its label (unless it is the default connector for its type, see below.) Thus, a non-default S3 connector with the label \"test\" would be identified as \"s3+test\". You can use your default connector for a given storage provider by passing the following identifiers: - `azureblob`: Your default Azure Blob connector. - `dropbox`: Your default Dropbox connector, if Dropbox is enabled for your Algorithmia instance. - `gs`: Your default Google Cloud Storage connector. - `s3`: Your default AWS S3 connector.  (required)
        :param str connector_path: Describes the file path you wish to operate on within your chosen data connector. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'connector_id',
            'connector_path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_file_existence" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connector_id' is set
        if self.api_client.client_side_validation and ('connector_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_id` when calling `verify_file_existence`")  # noqa: E501
        # verify the required parameter 'connector_path' is set
        if self.api_client.client_side_validation and ('connector_path' not in local_var_params or  # noqa: E501
                                                        local_var_params['connector_path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `connector_path` when calling `verify_file_existence`")  # noqa: E501

        if self.api_client.client_side_validation and 'connector_id' in local_var_params and not re.search(r'^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$', local_var_params['connector_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_id` when calling `verify_file_existence`, must conform to the pattern `/^(azureblob|data|dropbox|gs|s3){1}(\+[a-zA-Z0-9]+)?$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'connector_path' in local_var_params and not re.search(r'^([^\/]+\/?)*$', local_var_params['connector_path']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `connector_path` when calling `verify_file_existence`, must conform to the pattern `/^([^\/]+\/?)*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'connector_id' in local_var_params:
            path_params['connectorId'] = local_var_params['connector_id']  # noqa: E501
        if 'connector_path' in local_var_params:
            path_params['connectorPath'] = local_var_params['connector_path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/connector/{connectorId}/{connectorPath}', 'HEAD',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
