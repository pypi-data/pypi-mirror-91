(self.webpackChunk_deathbeds_wxyz_json_e=self.webpackChunk_deathbeds_wxyz_json_e||[]).push([[511],{214:(e,t)=>{class r{constructor(e){this.token=e,this.constructorName="ASTNode"}}let n=r;t.ASTNode=r,t.BinOp=class extends r{constructor(e,t,r){super(e),this.constructorName="BinOp",this.left=t,this.right=r}},t.UnaryOp=class extends r{constructor(e,t){super(e),this.constructorName="UnaryOp",this.expr=t}},t.Primitive=n,t.FunctionCall=class extends r{constructor(e,t,r){super(e),this.constructorName="FunctionCall",this.name=t,this.args=r}},t.ContextValue=class{constructor(e){this.token=e,this.constructorName="ContextValue"}},t.ValueAccess=class extends r{constructor(e,t,r,n,s){super(e),this.constructorName="ValueAccess",this.isInterval=r,this.arr=t,this.left=n,this.right=s}},t.List=class extends r{constructor(e,t){super(e),this.constructorName="List",this.list=t}},t.Object=class extends r{constructor(e,t){super(e),this.constructorName="Object",this.obj=t}}},400:(e,t,r)=>{var{BuiltinError:n}=r(649),s=r(857),{isString:i,isNumber:o,isBool:a,isArray:u,isObject:l,isJSON:c,isNull:h,isFunction:f}=r(618);let p={string:i,number:o,boolean:a,array:u,object:l,json:c,null:h,function:f},k=e=>new n(`invalid arguments to ${e}`);e.exports=e=>{let t={},r=(e,t,{argumentTests:r=[],minArgs:n=!1,variadic:s=null,needsContext:i=!1,invoke:o})=>(t[e]=(...t)=>{let a=t.shift();if(!s&&t.length<r.length)throw k(`builtin: ${e}`,t.toString());if(n&&t.length<n)throw k(`builtin: ${e}: expected at least ${n} arguments`);return s&&(r=t.map((()=>s))),t.forEach(((t,n)=>{if(!r[n].split("|").some((e=>p[e](t))))throw k(`builtin: ${e}`,r[n])})),i?o(a,...t):o(...t)},t[e].jsone_builtin=!0,t[e]);return["max","min"].forEach((e=>{if(null==Math[e])throw new Error(`${e} in Math undefined`);r(e,t,{minArgs:1,variadic:"number",invoke:(...t)=>Math[e](...t)})})),["sqrt","ceil","floor","abs"].forEach((e=>{if(null==Math[e])throw new Error(`${e} in Math undefined`);r(e,t,{argumentTests:["number"],invoke:t=>Math[e](t)})})),r("lowercase",t,{argumentTests:["string"],invoke:e=>e.toLowerCase()}),r("uppercase",t,{argumentTests:["string"],invoke:e=>e.toUpperCase()}),r("str",t,{argumentTests:["string|number|boolean|null"],invoke:e=>null===e?"null":e.toString()}),r("number",t,{argumentTests:["string"],invoke:Number}),r("len",t,{argumentTests:["string|array"],invoke:e=>Array.from(e).length}),r("strip",t,{argumentTests:["string"],invoke:e=>e.trim()}),r("rstrip",t,{argumentTests:["string"],invoke:e=>e.replace(/\s+$/,"")}),r("lstrip",t,{argumentTests:["string"],invoke:e=>e.replace(/^\s+/,"")}),r("split",t,{minArgs:1,variadic:"string|number",invoke:(e,t)=>e.split(t)}),r("join",t,{argumentTests:["array","string|number"],invoke:(e,t)=>e.join(t)}),r("fromNow",t,{variadic:"string",minArgs:1,needsContext:!0,invoke:(e,t,r)=>s(t,r||e.now)}),r("typeof",t,{argumentTests:["string|number|boolean|array|object|null|function"],invoke:e=>{for(let t of["string","number","boolean","array","object","function"])if(p[t](e))return t;if(p.null(e))return"null";throw k("builtin: typeof")}}),r("defined",t,{argumentTests:["string"],needsContext:!0,invoke:(e,t)=>e.hasOwnProperty(t)}),Object.assign({},t,e)}},649:e=>{class t extends Error{constructor(e){super(e),this.location=[]}add_location(e){this.location.unshift(e)}toString(){return this.location.length?`${this.name} at template${this.location.join("")}: ${this.message}`:`${this.name}: ${this.message}`}}class r extends t{constructor(e){super(e),this.message=e,this.name="BaseError"}}e.exports={JSONTemplateError:t,SyntaxError:class extends t{constructor(e){super(e),this.message=e,this.name="SyntaxError"}},InterpreterError:class extends r{constructor(e){super(e),this.name="InterpreterError"}},TemplateError:class extends r{constructor(e){super(e),this.name="TemplateError"}},BuiltinError:class extends r{constructor(e){super(e),this.name="BuiltinError"}}}},857:e=>{var t=new RegExp(["^(\\s*(-|\\+))?","(\\s*(\\d+)\\s*y((ears?)|r)?)?","(\\s*(\\d+)\\s*mo(nths?)?)?","(\\s*(\\d+)\\s*w((eeks?)|k)?)?","(\\s*(\\d+)\\s*d(ays?)?)?","(\\s*(\\d+)\\s*h((ours?)|r)?)?","(\\s*(\\d+)\\s*m(in(utes?)?)?)?","(\\s*(\\d+)\\s*s(ec(onds?)?)?)?","\\s*$"].join(""),"i");e.exports=(e="",r)=>{let n=function(e){var r=t.exec(e||"");if(!r)throw new Error("String: '"+e+"' isn't a time expression");var n="-"===r[2]?-1:1;return{years:parseInt(r[4]||0,10)*n,months:parseInt(r[8]||0,10)*n,weeks:parseInt(r[11]||0,10)*n,days:parseInt(r[15]||0,10)*n,hours:parseInt(r[18]||0,10)*n,minutes:parseInt(r[22]||0,10)*n,seconds:parseInt(r[25]||0,10)*n}}(e);return n.days+=30*n.months,n.days+=365*n.years,r=r?new Date(r):new Date,new Date(r.getTime()+7*n.weeks*24*60*60*1e3+24*n.days*60*60*1e3+60*n.hours*60*1e3+60*n.minutes*1e3+1e3*n.seconds).toJSON()}},511:(e,t,r)=>{const{Parser:n}=r(324),s=r(428),{Interpreter:i}=r(96);var o=r(857),a=r(468),{isString:u,isNumber:l,isBool:c,isArray:h,isObject:f,isTruthy:p}=r(618),k=r(400),{JSONTemplateError:w,TemplateError:d}=r(649);let g=e=>new SyntaxError(`Found ${e.value}, expected !=, &&, (, *, **, +, -, ., /, <, <=, ==, >, >=, [, in, ||`);function m(e,t){var r="",n=new RegExp(t.join("|")+"$");for(var s of Object.keys(e).sort())n.test(s)||(r+=" "+s);if(r)throw new d(t[0].replace("\\","")+" has undefined properties:"+r)}let y=e=>Array.isArray(e)?[].concat(...e.map(y)):e,v=(e,t)=>{let r,n="",s=e;for(;-1!==(r=s.search(/\$?\${/g));)if(n+=s.slice(0,r),"$"!=s[r+1]){let e=j(s.slice(r+2),"}",t);if(h(e.result)||f(e.result)){let t=s.slice(r+2,r+e.offset);throw new d(`interpolation of '${t}' produced an array or object`)}null===e.result?n+="":n+=e.result.toString(),s=s.slice(r+e.offset+1)}else n+="${",s=s.slice(r+3);return n+=s,n},b={},$={$eval:(e,t)=>{if(m(e,["\\$eval"]),!u(e.$eval))throw new d("$eval must be given a string expression");return O(e.$eval,t)},$flatten:(e,t)=>{m(e,["\\$flatten"]);let r=_(e.$flatten,t);if(!h(r))throw new d("$flatten value must evaluate to an array");return r.reduce(((e,t)=>e.concat(t)),[])},$flattenDeep:(e,t)=>{m(e,["\\$flattenDeep"]);let r=_(e.$flattenDeep,t);if(!h(r))throw new d("$flattenDeep value must evaluate to an array");return y(r)},$fromNow:(e,t)=>{m(e,["\\$fromNow","from"]);let r=_(e.$fromNow,t),n=t.now;if(e.from&&(n=_(e.from,t)),!u(r))throw new d("$fromNow expects a string");return o(r,n)},$if:(e,t)=>{if(m(e,["\\$if","then","else"]),!u(e.$if))throw new d("$if can evaluate string expressions only");if(p(O(e.$if,t))){if(e.hasOwnProperty("$then"))throw new d("$if Syntax error: $then: should be spelled then: (no $)");return e.hasOwnProperty("then")?_(e.then,t):b}return e.hasOwnProperty("else")?_(e.else,t):b},$json:(e,t)=>(m(e,["\\$json"]),a(_(e.$json,t))),$let:(e,t)=>{if(m(e,["\\$let","in"]),!f(e.$let))throw new d("$let value must be an object");let r={},n=_(e.$let,t);if(!f(n))throw new d("$let value must be an object");Object.keys(n).forEach((e=>{if(!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e))throw new d("top level keys of $let must follow /[a-zA-Z_][a-zA-Z0-9_]*/");r[e]=n[e]}));var s=Object.assign(t,r);if(null==e.in)throw new d("$let operator requires an `in` clause");return _(e.in,s)},$map:(e,t)=>{m(e,["\\$map","each\\(([a-zA-Z_][a-zA-Z0-9_]*)(,\\s*([a-zA-Z_][a-zA-Z0-9_]*))?\\)"]);let r=_(e.$map,t);if(!h(r)&&!f(r))throw new d("$map value must evaluate to an array or object");if(2!==Object.keys(e).length)throw new d("$map must have exactly two properties");let n=Object.keys(e).filter((e=>"$map"!==e))[0],s=/^each\(([a-zA-Z_][a-zA-Z0-9_]*)(,\s*([a-zA-Z_][a-zA-Z0-9_]*))?\)$/.exec(n);if(!s)throw new d("$map requires each(identifier) syntax");let i=s[1],o=s[3],a=e[n];if(f(r)){let e;return r=Object.keys(r).map((e=>({key:e,val:r[e]}))),r=r.map((r=>{let n=void 0!==o?{[i]:r.val,[o]:r.key}:{[i]:r};if(e=_(a,Object.assign({},t,n)),!f(e))throw new d(`$map on objects expects each(${i}) to evaluate to an object`);return e})).filter((e=>e!==b)),Object.assign({},...r)}return r.map(((e,r)=>{let n=void 0!==o?{[i]:e,[o]:r}:{[i]:e};return _(a,Object.assign({},t,n))})).filter((e=>e!==b))},$match:(e,t)=>{if(m(e,["\\$match"]),!f(e.$match))throw new d("$match can evaluate objects only");const r=[],n=e.$match;for(let e of Object.keys(n).sort())p(O(e,t))&&r.push(_(n[e],t));return r},$switch:(e,t)=>{if(m(e,["\\$switch"]),!f(e.$switch))throw new d("$switch can evaluate objects only");let r=[];const n=e.$switch;for(let e of Object.keys(n))p(O(e,t))&&r.push(_(n[e],t));if(r.length>1)throw new d("$switch can only have one truthy condition");return r.length>0?r[0]:b},$merge:(e,t)=>{m(e,["\\$merge"]);let r=_(e.$merge,t);if(!h(r)||r.some((e=>!f(e))))throw new d("$merge value must evaluate to an array of objects");return Object.assign({},...r)},$mergeDeep:(e,t)=>{m(e,["\\$mergeDeep"]);let r=_(e.$mergeDeep,t);if(!h(r)||r.some((e=>!f(e))))throw new d("$mergeDeep value must evaluate to an array of objects");if(0===r.length)return{};let n=(e,t)=>{if(h(e)&&h(t))return e.concat(t);if(f(e)&&f(t)){let r=Object.assign({},e);for(let s in t)r[s]=s in e?n(e[s],t[s]):t[s];return r}return t};return r.reduce(n,r.shift())},$reverse:(e,t)=>{m(e,["\\$reverse"]);let r=_(e.$reverse,t);if(!h(r))throw new d("$reverse value must evaluate to an array of objects");return r.reverse()},$sort:(e,t)=>{m(e,["\\$sort","by\\(([a-zA-Z_][a-zA-Z0-9_]*)\\)"]);let r=_(e.$sort,t);if(!h(r))throw new d("$sorted values to be sorted must have the same type");let n,s=Object.keys(e).filter((e=>"$sort"!==e))[0],i=/^by\(([a-zA-Z_][a-zA-Z0-9_]*)\)$/.exec(s);if(i){let r=Object.assign({},t),o=i[1],a=e[s];n=e=>(r[o]=e,O(a,r))}else{if(r.some((e=>h(e)||f(e))))throw new d("$sorted values to be sorted must have the same type");n=e=>e}let o=r.map((e=>[n(e),e]));if(o.length>0){let e=typeof o[0][0];if("number"!==e&&"string"!==e||o.some((t=>e!==typeof t[0])))throw new d("$sorted values to be sorted must have the same type")}return o.sort(((e,t)=>(e=e[0])<(t=t[0])?-1:e>t?1:0)).map((e=>e[1]))}},_=(e,t)=>{if(l(e)||c(e)||null===e)return e;if(u(e))return v(e,t);if(h(e))return e.map(((e,r)=>{try{return _(e,t)}catch(e){throw e instanceof w&&e.add_location(`[${r}]`),e}})).filter((e=>e!==b));let r=Object.keys($).filter((t=>e.hasOwnProperty(t)));if(r.length>1)throw new d("only one operator allowed");if(1===r.length)return $[r[0]](e,t);let n={};for(let r of Object.keys(e)){let s;try{s=_(e[r],t)}catch(e){throw e instanceof w&&(/^[a-zA-Z][a-zA-Z0-9]*$/.test(r)?e.add_location(`.${r}`):e.add_location(`[${JSON.stringify(r)}]`)),e}if(s!==b){if(r.startsWith("$$"))r=r.substr(1);else{if(/^\$[a-zA-Z][a-zA-Z0-9]*$/.test(r))throw new d("$<identifier> is reserved; use $$<identifier>");r=v(r,t)}n[r]=s}}return n},x=new s({ignore:"\\s+",patterns:{number:"[0-9]+(?:\\.[0-9]+)?",identifier:"[a-zA-Z_][a-zA-Z_0-9]*",string:"'[^']*'|\"[^\"]*\"",true:"true(?![a-zA-Z_0-9])",false:"false(?![a-zA-Z_0-9])",in:"in(?![a-zA-Z_0-9])",null:"null(?![a-zA-Z_0-9])"},tokens:["**",..."+-*/[].(){}:,".split(""),">=","<=","<",">","==","!=","!","&&","||","true","false","in","null","number","identifier","string"]}),O=(e,t)=>{let r=new n(x,e),s=r.parse();if(null!=r.current_token)throw g(r.current_token);return new i(t).interpret(s)},j=(e,t,r)=>{let s=new n(x,e),o=s.parse(),a=s.current_token;if(!a){let r=e.length;throw new SyntaxError(`Found end of string, expected ${t}`,{start:r,end:r})}if(a.kind!==t)throw g(a);return{result:new i(r).interpret(o),offset:a.start+2}};e.exports=(e,t={})=>{if(!Object.keys(t).every((e=>/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e))))throw new d("top level keys of context must follow /[a-zA-Z_][a-zA-Z0-9_]*/");t=k(Object.assign({},{now:o("0 seconds")},t));let r=_(e,t);return r===b?null:r}},96:(e,t,r)=>{const{isFunction:n,isObject:s,isString:i,isArray:o,isNumber:a,isInteger:u,isTruthy:l}=r(618),{InterpreterError:c}=r(649);let h=(e,t)=>new c(`${e} expects ${t}`),f=(e,t)=>{if(o(e)&&o(t)&&e.length===t.length){for(let r=0;r<e.length;r++)if(!f(e[r],t[r]))return!1;return!0}if(n(e))return e===t;if(s(e)&&s(t)){let r=Object.keys(e).sort();if(!f(r,Object.keys(t).sort()))return!1;for(let n of r)if(!f(e[n],t[n]))return!1;return!0}return e===t},p=(e,t,r)=>{if("+"===e&&!(a(t)&&a(r)||i(t)&&i(r)))throw h("infix: +","numbers/strings + numbers/strings");if(["-","*","/","**"].some((t=>t===e))&&(!a(t)||!a(r)))throw h(`infix: ${e}`,`number ${e} number`)},k=(e,t,r)=>{if("=="===e||"!="===e)return null;if(![">=","<=","<",">"].some((t=>t===e))||!(a(t)&&a(r)||i(t)&&i(r)))throw h(`infix: ${e}`,`numbers/strings ${e} numbers/strings`)};t.Interpreter=class{constructor(e){this.context=e}visit(e){return this["visit_"+e.constructorName](e)}visit_ASTNode(e){let t;switch(e.token.kind){case"number":return+e.token.value;case"null":return null;case"string":return t=e.token.value.slice(1,-1),t;case"true":return!0;case"false":return!1;case"identifier":return e.token.value}}visit_UnaryOp(e){let t=this.visit(e.expr);switch(e.token.kind){case"+":if(!a(t))throw h("unary +","number");return+t;case"-":if(!a(t))throw h("unary -","number");return-t;case"!":return!l(t)}}visit_BinOp(e){let t,r=this.visit(e.left);switch(e.token.kind){case"||":return l(r)||l(this.visit(e.right));case"&&":return l(r)&&l(this.visit(e.right));default:t=this.visit(e.right)}switch(e.token.kind){case"+":return p("+",r,t),r+t;case"-":return p("-",r,t),r-t;case"/":return p("/",r,t),r/t;case"*":return p("*",r,t),r*t;case">":return k(">",r,t),r>t;case"<":return k("<",r,t),r<t;case">=":return k(">=",r,t),r>=t;case"<=":return k("<=",r,t),r<=t;case"!=":return k("!=",r,t),!f(r,t);case"==":return k("==",r,t),f(r,t);case"**":return p("**",r,t),Math.pow(t,r);case".":if(s(r)){if(r.hasOwnProperty(t))return r[t];throw new c(`object has no property "${t}"`)}throw h("infix: .","objects");case"in":if(s(t)){if(!i(r))throw h("Infix: in-object","string on left side");t=Object.keys(t)}else{if(i(t)){if(!i(r))throw h("Infix: in-string","string on left side");return-1!==t.indexOf(r)}if(!o(t))throw h("Infix: in","Array, string, or object on right side")}return t.some((e=>f(r,e)))}}visit_List(e){let t=[];return void 0!==e.list[0]&&e.list.forEach((function(e){t.push(this.visit(e))}),this),t}visit_ValueAccess(e){let t=this.visit(e.arr),r=0,n=null;if(e.left&&(r=this.visit(e.left)),e.right&&(n=this.visit(e.right)),r<0&&(r=t.length+r),o(t)||i(t)){if(e.isInterval){if(n=null===n?t.length:n,n<0&&(n=t.length+n,n<0&&(n=0)),r>n&&(r=n),!u(r)||!u(n))throw new c("cannot perform interval access with non-integers");return t.slice(r,n)}if(!u(r))throw new c("should only use integers to access arrays or strings");if(r>=t.length)throw new c("index out of bounds");return t[r]}if(!s(t))throw h('infix: "[..]"',"object, array, or string");if(!i(r))throw new c("object keys must be strings");return t.hasOwnProperty(r)?t[r]:null}visit_ContextValue(e){if(this.context.hasOwnProperty(e.token.value))return this.context[e.token.value];throw new c(`unknown context value ${e.token.value}`)}visit_FunctionCall(e){let t=[],r=this.visit(e.name);if(n(r))return e.args.forEach((function(e){t.push(this.visit(e))}),this),r.hasOwnProperty("jsone_builtin")&&t.unshift(this.context),r.apply(null,t);throw new c(`${r} is not callable`)}visit_Object(e){let t={};for(let r in e.obj)t[r]=this.visit(e.obj[r]);return t}interpret(e){return this.visit(e)}}},324:(e,t,r)=>{const{UnaryOp:n,BinOp:s,Primitive:i,ContextValue:o,FunctionCall:a,ValueAccess:u,List:l,Object:c}=r(214),{SyntaxError:h}=r(649);let f=(e,t)=>(t.sort(),new h(`Found ${e.value}, expected ${t.join(", ")}`,e));t.Parser=class{constructor(e,t,r=0){this._source=t,this._tokenizer=e,this.current_token=this._tokenizer.next(this._source,r),this.unaryOpTokens=["-","+","!"],this.primitivesTokens=["number","null","true","false","string"],this.operations=[["||"],["&&"],["in"],["==","!="],["<",">","<=",">="],["+","-"],["*","/"],["**"]],this.expectedTokens=["!","(","+","-","[","false","identifier","null","number","string","true","{"]}takeToken(...e){if(null==this.current_token)throw new h("Unexpected end of input");if(e.length>0&&-1===e.indexOf(this.current_token.kind))throw f(this.current_token,e);try{this.current_token=this._tokenizer.next(this._source,this.current_token.end)}catch(e){throw e}}parse(e=0){let t;if(e==this.operations.length-1){t=this.parsePropertyAccessOrFunc();let r=this.current_token;for(;null!=r&&-1!==this.operations[e].indexOf(r.kind);r=this.current_token)this.takeToken(r.kind),t=new s(r,this.parse(e),t)}else{t=this.parse(e+1);let r=this.current_token;for(;null!=r&&-1!==this.operations[e].indexOf(r.kind);r=this.current_token)this.takeToken(r.kind),t=new s(r,t,this.parse(e+1))}return t}parsePropertyAccessOrFunc(){let e,t=this.parseUnit(),r=["[","(","."];for(let n=this.current_token;null!=n&&-1!==r.indexOf(n.kind);n=this.current_token)"["==n.kind?t=this.parseAccessWithBrackets(t):"."==n.kind?(n=this.current_token,this.takeToken("."),e=new i(this.current_token),this.takeToken("identifier"),t=new s(n,t,e)):"("==n.kind&&(t=this.parseFunctionCall(t));return t}parseUnit(){let e,t=this.current_token,r=-1!==this.unaryOpTokens.indexOf(t.kind),s=-1!==this.primitivesTokens.indexOf(t.kind);if(null==this.current_token)throw new h("Unexpected end of input");if(r)this.takeToken(t.kind),e=new n(t,this.parseUnit());else if(s)this.takeToken(t.kind),e=new i(t);else if("identifier"==t.kind)this.takeToken(t.kind),e=new o(t);else if("("==t.kind){if(this.takeToken("("),e=this.parse(),null==e)throw f(this.current_token,this.expectedTokens);this.takeToken(")")}else"["==t.kind?e=this.parseList():"{"==t.kind&&(e=this.parseObject());return e}parseFunctionCall(e){let t,r=this.current_token,n=[];if(this.takeToken("("),")"!=this.current_token.kind)for(t=this.parse(),n.push(t);null!=this.current_token&&","==this.current_token.kind;){if(null==n[n.length-1])throw f(this.current_token,this.expectedTokens);this.takeToken(","),t=this.parse(),n.push(t)}return this.takeToken(")"),t=new a(r,e,n),t}parseList(){let e,t=[],r=this.current_token;if(this.takeToken("["),"]"!=this.current_token.kind)for(e=this.parse(),t.push(e);","==this.current_token.kind;){if(null==t[t.length-1])throw f(this.current_token,this.expectedTokens);this.takeToken(","),e=this.parse(),t.push(e)}return this.takeToken("]"),e=new l(r,t),e}parseAccessWithBrackets(e){let t=null,r=null,n=this.current_token,s=!1;if(this.takeToken("["),"]"==this.current_token.kind)throw f(this.current_token,this.expectedTokens);if(":"!=this.current_token.kind&&(t=this.parse()),":"==this.current_token.kind&&(s=!0,this.takeToken(":")),"]"!=this.current_token.kind&&(r=this.parse()),s&&null==r&&"]"!=this.current_token.kind)throw f(this.current_token,this.expectedTokens);return this.takeToken("]"),new u(n,e,s,t,r)}parseObject(){let e,t,r,n={},s=this.current_token;this.takeToken("{");let i=this.current_token;for(;null!=i&&("string"==i.kind||"identifier"==i.kind);){if(t=i.value,"string"==i.kind&&(t=t.slice(1,-1)),this.takeToken(i.kind),this.takeToken(":"),r=this.parse(),null==r)throw f(this.current_token,this.expectedTokens);if(n[t]=r,null!=this.current_token&&"}"==this.current_token.kind)break;this.takeToken(","),i=this.current_token}return this.takeToken("}"),e=new c(s,n),e}}},428:(e,t,r)=>{var{SyntaxError:n}=r(649);let s=e=>(e=>{if("string"!=typeof e)return!1;try{new RegExp(`^${e}$`)}catch(e){return!1}return!0})(e)&&1===new RegExp(`^(?:|${e})$`).exec("").length,i=(e,t=0)=>{let r=e.length;for(let n=t;n<r;n++)if(void 0!==e[n])return n;return-1};const o=e=>{if(!e)throw new Error("Token configuration is invalid")};e.exports=class{constructor(e={}){e=Object.assign({},{ignore:null,patterns:{},tokens:[]},e),o(null===e.ignore||s(e.ignore)),o(e.patterns instanceof Object);for(let t of Object.keys(e.patterns))o(s(e.patterns[t]));o(e.tokens instanceof Array),e.tokens.forEach((e=>o("string"==typeof e))),this._tokens=e.tokens,this._hasIgnore=e.ignore?1:0,this._regex=new RegExp("^(?:"+[this._hasIgnore?`(${e.ignore})`:null,...this._tokens.map((t=>{return`(${e.patterns[t]||(r=t,r.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&"))})`;var r}))].filter((e=>null!==e)).join("|")+")")}next(e,t=0){let r,s;do{if(r=this._regex.exec(e.slice(t)),null===r){if(""!==e.slice(t))throw new n(`Unexpected input for '${e}' at '${e.slice(t)}'`,{start:t,end:e.length});return null}s=i(r,1),t+=r[0].length}while(this._hasIgnore&&1===s);return{kind:this._tokens[s-1-this._hasIgnore],value:r[s],start:t-r[0].length,end:t}}tokenize(e,t=0){let r={end:t},n=[];for(;r=this.next(e,r.end);)n.push(r);return n}}},618:e=>{let t={isString:e=>"string"==typeof e,isNumber:e=>"number"==typeof e,isInteger:e=>"number"==typeof e&&Number.isInteger(e),isBool:e=>"boolean"==typeof e,isNull:e=>null===e,isArray:e=>e instanceof Array,isObject:e=>e instanceof Object&&!(e instanceof Array)&&!(e instanceof Function),isFunction:e=>e instanceof Function,isJSON:e=>{if(t.isString(e)||t.isNumber(e)||t.isBool(e)||null===e)return!0;if(t.isArray(e))return e.every((e=>t.isJSON(e)));let r=!0;if(t.isobject(e)){for(let n of Object.keys(e))if(e.hasOwnProperty(n)&&(r=r&&t.isJSON(e[n]),!r))break;return r}return!1},isTruthy:e=>null!==e&&(t.isArray(e)&&e.length>0||t.isObject(e)&&Object.keys(e).length>0||t.isString(e)&&e.length>0||t.isNumber(e)&&0!==e||t.isBool(e)&&e||t.isFunction(e))};e.exports=t},468:e=>{e.exports=function(e,n){n||(n={}),"function"==typeof n&&(n={cmp:n});var s=n.space||"";"number"==typeof s&&(s=Array(s+1).join(" "));var i,o="boolean"==typeof n.cycles&&n.cycles,a=n.replacer||function(e,t){return t},u=n.cmp&&(i=n.cmp,function(e){return function(t,r){var n={key:t,value:e[t]},s={key:r,value:e[r]};return i(n,s)}}),l=[];return function e(n,i,c,h){var f=s?"\n"+new Array(h+1).join(s):"",p=s?": ":":";if(c&&c.toJSON&&"function"==typeof c.toJSON&&(c=c.toJSON()),void 0!==(c=a.call(n,i,c))){if("object"!=typeof c||null===c)return JSON.stringify(c);if(t(c)){for(var k=[],w=0;w<c.length;w++){var d=e(c,w,c[w],h+1)||JSON.stringify(null);k.push(f+s+d)}return"["+k.join(",")+f+"]"}if(-1!==l.indexOf(c)){if(o)return JSON.stringify("__cycle__");throw new TypeError("Converting circular structure to JSON")}l.push(c);var g=r(c).sort(u&&u(c));for(k=[],w=0;w<g.length;w++){var m=e(c,i=g[w],c[i],h+1);if(m){var y=JSON.stringify(i)+p+m;k.push(f+s+y)}}return l.splice(l.indexOf(c),1),"{"+k.join(",")+f+"}"}}({"":e},"",e,0)};var t=Array.isArray||function(e){return"[object Array]"==={}.toString.call(e)},r=Object.keys||function(e){var t=Object.prototype.hasOwnProperty||function(){return!0},r=[];for(var n in e)t.call(e,n)&&r.push(n);return r}}}]);