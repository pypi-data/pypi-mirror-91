{"version":3,"sources":["webpack://@jupyterlab/rtc/./lib/AutomergeActions.js","webpack://@jupyterlab/rtc/./lib/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAA+C;AACxC;AACP,WAAW,kEAAc;AACzB;AACO;AACP,WAAW,kEAAc;AACzB;AACA,sBAAsB,oEAAc;AACpC,KAAK;AACL;AACO;AACP,WAAW,0EAAsB;AACjC;AACO;AACP,WAAW,wEAAoB;AAC/B;AACO;AACP,WAAW,mEAAe;AAC1B;AACO;AACP,WAAW,wEAAoB;AAC/B;;;;;;;;;;;;;;;;;;;;;;;ACrBwD;AACA;AACxD,WAAW,mBAAmB;AACiB;AAC8B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gCAAgC,6DAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAY;AACvC;AACA;AACA,6FAA6F,QAAQ;AACrG,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA,uCAAuC,+DAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gCAAgC,6DAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAY;AACzC;AACA;AACA,6FAA6F,QAAQ;AACrG,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA,uCAAuC,+DAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAgB;AACxB,QAAQ,kEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,GAAG,EAAC","file":"lib_index_js.304e436627c4562112dd.js","sourcesContent":["import Automerge from \"automerge-wasm-bundler\";\nexport const initDocument = () => {\n    return Automerge.init();\n};\nexport const initDocumentText = () => {\n    return Automerge.from({\n        docId: '',\n        textArea: new Automerge.Text()\n    });\n};\nexport const applyChanges = (doc, changes) => {\n    return Automerge.applyChanges(doc, changes);\n};\nexport const getChanges = (oldDoc, newDoc) => {\n    return Automerge.getChanges(oldDoc, newDoc);\n};\nexport const merge = (oldDoc, newDoc) => {\n    return Automerge.merge(oldDoc, newDoc);\n};\nexport const getHistory = (doc) => {\n    return Automerge.getHistory(doc).map(state => [state.change.message, state.snapshot.textArea]);\n};\n","import { IEditorTracker } from '@jupyterlab/fileeditor';\nimport { INotebookTracker } from '@jupyterlab/notebook';\n// import { CodeMirrorEditor } from '@jupyterlab/codemirror';\nimport Automerge from \"automerge-wasm-bundler\";\nimport { initDocument, applyChanges, getChanges, } from \"./AutomergeActions\";\nclass Rtc {\n    constructor(notebookTracker, editorTracker) {\n        this.notebookTracker = notebookTracker;\n        this.editorTracker = editorTracker;\n        this.notebookTracker.activeCellChanged.connect((sender, cell) => this._activeCellChanged(cell));\n        this.editorTracker.widgetAdded.connect((sender, widget) => this._setupFileEditor(widget.content));\n        this.editorTracker.currentChanged.connect((sender, widget) => this._setupFileEditor(widget.content));\n    }\n    _onCellValueChange(value, change) {\n        if (this.rtcCell.textArea) {\n            if (this.cell.model.value.text !== this.rtcCell.textArea.toString()) {\n                const newDoc = Automerge.change(this.rtcCell, (d) => {\n                    if (change.type === 'insert') {\n                        d.textArea.insertAt(change.start, change.value);\n                    }\n                    if (change.type === 'remove') {\n                        d.textArea.deleteAt(change.start, (change.end - change.start));\n                    }\n                });\n                const changes = getChanges(this.rtcCell, newDoc);\n                this.rtcCell = newDoc;\n                this.ws.send(changes[0]);\n            }\n        }\n    }\n    _activeCellChanged(cell) {\n        if (cell != null) {\n            this.rtcCell = initDocument();\n            this.cell = cell;\n            this.cell.editor.model.value.changed.connect((value, change) => this._onCellValueChange(value, change));\n            //      this.ws = new WebSocket(`ws://localhost:8888/jupyterlab_rtc/websocket?doc=${cell.id}`);\n            this.ws = new WebSocket(`ws://localhost:4321/${cell.id}`);\n            this.ws.binaryType = 'arraybuffer';\n            this.ws.onmessage = (message) => {\n                if (message.data) {\n                    const data = new Uint8Array(message.data);\n                    const changedDoc = applyChanges(this.rtcCell, [data]);\n                    this.rtcCell = changedDoc;\n                    const text = this.rtcCell.textArea.toString();\n                    if (this.cell.model.value.text !== text) {\n                        this.cell.model.value.text = text;\n                    }\n                }\n            };\n        }\n    }\n    _onFileEditorValueChange(value, change) {\n        if (this.rtcEditor.textArea) {\n            if (this.fileEditor.model.value.text !== this.rtcEditor.textArea.toString()) {\n                const newDoc = Automerge.change(this.rtcEditor, (d) => {\n                    if (change.type === 'insert') {\n                        d.textArea.insertAt(change.start, change.value);\n                    }\n                    if (change.type === 'remove') {\n                        d.textArea.deleteAt(change.start, (change.end - change.start));\n                    }\n                });\n                const changes = getChanges(this.rtcEditor, newDoc);\n                this.rtcEditor = newDoc;\n                this.ws.send(changes[0]);\n            }\n        }\n    }\n    _setupFileEditor(fileEditor) {\n        if (fileEditor != null) {\n            this.rtcEditor = initDocument();\n            this.fileEditor = fileEditor;\n            this.fileEditor.editor.model.value.changed.connect((value, change) => this._onFileEditorValueChange(value, change));\n            //      this.ws = new WebSocket(`ws://localhost:8888/jupyterlab_rtc/websocket?doc=${cell.id}`);\n            this.ws = new WebSocket(`ws://localhost:4321/${fileEditor.id}`);\n            this.ws.binaryType = 'arraybuffer';\n            this.ws.onmessage = (message) => {\n                if (message.data) {\n                    const data = new Uint8Array(message.data);\n                    const changedDoc = applyChanges(this.rtcEditor, [data]);\n                    this.rtcEditor = changedDoc;\n                    const text = this.rtcEditor.textArea.toString();\n                    if (this.fileEditor.model.value.text !== text) {\n                        this.fileEditor.model.value.text = text;\n                    }\n                }\n            };\n        }\n    }\n}\n/**\n * Initialization data for the @jupyterlab/rtc extension.\n */\nconst rtc = {\n    id: '@jupyterlab/rtc:extension',\n    autoStart: true,\n    requires: [\n        INotebookTracker,\n        IEditorTracker\n    ],\n    activate: (app, notebookTracker, editorTracker) => {\n        const rtc = new Rtc(notebookTracker, editorTracker);\n        console.log('JupyterLab extension @jupyterlab/rtc is activated!', rtc);\n    }\n};\nexport default rtc;\n"],"sourceRoot":""}