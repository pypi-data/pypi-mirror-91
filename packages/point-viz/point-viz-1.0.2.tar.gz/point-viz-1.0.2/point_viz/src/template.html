<!DOCTYPE html>
<html lang="en">
<head>
	<title>TASK_NAME</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../src/main.css">
    <script src="../src/build/d3.v4.min.js"></script>
    <script src="../src/jsm/libs/npyjs.js"></script>
	<!--<script src="//unpkg.com/three-spritetext"></script>-->
</head>
<body>
,
<div id="container"></div>
<div id="info"><a href="https://github.com/SUZhaoyu/point_viz" target="_blank" rel="noopener">point_viz</a> TASK_NAME </div>

<script type="module">

	import * as THREE from '../src/build/three.module.js';
	import  Stats  from '../src/jsm/libs/stats.module.js';
	import { GUI } from '../src/jsm/libs/dat.gui.module.js';
    import { OrbitControls } from '../src/jsm/controls/OrbitControls.js';
    // var npyjs = require('npyjs');
    // const sleep = t => new Promise(s => setTimeout(s, t));
	
	var container, stats;
	var camera, scene, renderer, camera_controls;
	var points;
	var points_bin, bbox_csv, points_csv;
	var stride = 6; // x, y, z, r, g, b
	var npy = new npyjs();


	init();
	animate();
	function roundRect(ctx, x, y, w, h, r)
	{
	    ctx.beginPath();
	    ctx.moveTo(x+r, y);
	    ctx.lineTo(x+w-r, y);
	    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
	    ctx.lineTo(x+w, y+h-r);
	    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
	    ctx.lineTo(x+r, y+h);
	    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
	    ctx.lineTo(x, y+r);
	    ctx.quadraticCurveTo(x, y, x+r, y);
	    ctx.closePath();
	    ctx.fill();
		ctx.stroke();
	}
	function makeTextSprite( message, parameters )
	{
		if ( parameters === undefined ) parameters = {};

		var fontface = parameters.hasOwnProperty("fontface") ?
			parameters["fontface"] : "Arial";

		var fontsize = parameters.hasOwnProperty("fontsize") ?
			parameters["fontsize"] : 18;

		var borderThickness = parameters.hasOwnProperty("borderThickness") ?
			parameters["borderThickness"] : 0.2;

		var borderColor = parameters.hasOwnProperty("borderColor") ?
			parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };

		var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
			parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

		// var spriteAlignment = THREE.SpriteAlignment.topLeft;

		var canvas = document.createElement('canvas');
		var context = canvas.getContext('2d');
		context.font = "Bold " + fontsize + "px " + fontface;

		// get size data (height depends only on font size)
		var metrics = context.measureText( message );
		var textWidth = metrics.width;

		// background color
		context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
									  + backgroundColor.b + "," + backgroundColor.a + ")";
		// border color
		context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
									  + borderColor.b + "," + borderColor.a + ")";

		context.lineWidth = borderThickness;
		roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
		// 1.4 is extra height factor for text below baseline: g,j,p,q.

		// text color
		context.fillStyle = "rgba(255, 255, 255, 1.0)";

		context.fillText( message, borderThickness, fontsize + borderThickness);

		// canvas contents will be used for a texture
		var texture = new THREE.Texture(canvas);
		texture.needsUpdate = true;

		var spriteMaterial = new THREE.SpriteMaterial(
			{ map: texture, useScreenCoordinates: false } );
		var sprite = new THREE.Sprite( spriteMaterial );
		sprite.scale.set(0.1,0.05,1.0);
		return sprite;
	}

	function init() {
		// // Check for the various File API support.
		if (window.File && window.FileReader && window.FileList && window.Blob) {
		// Great success! All the File APIs are supported.

			npy.load("../data/INPUT_PC_CSV", function(res) {
				// `array` is a one-dimensional array of the raw data
				// `shape` is a one-dimensional array that holds a numpy-style shape.
				points_bin = res.data;
				// alert(res.shape);
				// alert(res.data.length);
				// alert(
				// 	`You loaded an array with ${array.length} elements and ${shape.length} dimensions.`
				// );
				gui_controls.redraw_points();

			});



		} else {
			alert('The File APIs are not fully supported in this browser.');
		}


		d3.csv("../data/INPUT_BBOX_CSV", function(data) {
			bbox_csv = data;
			gui_controls.redraw_bboxes();
		});



		container = document.getElementById('container');

		//


		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
		camera.layers.enable( 0 );
		camera.layers.enable( 1 );
		camera.layers.enable( 2 );
		camera.position.z = .5;
		camera.position.x = .5;
		camera.position.y = 0.25;

		renderer = new THREE.WebGLRenderer({alpha: true});
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);

		scene = new THREE.Scene();
		const axesHelper = new THREE.AxesHelper( 0.1 );
		scene.add( axesHelper );

		camera_controls = new OrbitControls(camera, renderer.domElement);
		camera_controls.enableDamping = true;
    	camera_controls.dampingFactor =  0.8;


		var gui_controls = new function () {
			this.pointSize = 2;
			this.opacity = 1.0;
			this.defaultColor=true;
			this.uniColor = 0xFFFFFF;
			this.bboxWidth = 2;

			this.redraw_points = function () {
				if (scene.getObjectByName("particles")) {
					scene.remove(scene.getObjectByName("particles"));
				}
				createParticles(gui_controls.pointSize,
								gui_controls.opacity,
								gui_controls.defaultColor,
								gui_controls.uniColor);
				render();

			};

			this.redraw_bboxes = function () {
				if (scene.getObjectByName("bboxes")) {
					scene.remove(scene.getObjectByName("bboxes"));
				}
				createBboxes(gui_controls.bboxWidth);
				render();
			};
        };
		var layers = { bbox: true, labelText: true};
		var gui = new GUI();
		console.log(gui);
		gui.add(gui_controls, 'pointSize', 0.1, 10).onChange(gui_controls.redraw_points);
		gui.add(gui_controls, 'opacity', 0, 1).onChange(gui_controls.redraw_points);
		gui.add(gui_controls, 'defaultColor').onChange(gui_controls.redraw_points);
		gui.addColor(gui_controls, 'uniColor').onChange(gui_controls.redraw_points);
		gui.add(layers, 'bbox').onChange(function(){camera.layers.toggle(1); render();});
		gui.add(layers, 'labelText').onChange(function(){camera.layers.toggle(2); render();});
        render();
        // alert(Object.keys(gui));
        // alert(Object.keys(gui_controls));

        
		function createParticles(size, opacity, defaultColor, uniColor) {
			if (defaultColor) {
				uniColor = 0xffffff;
			}
			var geometry = new THREE.BufferGeometry();
			var material = new THREE.PointsMaterial({
				size: size,
				vertexColors: defaultColor,
				transparent: true,
				sizeAttenuation: false,
				opacity: opacity,
				color: uniColor,
			});
			var positions = [];
			var colors = [];
			var color = new THREE.Color();

			for (var i = 0, l = points_bin.length / stride; i < l; i++) {
				var x = points_bin[i * stride + 0];
				var y = points_bin[i* stride + 1];
				var z = points_bin[i* stride + 2];
				var r = points_bin[i* stride + 3] / 255.;
				var g = points_bin[i* stride + 4] / 255.;
				var b = points_bin[i* stride + 5] / 255.;
				positions.push(x, y, z);
				color.setRGB(r, g, b);
				colors.push(color.r, color.g, color.b);
			}
			geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
			geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
			geometry.computeBoundingSphere();

			points = new THREE.Points(geometry, material);
			points.name = "particles";
			points.layers.set(0);
			scene.add(points);
		}



		function createBboxes(width) {
			for (var i = 0; i < bbox_csv.length; i++){
				var text = bbox_csv[i].label_text;
				var l = parseFloat(bbox_csv[i].l);
				var w = parseFloat(bbox_csv[i].w);
				var h = parseFloat(bbox_csv[i].h);
				var x = parseFloat(bbox_csv[i].x);
				var y = parseFloat(bbox_csv[i].y);
				var z = parseFloat(bbox_csv[i].z);
				var r = parseFloat(bbox_csv[i].r);
				var c = bbox_csv[i].color;


				var color = new THREE.Color(c);
				// console.log(bbox_csv[i].color);

				var geometry = new THREE.BoxBufferGeometry(l, h, w);
				var edges = new THREE.EdgesGeometry(geometry);
				var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial({color: color, linewidth: width}));
				line.position.set(x, y, z);
				line.rotation.y = r;
				line.layers.set(1);
				scene.add(line);
				// y = y + 0.001;
				if (text !== ' ') {
					var spritey = makeTextSprite(text,
						{fontsize: 25,
						 borderColor: {r:0, g:0, b:0, a:1.0},
						 backgroundColor: {r:255, g:100, b:100, a:1.0} } );
					spritey.position.setX(x);
					spritey.position.setY(y + h / 2. - 0.01);
					spritey.position.setZ(z);
					spritey.layers.set(2);
					scene.add(spritey);
				}
			}
		}

		container.appendChild( renderer.domElement );
		stats = new Stats();
		container.appendChild( stats.dom );
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}

	function animate() {
		requestAnimationFrame( render );
		// camera_controls.update();
		// renderer.render( scene, camera );

		// render();
		camera_controls.addEventListener('change', render);
		window.addEventListener( 'resize', onWindowResize, false );
		stats.update();
	}

	function render() {
		// requestAnimationFrame( animate );
		// camera_controls.update();
		renderer.render( scene, camera );
	}



</script>

</body>
</html>