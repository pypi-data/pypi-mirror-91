{"version":3,"sources":["WebRtcStreamer.tsx","VisibilitySwitch.tsx","index.tsx"],"names":["isWebRtcMode","val","setupOffer","pc","createOffer","then","offer","console","log","setLocalDescription","Promise","resolve","iceGatheringState","addEventListener","checkState","removeEventListener","localDescription","catch","err","error","WebRtcStreamer","props","videoRef","audioRef","processAnswerInner","sdpAnswerJson","a","sdpAnswer","JSON","parse","setRemoteDescription","processAnswer","finally","setState","signaling","startInner","mode","args","Error","hasVideo","hasAudio","config","settings","rtc_configuration","RTCPeerConnection","evt","track","kind","videoElem","current","srcObject","streams","audioElem","defaultConstraints","audio","video","constraints","media_stream_constraints","navigator","mediaDevices","getUserMedia","stream","getTracks","forEach","addTrack","getTransceivers","direction","addTransceiver","playing","toJSON","Streamlit","setComponentValue","sdpOffer","warn","start","stopInner","undefined","transceiver","stop","getSenders","sender","setTimeout","close","stopping","render","buttonDisabled","disabled","state","receivable","isReceivable","visible","onVisibilityChange","setImmediate","setFrameHeight","style","width","ref","autoPlay","controls","onCanPlay","variant","onClick","color","React","createRef","this","remoteDescription","StreamlitComponentBase","withStreamlitConnection","VisibilitySwitch","divProps","useEffect","display","theme","createMuiTheme","overrides","MuiCssBaseline","body","backgroundColor","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7a1f2599.chunk.js","sourcesContent":["import {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n  ComponentProps,\n} from \"streamlit-component-lib\";\nimport React, { ReactNode } from \"react\";\nimport Box from \"@material-ui/core/Box\";\nimport Button from \"@material-ui/core/Button\";\nimport VisibilitySwitch from \"./VisibilitySwitch\";\n\ntype WebRtcMode = \"RECVONLY\" | \"SENDONLY\" | \"SENDRECV\";\nconst isWebRtcMode = (val: unknown): val is WebRtcMode =>\n  val === \"RECVONLY\" || val === \"SENDONLY\" || val === \"SENDRECV\";\nconst isReceivable = (mode: WebRtcMode): boolean =>\n  mode === \"SENDRECV\" || mode === \"RECVONLY\";\n\nconst setupOffer = (\n  pc: RTCPeerConnection\n): Promise<RTCSessionDescription | null> => {\n  return pc\n    .createOffer()\n    .then((offer) => {\n      console.log(\"Created offer:\", offer);\n      return pc.setLocalDescription(offer);\n    })\n    .then(() => {\n      console.log(\"Wait for ICE gethering...\");\n      // Wait for ICE gathering to complete\n      return new Promise<void>((resolve) => {\n        if (pc.iceGatheringState === \"complete\") {\n          resolve();\n        } else {\n          const checkState = () => {\n            if (pc.iceGatheringState === \"complete\") {\n              pc.removeEventListener(\"icegatheringstatechange\", checkState);\n              resolve();\n            }\n          };\n          pc.addEventListener(\"icegatheringstatechange\", checkState);\n        }\n      });\n    })\n    .then(() => {\n      const offer = pc.localDescription;\n      return offer;\n    })\n    .catch((err) => {\n      console.error(err);\n      throw err;\n    });\n};\n\ninterface State {\n  signaling: boolean;\n  playing: boolean;\n  stopping: boolean;\n  hasVideo: boolean;\n  hasAudio: boolean;\n}\n\nclass WebRtcStreamer extends StreamlitComponentBase<State> {\n  private pc: RTCPeerConnection | undefined;\n  private videoRef: React.RefObject<HTMLVideoElement>;\n  private audioRef: React.RefObject<HTMLAudioElement>;\n\n  constructor(props: ComponentProps) {\n    super(props);\n    this.videoRef = React.createRef();\n    this.audioRef = React.createRef();\n\n    this.state = {\n      signaling: false,\n      playing: false,\n      stopping: false,\n      hasVideo: false,\n      hasAudio: false,\n    };\n  }\n\n  private processAnswerInner = async (\n    pc: RTCPeerConnection,\n    sdpAnswerJson: string\n  ): Promise<void> => {\n    const sdpAnswer = JSON.parse(sdpAnswerJson);\n    console.log(\"Receive answer sdpOffer\", sdpAnswer);\n    await pc.setRemoteDescription(sdpAnswer);\n  };\n\n  private processAnswer = (\n    pc: RTCPeerConnection,\n    sdpAnswerJson: string\n  ): void => {\n    this.processAnswerInner(pc, sdpAnswerJson)\n      .then(() => {\n        console.log(\"Remote description is set\");\n      })\n      .finally(() => this.setState({ signaling: false }));\n  };\n\n  private startInner = async () => {\n    const mode = this.props.args[\"mode\"];\n    if (!isWebRtcMode(mode)) {\n      throw new Error(`Invalid mode ${mode}`);\n    }\n\n    this.setState({ signaling: true, hasVideo: false, hasAudio: false });\n\n    const config: RTCConfiguration =\n      this.props.args.settings?.rtc_configuration || {};\n    console.log(\"RTCConfiguration:\", config);\n    const pc = new RTCPeerConnection(config);\n\n    // Connect received audio / video to DOM elements\n    if (mode === \"SENDRECV\" || mode === \"RECVONLY\") {\n      pc.addEventListener(\"track\", (evt) => {\n        if (evt.track.kind === \"video\") {\n          const videoElem = this.videoRef.current;\n          if (videoElem == null) {\n            console.error(\"video element is not mounted\");\n            return;\n          }\n\n          videoElem.srcObject = evt.streams[0];\n          this.setState({ hasVideo: true });\n        } else {\n          const audioElem = this.audioRef.current;\n          if (audioElem == null) {\n            console.error(\"audio element is not mounted\");\n            return;\n          }\n\n          audioElem.srcObject = evt.streams[0];\n          this.setState({ hasAudio: true });\n        }\n      });\n    }\n\n    // Set up transceivers\n    if (mode === \"SENDRECV\" || mode === \"SENDONLY\") {\n      const defaultConstraints = {\n        audio: true,\n        video: true,\n      };\n      const constraints: MediaStreamConstraints =\n        this.props.args.settings?.media_stream_constraints ||\n        defaultConstraints;\n      console.log(\"MediaStreamConstraints:\", constraints);\n\n      if (constraints.audio || constraints.video) {\n        const stream = await navigator.mediaDevices.getUserMedia(constraints);\n        stream.getTracks().forEach((track) => {\n          pc.addTrack(track, stream);\n        });\n      }\n\n      if (mode === \"SENDONLY\") {\n        for (const transceiver of pc.getTransceivers()) {\n          transceiver.direction = \"sendonly\";\n        }\n      }\n    } else if (mode === \"RECVONLY\") {\n      pc.addTransceiver(\"video\", { direction: \"recvonly\" });\n      pc.addTransceiver(\"audio\", { direction: \"recvonly\" });\n    }\n\n    this.setState({ playing: true });\n\n    console.log(\"transceivers\", pc.getTransceivers());\n\n    setupOffer(pc).then((offer) => {\n      if (offer == null) {\n        console.warn(\"Failed to create an offer SDP\");\n        return;\n      }\n\n      console.log(\"Send sdpOffer\", offer.toJSON());\n      Streamlit.setComponentValue({\n        sdpOffer: offer.toJSON(),\n        playing: true,\n      });\n    });\n    this.pc = pc;\n  };\n\n  private start = (): void => {\n    this.startInner().catch(() => this.setState({ signaling: false }));\n  };\n\n  private stopInner = async (): Promise<void> => {\n    const pc = this.pc;\n    this.pc = undefined;\n    this.setState({ playing: false }, () =>\n      Streamlit.setComponentValue({ playing: false })\n    );\n\n    if (pc == null) {\n      return Promise.resolve();\n    }\n\n    // close transceivers\n    if (pc.getTransceivers) {\n      pc.getTransceivers().forEach(function (transceiver) {\n        if (transceiver.stop) {\n          transceiver.stop();\n        }\n      });\n    }\n\n    // close local audio / video\n    pc.getSenders().forEach(function (sender) {\n      sender.track?.stop();\n    });\n\n    // close peer connection\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        pc.close();\n        resolve();\n      }, 500);\n    });\n  };\n\n  private stop = () => {\n    this.setState({ stopping: true });\n    this.stopInner().finally(() => {\n      this.setState({ stopping: false, hasVideo: false, hasAudio: false });\n    });\n  };\n\n  public componentDidUpdate() {\n    if (this.pc == null) {\n      return;\n    }\n    const pc = this.pc;\n    if (pc.remoteDescription == null) {\n      const sdpAnswerJson = this.props.args[\"sdp_answer_json\"];\n      if (sdpAnswerJson) {\n        this.processAnswer(pc, sdpAnswerJson);\n      }\n    }\n  }\n\n  public render = (): ReactNode => {\n    const buttonDisabled =\n      this.props.disabled || this.state.signaling || this.state.stopping;\n    const mode = this.props.args[\"mode\"];\n    const receivable = isWebRtcMode(mode) && isReceivable(mode);\n\n    return (\n      <Box>\n        <VisibilitySwitch\n          visible={receivable}\n          onVisibilityChange={() => setImmediate(Streamlit.setFrameHeight)}\n        >\n          <Box>\n            <video\n              style={{\n                width: \"100%\",\n              }}\n              ref={this.videoRef}\n              autoPlay\n              controls\n              onCanPlay={() => Streamlit.setFrameHeight()}\n            />\n          </Box>\n          <Box>\n            <audio ref={this.audioRef} autoPlay controls />\n          </Box>\n        </VisibilitySwitch>\n        <Box>\n          {this.state.playing ? (\n            <Button\n              variant=\"contained\"\n              onClick={this.stop}\n              disabled={buttonDisabled}\n            >\n              Stop\n            </Button>\n          ) : (\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              onClick={this.start}\n              disabled={buttonDisabled}\n            >\n              Start\n            </Button>\n          )}\n        </Box>\n      </Box>\n    );\n  };\n}\n\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default withStreamlitConnection(WebRtcStreamer);\n","import React, { useEffect } from \"react\";\n\ninterface VisibilitySwitchProps extends React.ComponentProps<\"div\"> {\n  visible?: boolean;\n  onVisibilityChange: (newVisibility: boolean) => void;\n}\nconst VisibilitySwitch = ({\n  visible = true,\n  onVisibilityChange,\n  ...divProps\n}: VisibilitySwitchProps) => {\n  useEffect(() => {\n    onVisibilityChange(visible);\n  }, [visible, onVisibilityChange]);\n\n  return (\n    <div\n      style={{\n        ...divProps.style,\n        display: visible ? divProps.style?.display : \"none\",\n      }}\n      {...divProps}\n    />\n  );\n};\n\nexport default VisibilitySwitch;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { createMuiTheme, ThemeProvider } from \"@material-ui/core/styles\";\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport WebRtcStreamer from \"./WebRtcStreamer\";\n\nconst theme = createMuiTheme({\n  overrides: {\n    MuiCssBaseline: {\n      \"@global\": {\n        body: {\n          // Unset the background-color since <CssBaseLine /> applies the default Material Design background color\n          // (https://material-ui.com/components/css-baseline/#approach),\n          // which however does not match the Streamlit's background.\n          backgroundColor: \"initial\",\n        },\n      },\n    },\n  },\n});\n\nReactDOM.render(\n  <React.StrictMode>\n    <ThemeProvider theme={theme}>\n      <CssBaseline />\n      <WebRtcStreamer />\n    </ThemeProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}